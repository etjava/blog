/*
SQLyog 企业版 - MySQL GUI v8.14 
MySQL - 5.7.39 : Database - db_blog
*********************************************************************
*/

/*!40101 SET NAMES utf8 */;

/*!40101 SET SQL_MODE=''*/;

/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
CREATE DATABASE /*!32312 IF NOT EXISTS*/`db_blog` /*!40100 DEFAULT CHARACTER SET utf8 */;

USE `db_blog`;

/*Table structure for table `t_album` */

DROP TABLE IF EXISTS `t_album`;

CREATE TABLE `t_album` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `albumName` varchar(64) DEFAULT NULL COMMENT '专辑名称',
  `releaseDate` date DEFAULT NULL COMMENT '专辑发布时间',
  `state` int(11) DEFAULT NULL COMMENT '是否有效 0 无效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

/*Data for the table `t_album` */

/*Table structure for table `t_blog` */

DROP TABLE IF EXISTS `t_blog`;

CREATE TABLE `t_blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(256) DEFAULT NULL,
  `summary` varchar(512) DEFAULT NULL,
  `releaseDate` datetime DEFAULT NULL,
  `clickHit` int(11) DEFAULT NULL,
  `replyHit` int(11) DEFAULT NULL,
  `content` text,
  `typeId` int(11) DEFAULT NULL,
  `keyword` varchar(64) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=93 DEFAULT CHARSET=utf8;

/*Data for the table `t_blog` */

insert  into `t_blog`(`id`,`title`,`summary`,`releaseDate`,`clickHit`,`replyHit`,`content`,`typeId`,`keyword`) values (1,'aa','aa','2022-01-01 00:00:00',9,1,'aa',1,'aa'),(2,'bb','bb','2022-02-02 00:00:00',35,2,'aa',2,'bb'),(3,'cc','cc','2022-03-03 00:00:00',50,13,'33',1,'cc'),(39,'Java HelloWorld实现',' 第一个博客，当然从HelloWorld 开发，主要测试下 百度ueditor的代码高亮效果如何。下面上代码：package com.java1234.demo;/** * 测试 * @author Administrator * */public class HelloWorld {  public stat','2016-02-02 10:00:42',289,18,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/> 第一个博客，当然从HelloWorld 开发，主要测试下 百度ueditor的代码高亮效果如何。</p><p><br/></p><p>下面上代码：</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.demo;\n\n/**\n&nbsp;*&nbsp;测试\n&nbsp;*&nbsp;@author&nbsp;Administrator\n&nbsp;*\n&nbsp;*/\npublic&nbsp;class&nbsp;HelloWorld&nbsp;{\n\n  public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n     System.out.println(&quot;Hello&nbsp;World，屌炸天！&quot;);\n    }\n}</pre><p><br/></p><p>代码高亮还算凑合，如果加上 复制代码功能，会更好点；</p><p><br/></p><p>运行效果如下：</p><p><img src=\"/static/userImages/20160202/1454378386640040323.jpg\" title=\"1454378386640040323.jpg\" alt=\"QQ鎴浘20160202095931.jpg\"/></p><p><br/></p><p><br/></p><p>这个图我是直接用百度ueditor直接截图的，很方便。这个是我选用百度ueditor在线编辑器的一个重要原因。</p><p><br/></p><p><br/></p>',1,'java'),(40,'大学必须掌握的软件基础课程',' 大学软件专业有很多课程，有些学生搞不清哪些是重点，以下是笔者根据多年经验，认真很重要的课程罗列下：1，C语言  很重要，作为学编程的入门语言，也是众多流行编程语言之父。2，数据结构和算法很重要，以后深入理解一些东西有帮助，即使是Java把很多数据结构都进行了封装，但是学习本课程，可以对性能有深入理解；3，计','2016-02-02 12:41:52',323,9,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>&nbsp;大学软件专业有很多课程，有些学生搞不清哪些是重点，以下是笔者根据多年经验，认真很重要的课程罗列下：</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>1，C语言 &nbsp;</strong></span></p><p>很重要，作为学编程的入门语言，也是众多流行编程语言之父。</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>2，数据结构和算法</strong></span></p><p>很重要，以后深入理解一些东西有帮助，即使是Java把很多数据结构都进行了封装，但是学习本课程，可以对性能有深入理解；</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>3，计算机组成原理</strong></span></p><p>一般，学习一下；</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>4，编译原理</strong></span></p><p>一般，学习一下；</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>5，数据库原理</strong></span></p><p>很重要，对以后系统的数据库设计有帮助，站的层次高；</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>6，操作系统原理</strong></span></p><p>很重要，对以后技术提供，和层次有帮助；</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>7，计算机网络</strong></span></p><p>一般，学习一下；</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>8，软件工程</strong></span></p><p>非常重要，对整个软件开发体系的熟悉，直接可以影响到一个技术人员的职业生涯；</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong>9，计算机英语</strong></span></p><p>非常重要，有一些屌丝不重视，这个真的很重要，以后学习一些新技术的时候，有时候中文资源比较少，这时候学习，基本是直接看官方英文文档，假如英语不行，会很苦逼；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">10，英语</span></strong></p><p>非常重要，这个和上面的计算机英语有区别，计算机英语主要是一些专业词汇的中文专业翻译；而英语的话，是更加广泛的概念，最少要达到4级，最好6级。大学时候通读基本英文技术书籍，我推荐 Head First系列，以及Thining in Java；</p><p><br/></p><p>以上是我认为比较重要的10个课程。大家可以参考下。。可以有遗漏，大家可以评论留言。讨论交流。</p><p><br/></p><p><span style=\"color: rgb(255, 0, 0);\"><strong><br/></strong></span></p>',4,'大学'),(41,'大学里应该掌握的两个能力','  根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；第一种能力，自学能力；所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；这种能力如何培养呢？根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就','2016-02-02 13:14:53',317,8,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0003.gif\"/> &nbsp;根据我的经验，我总结了下，大学里掌握以下两种，毕业的时候，用人单位比较喜欢；</p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第一种能力，自学能力；</span></strong></p><p>所谓自学能力，顾名思义，就是自我学习知识，技术的能力，这种能力，人与人之间的差距有大，就像有的人毕业能拿13K，有的人只能拿3K；</p><p>这种能力如何培养呢？</p><p>根据我的经验，没有捷径，就是多读书，多思考，多实践，还有就是稍微多做点笔记，多总结；</p><p>很多人自学能力差，大多数原因不是笨，是读书少，见识少。读书少，基础差，想学点新东西都吃力，底子问题；</p><p>学习方法方面，我有些心得；</p><p>有些二货拿到书，直接从头读到尾，而且不允许自己有遗漏，这个是一种效率很底下的学习方法；</p><p>我的建议如下：</p><p>第一：拿到一本书，先自己想想，是不是自己需要的书，网上多查查，这本书好不好，书的人写的，作者有牛逼的，也有比较渣；</p><p>第二：决定看一本书的时候，一定要先看目录大纲，把目录好好看看，这本书讲啥，章节的划分；然后脑海里有大体映像之后，再看具体章节；说简单点，就是先总后分；</p><p>第三：学习的时候，一定要做笔记，写总结；这样才会有提高；最好是写到自己的博客里；</p><p><br/></p><p><br/></p><p><strong><span style=\"color: rgb(255, 0, 0);\">第二种能力，分析问题和解决问题的能力；</span></strong></p><p>第二种能力，很关键，尤其是搞开发的人，这种能力直接关系到自己的前途；</p><p>比如组长或者项目经理给你一个需求，让你开发出来，我举个具体的例子，组长让你开发一个功能，从数据库取数据库，生成word，并且导出；</p><p>有些人一看这功能，顿时晕了，自己没搞过，老师没教过。无从下手。顿时感觉人生好迷茫；</p><p>这时候就是体现一个人分析问题和解决问题的能力了；</p><p>正常分析过程是这样的，首先是查询数据，然后生成一个word，页面请求，返回word文件流；这里涉及到生成word，可以通过百度关键字 java生成word；</p><p>可以看到有很多的技术方案，这时候，你再百度具体的方案的比较，当然也可以论坛，群里交流。比如velocity freemarker；找到方案后，就是学习这个技术，</p><p>这个就是上面的自学能力的体现，如何快速入门掌握，当然，这种简单的技术，直接搞点demo，运行下，很容易上手；不需要看书；</p><p>如何这种培养能力呢？</p><p>没有捷径，就是要多读书，多学习，多思考，以及最重要，多实践，多搞点小项目，搞的时候会遇到很多问题，设计问题，调试问题，技术方案问题等等；</p><p>遇到问题，解决问题。能力就是这样慢慢提高的。不是什么一下子就变成大神，除非你在做梦；<br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/>加油吧。骚年们！</p><p><br/></p>',4,'大学'),(42,'Mysql中文乱码问题解决','有些学员经常遇到 项目jdbc获取数据库数据，中文乱码；这里给出一些解决方案：第一种，修改Mysql数据库编码，改成utf-8，默认是latin1 （推荐）； 如图，找到mysql安装，点mysql实例配置  一直点next知道下面这个界面：记住，前面那个圈 一点要点。。下拉框选utf8继续next直到：写你','2016-02-02 13:29:33',198,6,'<p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">有些学员经常遇到 项目jdbc获取数据库数据，中文乱码；</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><br/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">这里给出一些解决方案：</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><br/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><span style=\"color: rgb(255, 0, 0);\">第一种，修改Mysql数据库编码，改成utf-8，默认是latin1 （推荐）；</span></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><img alt=\"QQ鍥剧墖20160202132103.png\" src=\"/static/userImages/20160202/1454390480343030776.png\" title=\"1454390480343030776.png\"/> 如图，找到mysql安装，点mysql实例配置</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><br/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><img src=\"/static/userImages/20160202/1454390537171022264.jpg\" alt=\"1454390537171022264.jpg\"/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">&nbsp;</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">&nbsp;一直点next知道下面这个界面：</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><img alt=\"QQ鍥剧墖20160202132310.png\" src=\"/static/userImages/20160202/1454390616812058607.png\" title=\"1454390616812058607.png\"/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">记住，前面那个圈 一点要点。。下拉框选utf8</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><br/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">继续next直到：</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><img alt=\"QQ鍥剧墖20160202132431.png\" src=\"/static/userImages/20160202/1454390692687028654.png\" title=\"1454390692687028654.png\"/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">写你原来的密码继续，然后继续Next:</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><img alt=\"QQ鍥剧墖20160202132517.png\" src=\"/static/userImages/20160202/1454390731515038389.png\" title=\"1454390731515038389.png\"/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">点击 执行</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><img alt=\"QQ鍥剧墖20160202132618.png\" src=\"/static/userImages/20160202/1454390793796097934.png\" title=\"1454390793796097934.png\"/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">这样就OK了；</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><br/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">这个执行完。记得要把原来导入的项目数据库删除，重新的导入下即可；<br/></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><br/><span style=\"color: rgb(255, 0, 0);\"></span></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\"><span style=\"color: rgb(255, 0, 0);\">第二种，修改jdbc请求url 指定编码 （不推荐）<br/></span></p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">在jdbc url后面 加上 ?useUnicode=true&amp;characterEncoding=UTF8 指定下编码；</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">假如是在xml配置文件里 要转义下 搞成 ?useUnicode=true&amp;amp;characterEncoding=UTF-8 ；</p><p style=\"margin: 5px 0px; color: rgb(0, 0, 0); font-family: sans-serif; font-size: 16px; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: auto; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 1; word-spacing: 0px; -webkit-text-stroke-width: 0px;\">比如在spring配置文件里：</p><pre class=\"brush:xml;toolbar:false\">&lt;!--&nbsp;配置数据源&nbsp;--&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;bean&nbsp;id=&quot;dataSource&quot;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;url&quot;&nbsp;value=&quot;jdbc:mysql://localhost:3306/db_blog?useUnicode=true&amp;amp;characterEncoding=UTF-8&quot;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;username&quot;&nbsp;value=&quot;root&quot;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;property&nbsp;name=&quot;password&quot;&nbsp;value=&quot;123456&quot;/&gt;\n&nbsp;&nbsp;&nbsp;&nbsp;&lt;/bean&gt;</pre><p><br/></p><p>推荐第一种；</p><p><br/></p>',2,'mysql 乱码'),(43,'解决Url带中文参数乱码问题',' 这里我来介绍下如何配置Tomcat 来解决Url带中文参数乱码问题；首先打开Tomcat安装目录，以Tomcat7为例，其他版本基本一样；打开conf文件打开server.xml大概在70行左右的位置 我们加一个属性 URIEncoding=\"UTF-8\"搞成这样即可。。这个是发布项目的时候，配置方式。下面','2016-01-22 13:38:39',191,2,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0001.gif\"/> 这里我来介绍下如何配置Tomcat 来解决Url带中文参数乱码问题；</p><p><br/></p><p>首先打开Tomcat安装目录，以Tomcat7为例，其他版本基本一样；</p><p><img src=\"/static/userImages/20160202/1454391117593077429.jpg\" alt=\"1454391117593077429.jpg\"/></p><p><br/></p><p>打开conf文件</p><p><img src=\"/static/userImages/20160202/1454391166890014358.jpg\" alt=\"1454391166890014358.jpg\"/><br/></p><p><br/></p><p>打开server.xml</p><p><img src=\"/static/userImages/20160202/1454391299968024532.jpg\" alt=\"1454391299968024532.jpg\"/><br/></p><p><br/></p><p>大概在70行左右的位置 我们加一个属性 URIEncoding=&quot;UTF-8&quot;</p><p><br/></p><p><img src=\"/static/userImages/20160202/1454391361171014090.jpg\" alt=\"1454391361171014090.jpg\"/></p><p><br/></p><p>搞成这样即可。。这个是发布项目的时候，配置方式。</p><p><br/></p><p>下面介绍开发的时候，如何配置：</p><p>打开eclipse</p><p>找到server</p><p><img src=\"/static/userImages/20160202/1454391411687030232.jpg\" alt=\"1454391411687030232.jpg\"/><br/></p><p><br/></p><p>点开server.xml</p><p><img src=\"/static/userImages/20160202/1454391443968032571.jpg\" alt=\"1454391443968032571.jpg\"/><br/></p><p><br/></p><p>和刚才一样，加下 URIEncoding=&quot;UTF-8&quot; 这样就支持Url中文参数了；</p><p><br/></p><p>当然还有其他方法，比较麻烦。比如自己转码，过滤。这里就不介绍了。<br/></p>',3,'url中文参数'),(44,'人生需要奋斗','今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要轻言放弃。--马云','2016-02-02 14:03:06',252,18,'<p>今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要轻言放弃。--马云</p><p><img alt=\"1-1510121339113S.jpg\" src=\"/static/userImages/20160202/1454392975421022042.jpg\" title=\"1454392975421022042.jpg\"/></p>',5,NULL),(45,'shiro介绍以及推荐视频教程','shiro是apache提供的强大而灵活的开源安全框架，它主要用来处理身份认证，授权，企业会话管理和加密。shiro功能：用户验证、用户执行访问权限控制、在任何环境下使用session API，如cs程序。可以使用多数据源如同时使用oracle、mysql。单点登录(sso)支持。remember me服务。','2016-02-02 17:00:30',361,25,'<p>shiro是apache提供的强大而灵活的开源安全框架，它主要用来处理身份认证，授权，企业会话管理和加密。</p><p>shiro功能：用户验证、用户执行访问权限控制、在任何环境下使用session API，如cs程序。可以使用多数据源如同时使用oracle、mysql。单点登录(sso)支持。remember me服务。</p><p><br/></p><p>推荐视频教程 一头扎进shiro&nbsp;</p><p>课程目录：<span class=\"Apple-tab-span\" style=\"white-space: pre;\"> </span><a href=\"http://www.java1234.com/zy032.html\" target=\"_blank\" title=\"http://www.java1234.com/zy032.html\">http://www.java1234.com/zy032.html</a><span class=\"Apple-tab-span\" style=\"white-space: pre;\">  </span></p><p>百度云打包下载： &nbsp;<a href=\"http://pan.baidu.com/s/1ntEifgt\" target=\"_blank\" title=\"http://pan.baidu.com/s/1ntEifgt\">http://pan.baidu.com/s/1ntEifgt</a></p>',7,'shiro java'),(47,'什么是webservice?','  webservice 有的人一看到这个，估计会认为这个是一种新技术，一种新框架。其实不是，严格的说，webservice是一种跨平台，跨语言的规范，用于不同平台，不同语言开发的应用之间的交互。  这里具体举个例子，比如在Windows Server服务器上有个C#.Net开发的应用A，在Linux上有个J','2016-02-03 16:07:31',302,15,'<p>&nbsp; webservice 有的人一看到这个，估计会认为这个是一种新技术，一种新框架。<br/></p><p>其实不是，严格的说，webservice是一种跨平台，跨语言的规范，用于不同平台，不同语言开发的应用之间的交互。</p><p><br/></p><p>&nbsp; 这里具体举个例子，比如在Windows Server服务器上有个C#.Net开发的应用A，在Linux上有个Java语言开发的应用B，</p><p>B应用要调用A应用，或者是互相调用。用于查看对方的业务数据。</p><p>&nbsp; 再举个例子，天气预报接口。无数的应用需要获取天气预报信息；这些应用可能是各种平台，各种技术实现；而气象局的项目，估计也就一两种，要对外提供天气预报信息，这个时候，如何解决呢？</p><p><br/></p><p>&nbsp; webservice就是出于以上类似需求而定义出来的规范；</p><p>&nbsp;&nbsp;</p><p>&nbsp; 开发人员一般就是在具体平台开发webservice接口，以及调用webservice接口；每种开发语言都有自己的webservice实现框架。比如Java 就有&nbsp;Apache Axis1、Apache Axis2、Codehaus XFire、Apache CXF、Apache Wink、Jboss &nbsp;RESTEasyd等等...</p><p><br/></p><p><img src=\"/static/userImages/20160203/1454486847949023678.jpg\" title=\"1454486847949023678.jpg\" alt=\"20131203094415-1061627437.jpg\"/></p><p><br/></p><p><br/></p><p>&nbsp;&nbsp;</p>',9,'webservice java'),(48,'百度云资源，是程序员们的发家致富一块肥肉','  百度云在前两年的“云大战”中，最终获胜，当年各种云盘，相互厮杀，有技术方面的，有公关方面的原因，最终还是百度云大获全胜；  百度云经过几年的发展，逐渐成熟，性能稳定。开始的时候是不考虑盈利的，无广告。一直花钱投入，立志把这个云技术项目做好。时间证明了一切，百度云是一个优秀的，用户量最大的，资源最多，并且处','2016-02-04 18:49:15',888,18,'<p>&nbsp; 百度云在前两年的“云大战”中，最终获胜，当年各种云盘，相互厮杀，有技术方面的，有公关方面的原因，最终还是百度云大获全胜；</p><p>&nbsp; 百度云经过几年的发展，逐渐成熟，性能稳定。开始的时候是不考虑盈利的，无广告。一直花钱投入，立志把这个云技术项目做好。时间证明了一切，百度云是一个优秀的，用户量最大的，资源最多，</p><p>并且处理违法信息的手段都是成熟的。</p><p>&nbsp; 大家看了标题也许有疑问，“百度云资源，是程序员们的发家致富一块肥肉” 根本原因是百度云拥有海量的用户分享的资源， 但为什么是程序员的肥肉呢。据本人观察，中国至少有500家网站吃到百度云这块肥肉，一种一家就是我，<a href=\"http://pan.java1234.com/\" target=\"_blank\" title=\"http://pan.java1234.com/\">http://pan.java1234.com/</a></p><p>我这个项目，主要是利用谷歌自定义搜索，来搜索用户需要的资源。日IP 2万左右，但是钱赚得不多。</p><p>&nbsp;下面我来谈谈如何利用百度云来赚钱，这里只针对程序员，因为只有程序员有技术来实现。说简单点，就是百度云的海量资源，程序员们可以看作是海量的页面，可以拿过来，搞成自己的资源页面。这样自己搞的站点，就拥有了海量的页面，只要seo搞得还行，一天搞个几万个流量，甚至几十万流量都没问题。然后挂google广告，百度联盟广告，我看到过类似网站，成功申请到谷歌广告，百度联盟广告的。</p><p>&nbsp;这块蛋糕，以后肯定会被越来越多的程序员看重，并且分享。但是我个人觉得，这块蛋糕非常大，大得我估计能养活10万个程序员。<img src=\"http://img.baidu.com/hi/jx2/j_0005.gif\"/> 当然有些人觉得我吹牛逼，其实我说的还是保守的值。</p><p>&nbsp;下面我来分析下，如何来搞这个项目 要用到哪些技术，传统的php ,asp.net,jsp 都可以来实现这项目。我自己也去看了人家的实现，核心的是采集技术，怎么个采集法呢，不是随便瞎搞的，一条比较好的方法是先去采集百度云分享达人的帐号，然后挨个的采集他们的分享资源。就是搞这个项目，说实话，要花不少时间，就是在采集资源这块。我估计有不少程序员是全职搞这个项目的，我上次看到几个，根据流量和广告。我估计他们一个月至少有2，3万。流量很大。采集到数据后，然后就是显示，这个再简单不过了。作为程序员，如果连这个都不会，那只能称技术员了。</p><p>&nbsp;&nbsp;</p><p>&nbsp; 好了，今天就把这个牛逼蛋糕介绍到这里，希望大家看到我这个文章，假如技术上满足条件，可以试着业余先搞搞。或许你从此屌炸天了。</p><p><br/></p><p><img src=\"/static/userImages/20160204/1454582940339078791.jpg\" title=\"1454582940339078791.jpg\" alt=\"QQ鎴浘20160204184853.jpg\"/></p><p><br/></p><p><br/></p>',4,'百度云 赚钱'),(49,'新的一年，祝愿大家幸福平安，事业有成','新的一年，祝愿大伙猴年大吉。 看我博客的，大多数都是在奋斗的年轻人，希望大家在最能够吃苦的年纪，一定要多努力。20到30岁是人生学习专业知识，积累经验，积累人脉以及磨练自己的最佳时期。一定要把握好。当然包括我自己，作为一个成了家的男人，也要奋斗，让家人过好的生活。','2016-02-09 20:12:21',211,10,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0002.gif\"/><img src=\"http://img.baidu.com/hi/jx2/j_0002.gif\"/><img src=\"http://img.baidu.com/hi/jx2/j_0002.gif\"/><br/></p><p><br/></p><p>新的一年，祝愿大伙猴年大吉。</p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/> 看我博客的，大多数都是在奋斗的年轻人，希望大家在最能够吃苦的年纪，一定要多努力。20到30岁是人生学习专业知识，积累经验，积累人脉以及磨练自己的最佳时期。一定要把握好。</p><p><img alt=\"1104291174.png\" src=\"/static/userImages/20160209/1455019874408003267.png\" title=\"1455019874408003267.png\"/></p><p><br/></p><p>当然包括我自己，作为一个成了家的男人，也要奋斗，让家人过好的生活。<img src=\"http://img.baidu.com/hi/ldw/w_0003.gif\"/></p><p><br/></p>',5,NULL),(50,'使用Jsoup解析出html中的img元素','jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。博客项目有个需求。展示博客列表的时候，显示一些博客里的图片，增强用户体验；这里的话，有两种方案，第一种 是在后台处理，把','2016-02-14 12:52:43',169,6,'<p><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; line-height: 24px; text-indent: 28px; background-color: rgb(255, 255, 255);\">jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</span></p><p><img src=\"/static/userImages/20160214/1455425736515085353.jpg\" title=\"1455425736515085353.jpg\" alt=\"QQ鎴浘20160214125257.jpg\"/></p><p><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; line-height: 24px; text-indent: 28px; background-color: rgb(255, 255, 255);\"><br/></span></p><p><span style=\"color: rgb(51, 51, 51); font-family: arial, 宋体, sans-serif; font-size: 14px; line-height: 24px; text-indent: 28px; background-color: rgb(255, 255, 255);\">博客项目有个需求。展示博客列表的时候，显示一些博客里的图片，增强用户体验；</span></p><p>这里的话，有两种方案，第一种 是在后台处理，把解析好的图片存集合里，然后转发到页面，遍历显示；还有一种是把博客内容送到页面，用Jquery处理。</p><p>我考虑了下。还是在后台处理好比较好，因为项目本身用到了 cnd加速，所以在前端处理反而影响效率。</p><p>在后端处理，可以使用Jsoup，很方便；</p><p><br/></p><p>Jsoup主页：<a href=\"http://jsoup.org/\" target=\"_blank\" title=\"http://jsoup.org/\">http://jsoup.org/</a></p><p><br/></p><p>maven地址：</p><pre class=\"brush:xml;toolbar:false\">&lt;dependency&gt;\n     &lt;groupId&gt;org.jsoup&lt;/groupId&gt;\n      &lt;artifactId&gt;jsoup&lt;/artifactId&gt;\n        &lt;version&gt;1.8.3&lt;/version&gt;\n  &lt;/dependency&gt;</pre><p><br/></p><p><br/></p><p>这里给下关键代码：</p><pre class=\"brush:java;toolbar:false\">for(Blog&nbsp;blog:blogList){\n            List&lt;String&gt;&nbsp;imagesList=blog.getImagesList();\n          String&nbsp;blogInfo=blog.getContent();\n           Document&nbsp;doc=Jsoup.parse(blogInfo);\n          Elements&nbsp;jpgs=doc.select(&quot;img[src$=.jpg]&quot;);&nbsp;//　查找扩展名是jpg的图片\n           for(int&nbsp;i=0;i&lt;jpgs.size();i++){\n               Element&nbsp;jpg=jpgs.get(i);\n             imagesList.add(jpg.toString());\n               if(i==2){\n                 break;\n                }\n         }\n     }</pre><p><br/></p><p>主要涉及到一些选择器。不难。大家可以参考下官方文档。或者百度很容易上手。</p><p><br/></p>',10,'jsoup java'),(51,'使用CXF开发WebService服务器端接口','CXF作为java领域主流的WebService实现框架，Java程序员有必要掌握它。CXF主页：http://cxf.apache.org/简介：百度百科今天的话，主要是用CXF来开发下WebService服务器端接口，明天写下开发客户端接口；这里用Maven。首先建一个Maven的j2se项目；项目的jr','2016-02-14 20:46:04',199,1,'<p><br/>CXF作为java领域主流的WebService实现框架，Java程序员有必要掌握它。</p><p><br/></p><p>CXF主页：<a href=\"http://cxf.apache.org/\" target=\"_blank\" title=\"http://cxf.apache.org/\">http://cxf.apache.org/</a></p><p><br/></p><p>简介：<a href=\"http://baike.baidu.com/link?url=DSx84NVH4yZmYVYOiyFVucRScx5i1rXy5VH6N8VgLygZwkybqL1RVAISqgmWXt-pycDsWVTfydkOowd1ysGxGq\" target=\"_blank\" title=\"http://baike.baidu.com/link?url=DSx84NVH4yZmYVYOiyFVucRScx5i1rXy5VH6N8VgLygZwkybqL1RVAISqgmWXt-pycDsWVTfydkOowd1ysGxGq\">百度百科</a></p><p><br/></p><p>今天的话，主要是用CXF来开发下WebService服务器端接口，明天写下开发客户端接口；</p><p><br/></p><p>这里用Maven。<br/></p><p><br/></p><p>首先建一个Maven的j2se项目；<br/></p><p><img src=\"/static/userImages/20160214/1455452546687063197.jpg\" title=\"1455452546687063197.jpg\" alt=\"QQ鎴浘20160214201912.jpg\"/></p><p><br/></p><p>项目的jre用1.7，因为1.7有webservice的默认实现。不要用1.5 不然下面你用我的代码会有问题，用1.5的话，还需要另外加jar包，这里为了大家省事，要换成1.7;</p><p><img src=\"/static/userImages/20160214/1455452618468053349.jpg\" title=\"1455452618468053349.jpg\" alt=\"QQ鎴浘20160214201936.jpg\"/></p><p><br/></p><p><br/></p><p>根据规范，我们先建一个接口类：HelloWorld</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\nimport&nbsp;javax.jws.WebService;\n\n@WebService\npublic&nbsp;interface&nbsp;HelloWorld&nbsp;{\n\n  public&nbsp;String&nbsp;say(String&nbsp;str);\n}</pre><p><br/></p><p>再建一个具体的实现类：HelloWorldImpl</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice.impl;\n\nimport&nbsp;javax.jws.WebService;\n\nimport&nbsp;com.java1234.webservice.HelloWorld;\n\n@WebService\npublic&nbsp;class&nbsp;HelloWorldImpl&nbsp;implements&nbsp;HelloWorld{\n\n public&nbsp;String&nbsp;say(String&nbsp;str)&nbsp;{\n       return&nbsp;&quot;Hello&nbsp;&quot;+str;\n  }\n\n}</pre><p><br/></p><p>最后建一个发布服务的主类：Server<br/></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\n\nimport&nbsp;javax.xml.ws.Endpoint;\n\nimport&nbsp;com.java1234.webservice.impl.HelloWorldImpl;\n\npublic&nbsp;class&nbsp;Server&nbsp;{\n\n    public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n     System.out.println(&quot;web&nbsp;service&nbsp;start&quot;);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HelloWorld&nbsp;implementor&nbsp;=&nbsp;new&nbsp;HelloWorldImpl();&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;address&nbsp;=&nbsp;&quot;http://192.168.1.103/helloWorld&quot;;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Endpoint.publish(address,&nbsp;implementor);&nbsp;&nbsp;//&nbsp;JDK实现\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;web&nbsp;service&nbsp;started&quot;);&nbsp;&nbsp;\n }\n}</pre><p><br/></p><p>这里的Endpoint是Jdk自身实现的WebService。所以到这里我们不需要用到CXF的任何东西。</p><p>这里的address，写上自己的本机IP</p><p>我们运行下Server类：</p><p>运行效果如下：<br/></p><p><img src=\"/static/userImages/20160214/1455452954968056097.jpg\" title=\"1455452954968056097.jpg\" alt=\"QQ鎴浘20160214202633.jpg\"/></p><p><br/></p><p>我们在浏览器里访问：<a href=\"http://192.168.1.103/helloWorld?wsdl\" _src=\"http://192.168.1.103/helloWorld?wsdl\">http://192.168.1.103/helloWorld?wsdl</a> </p><p><br/></p><p>效果：<br/></p><p><img src=\"/static/userImages/20160214/1455453073062071044.jpg\" title=\"1455453073062071044.jpg\" alt=\"QQ鎴浘20160214202817.jpg\"/></p><p><br/></p><p>说明已经成功调用了webservice接口；</p><p><br/></p><p>这里的wsdl 是&nbsp;Web Services Description Language的缩写，是一个用来描述Web服务和说明如何与Web服务通信的XML语言。WSDL是Web Service的描述语言，用于描述Web Service的服务，接口绑定等，为用户提供详细的接口说明书。</p><p><br/></p><p>请求后得到的是一个xml规范文档。是一套规范，后面会具体介绍，任何语言平台技术都可以解析。</p><p><br/></p><p><br/></p><p><br/></p><p>下面我们介绍使用CXF来实现webservice接口：</p><p>我们先在pom.xml中加入：<br/></p><pre class=\"brush:xml;toolbar:false\">&lt;dependency&gt;\n      &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;\n     &lt;artifactId&gt;cxf-core&lt;/artifactId&gt;\n     &lt;version&gt;3.1.5&lt;/version&gt;\n  &lt;/dependency&gt;\n   \n  &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;\n     &lt;artifactId&gt;cxf-rt-frontend-jaxws&lt;/artifactId&gt;\n        &lt;version&gt;3.1.5&lt;/version&gt;\n  &lt;/dependency&gt;\n   \n  &lt;dependency&gt;\n        &lt;groupId&gt;org.apache.cxf&lt;/groupId&gt;\n     &lt;artifactId&gt;cxf-rt-transports-http-jetty&lt;/artifactId&gt;\n     &lt;version&gt;3.1.5&lt;/version&gt;\n  &lt;/dependency&gt;</pre><p><br/></p><p>这里要额外加入jetty，作为webservice发布的服务器。jetty是一个内嵌的web服务器；</p><p><br/></p><p><img src=\"/static/userImages/20160214/1455453479984038162.jpg\" title=\"1455453479984038162.jpg\" alt=\"QQ鎴浘20160214203514.jpg\"/></p><p><br/></p><p>我们把Server改下。换成CXF实现：<br/></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\n\nimport&nbsp;org.apache.cxf.jaxws.JaxWsServerFactoryBean;\n\nimport&nbsp;com.java1234.webservice.impl.HelloWorldImpl;\n\npublic&nbsp;class&nbsp;Server&nbsp;{\n\n    public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n     System.out.println(&quot;web&nbsp;service&nbsp;start&quot;);&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HelloWorld&nbsp;implementor&nbsp;=&nbsp;new&nbsp;HelloWorldImpl();&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;String&nbsp;address&nbsp;=&nbsp;&quot;http://192.168.1.103/helloWorld&quot;;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;Endpoint.publish(address,&nbsp;implementor);&nbsp;&nbsp;//&nbsp;JDK实现\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JaxWsServerFactoryBean&nbsp;factoryBean&nbsp;=&nbsp;new&nbsp;JaxWsServerFactoryBean();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factoryBean.setAddress(address);&nbsp;//&nbsp;设置暴露地址\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factoryBean.setServiceClass(HelloWorld.class);&nbsp;//&nbsp;接口类\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factoryBean.setServiceBean(implementor);&nbsp;//&nbsp;设置实现类\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;factoryBean.create();        \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;web&nbsp;service&nbsp;started&quot;);&nbsp;&nbsp;\n  }\n}</pre><p><br/></p><p>运行效果和刚才一样，这里就不再重复；</p><p><br/></p><p>完整源码下载：<a href=\"http://pan.baidu.com/s/1jHwGLF4\" target=\"_blank\" title=\"http://pan.baidu.com/s/1jHwGLF4\">http://pan.baidu.com/s/1jHwGLF4</a> </p><p><br/></p>',9,'webservice cxf java'),(52,'使用CXF开发WebService客户端','前面一讲开发了webservice服务器端接口，今天的话，我们来开发webservice客户端，让大家来体验下过程；首先建一个Maven项目，项目名字，WS_Client；然后我们要用CXF给我们提供的工具wsdl2java 来根据请求的url生成客户端代码；wsdl2java工具在CXF开发包里；开发下载地','2016-02-15 21:06:30',259,10,'<p>前面一讲开发了webservice服务器端接口，今天的话，我们来开发webservice客户端，让大家来体验下过程；</p><p><br/></p><p>首先建一个Maven项目，项目名字，WS_Client；</p><p><img src=\"/static/userImages/20160215/1455539511890048174.jpg\" alt=\"1455539511890048174.jpg\"/><br/></p><p><br/></p><p>然后我们要用CXF给我们提供的工具wsdl2java 来根据请求的url生成客户端代码；</p><p><br/></p><p>wsdl2java工具在CXF开发包里；</p><p>开发下载地址：<a title=\"http://cxf.apache.org/download.html\" target=\"_blank\" href=\"http://cxf.apache.org/download.html\">http://cxf.apache.org/download.html</a></p><p><img alt=\"QQ鎴浘20160215203213.jpg\" src=\"/static/userImages/20160215/1455539700734093102.jpg\" title=\"1455539700734093102.jpg\" width=\"667\" height=\"264\" style=\"width: 667px; height: 264px;\"/></p><p><br/></p><p>下载二进制包，然后解压到D盘 <br/></p><p><img alt=\"QQ鎴浘20160215203317.jpg\" src=\"/static/userImages/20160215/1455539761187019902.jpg\" title=\"1455539761187019902.jpg\"/></p><p><br/></p><p>这里我们看到了wsdl2java命令；当然要用的话，还得配置Path。我们打开环境变量配置，加入路径 D:\\apache-cxf-3.1.5\\bin&nbsp; 可能你的和我不一样；</p><p><img src=\"/static/userImages/20160215/1455539844625087079.jpg\" alt=\"1455539844625087079.jpg\"/><br/></p><p><br/></p><p>现在我们要干的事是在我们项目里生成我们需要的webservice客户端代码，</p><p>我们找到项目的本地路径，</p><p><img alt=\"QQ鎴浘20160215203622.jpg\" src=\"/static/userImages/20160215/1455539950421090821.jpg\" title=\"1455539950421090821.jpg\"/></p><p><br/></p><p>我的地址是：D:\\workspace\\WS_Client\\src\\main\\java 你们的可能和我不一样：</p><p><br/></p><p>然后我们进入dos，进入上面的本地硬盘地址，然后执行命令：wsdl2java&nbsp;<a href=\"http://192.168.1.103/helloWorld?wsdl\" _src=\"http://192.168.1.103/helloWorld?wsdl\">http://192.168.1.103/helloWorld?wsdl</a> </p><p><img src=\"/static/userImages/20160215/1455542517421041234.jpg\" title=\"1455542517421041234.jpg\" alt=\"QQ鎴浘20160215211824.jpg\"/></p><p><br/></p><p>这样就完成了代码的生成，我们刷新下工程：</p><p><img src=\"/static/userImages/20160215/1455542567125006252.jpg\" title=\"1455542567125006252.jpg\" alt=\"QQ鎴浘20160215212002.jpg\"/></p><p><br/></p><p>最关键的代码是HelloWorldService.java 我们下面写请求主类要用到；</p><p><br/></p><p><br/></p><p>我们下面写下主类 Client ，自己建下：</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\npublic&nbsp;class&nbsp;Client&nbsp;{\n\n public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n     HelloWorldService&nbsp;service=new&nbsp;HelloWorldService();\n      HelloWorld&nbsp;helloWorld=service.getHelloWorldPort();\n       System.out.println(helloWorld.say(&quot;java1234_小锋&quot;));\n  }\n}</pre><p><br/></p><p>运行如下：</p><p><img src=\"/static/userImages/20160215/1455542695984058850.jpg\" title=\"1455542695984058850.jpg\" alt=\"QQ鎴浘20160215212217.jpg\"/></p><p><br/></p><p>说明我们成功调用了webservice服务器端的接口。</p><p><br/></p><p>完整代码：<a href=\"http://pan.baidu.com/s/1gebOAR5\" target=\"_blank\" title=\"http://pan.baidu.com/s/1gebOAR5\">http://pan.baidu.com/s/1gebOAR5</a></p>',9,'webservice cxf'),(53,'CXF处理JavaBean以及复合类型','前面讲的是处理简单类型，今天这里来讲下CXF处理JavaBean以及复合类型，比如集合；这里实例是客户端传一个JavaBean，服务器端返回集合类型；在原来的项目实例基础上，我们先创建一个实体类User:package com.java1234.entity;/** * 用户实体类 * @author Adm','2016-02-18 10:31:19',117,8,'<p>前面讲的是处理简单类型，今天这里来讲下CXF处理JavaBean以及复合类型，比如集合；</p><p><br/></p><p>这里实例是客户端传一个JavaBean，服务器端返回集合类型；</p><p><br/></p><p>在原来的项目实例基础上，我们先创建一个实体类User:<br/></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.entity;\n\n/**\n&nbsp;*&nbsp;用户实体类\n&nbsp;*&nbsp;@author&nbsp;Administrator\n&nbsp;*\n&nbsp;*/\npublic&nbsp;class&nbsp;User&nbsp;{\n\n   private&nbsp;Integer&nbsp;id;&nbsp;//&nbsp;编号\n private&nbsp;String&nbsp;userName;&nbsp;//&nbsp;用户名\n   private&nbsp;String&nbsp;password;&nbsp;//&nbsp;密码\n    \n  public&nbsp;Integer&nbsp;getId()&nbsp;{\n       return&nbsp;id;\n   }\n public&nbsp;void&nbsp;setId(Integer&nbsp;id)&nbsp;{\n       this.id&nbsp;=&nbsp;id;\n   }\n public&nbsp;String&nbsp;getUserName()&nbsp;{\n      return&nbsp;userName;\n }\n public&nbsp;void&nbsp;setUserName(String&nbsp;userName)&nbsp;{\n        this.userName&nbsp;=&nbsp;userName;\n   }\n public&nbsp;String&nbsp;getPassword()&nbsp;{\n      return&nbsp;password;\n }\n public&nbsp;void&nbsp;setPassword(String&nbsp;password)&nbsp;{\n        this.password&nbsp;=&nbsp;password;\n   }\n \n  \n}</pre><p><br/></p><p>再创建一个Role实体类：</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.entity;\n\n/**\n&nbsp;*&nbsp;角色实体\n&nbsp;*&nbsp;@author&nbsp;Administrator\n&nbsp;*\n&nbsp;*/\npublic&nbsp;class&nbsp;Role&nbsp;{\n\n    private&nbsp;Integer&nbsp;id;&nbsp;//&nbsp;编号\n private&nbsp;String&nbsp;roleName;&nbsp;//&nbsp;角色名称\n  \n  \n  \n  public&nbsp;Role()&nbsp;{\n     super();\n      //&nbsp;TODO&nbsp;Auto-generated&nbsp;constructor&nbsp;stub\n   }\n \n  \n  \n  public&nbsp;Role(Integer&nbsp;id,&nbsp;String&nbsp;roleName)&nbsp;{\n       super();\n      this.id&nbsp;=&nbsp;id;\n       this.roleName&nbsp;=&nbsp;roleName;\n   }\n\n\n\n   public&nbsp;Integer&nbsp;getId()&nbsp;{\n       return&nbsp;id;\n   }\n public&nbsp;void&nbsp;setId(Integer&nbsp;id)&nbsp;{\n       this.id&nbsp;=&nbsp;id;\n   }\n public&nbsp;String&nbsp;getRoleName()&nbsp;{\n      return&nbsp;roleName;\n }\n public&nbsp;void&nbsp;setRoleName(String&nbsp;roleName)&nbsp;{\n        this.roleName&nbsp;=&nbsp;roleName;\n   }\n \n  \n}</pre><p><br/></p><p><br/></p><p>然后HelloWorld再加一个接口方法getRoleByUser，通过用户查找角色：<br/></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\nimport&nbsp;java.util.List;\n\nimport&nbsp;javax.jws.WebService;\n\nimport&nbsp;com.java1234.entity.Role;\nimport&nbsp;com.java1234.entity.User;\n\n@WebService\npublic&nbsp;interface&nbsp;HelloWorld&nbsp;{\n\n  public&nbsp;String&nbsp;say(String&nbsp;str);\n \n  public&nbsp;List&lt;Role&gt;&nbsp;getRoleByUser(User&nbsp;user);\n}</pre><p><br/></p><p><br/></p><p>然后HelloWorld接口实现类 HelloWorldImpl写下新增的方法的具体实现，我们这里写死，模拟下即可：<br/></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice.impl;\n\nimport&nbsp;java.util.ArrayList;\nimport&nbsp;java.util.List;\n\nimport&nbsp;javax.jws.WebService;\n\nimport&nbsp;com.java1234.entity.Role;\nimport&nbsp;com.java1234.entity.User;\nimport&nbsp;com.java1234.webservice.HelloWorld;\n\n@WebService\npublic&nbsp;class&nbsp;HelloWorldImpl&nbsp;implements&nbsp;HelloWorld{\n\n public&nbsp;String&nbsp;say(String&nbsp;str)&nbsp;{\n       return&nbsp;&quot;Hello&nbsp;&quot;+str;\n  }\n\n   public&nbsp;List&lt;Role&gt;&nbsp;getRoleByUser(User&nbsp;user)&nbsp;{\n        List&lt;Role&gt;&nbsp;roleList=new&nbsp;ArrayList&lt;Role&gt;();\n      //&nbsp;模拟&nbsp;直接写死\n      if(user!=null){\n           if(user.getUserName().equals(&quot;java1234&quot;)&nbsp;&amp;&amp;&nbsp;user.getPassword().equals(&quot;123456&quot;)){\n               roleList.add(new&nbsp;Role(1,&quot;技术总监&quot;));\n              roleList.add(new&nbsp;Role(2,&quot;架构师&quot;));\n           }else&nbsp;if(user.getUserName().equals(&quot;jack&quot;)&nbsp;&amp;&amp;&nbsp;user.getPassword().equals(&quot;123456&quot;)){\n                roleList.add(new&nbsp;Role(3,&quot;程序员&quot;));\n           }\n         return&nbsp;roleList;\n     }else{\n            return&nbsp;null;           \n      }\n     \n  }\n \n  \n\n}</pre><p><br/></p><p>服务端其他地方不用动；<br/></p><p><br/></p><p>下面我们来处理下客户端，和前面讲的一样。我们用wsdl2java工具重新生成代码，这里就不再讲；</p><p><br/></p><p><img src=\"/static/userImages/20160218/1455762437448028677.jpg\" title=\"1455762437448028677.jpg\" alt=\"QQ鎴浘20160218103035.jpg\"/></p><p><br/></p><p>这里我看到，实体类，以及接口实现，代码都生成了。</p><p><br/></p><p>我们改下Client类：</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\nimport&nbsp;java.util.List;\n\npublic&nbsp;class&nbsp;Client&nbsp;{\n\n  public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n     HelloWorldService&nbsp;service=new&nbsp;HelloWorldService();\n      HelloWorld&nbsp;helloWorld=service.getHelloWorldPort();\n       //System.out.println(helloWorld.say(&quot;java1234&quot;));\n       User&nbsp;user=new&nbsp;User();\n       user.setUserName(&quot;jack&quot;);\n       user.setPassword(&quot;123456&quot;);\n     List&lt;Role&gt;&nbsp;roleList=helloWorld.getRoleByUser(user);\n        for(Role&nbsp;role:roleList){\n         System.out.println(role.getId()+&quot;,&quot;+role.getRoleName());\n        }\n }\n}</pre><p><br/></p><p>运行截图：<br/></p><p><img src=\"/static/userImages/20160218/1455762521698070806.jpg\" title=\"1455762521698070806.jpg\" alt=\"QQ鎴浘20160218103159.jpg\"/></p><p><br/></p><p>完整代码：<a href=\"http://pan.baidu.com/s/1c1drMYO\" target=\"_blank\" title=\"http://pan.baidu.com/s/1c1drMYO\">http://pan.baidu.com/s/1c1drMYO</a></p><p><br/></p>',9,'webservice cxf'),(54,'webservice执行过程深入理解','前面我们搞了1，2个DEMO，基本对webservice服务发布，调用 ，执行 有一定的了解。今天的话，我们再系统的梳理下webservice执行过程。首先我们在webservice服务器端开发webservice接口，然后发布webservice；然后我们通过一个Url调用webservice接口，比如发布','2016-02-19 20:18:54',107,0,'<p>前面我们搞了1，2个DEMO，基本对webservice服务发布，调用 ，执行 有一定的了解。</p><p>今天的话，我们再系统的梳理下webservice执行过程。</p><p><br/></p><p>首先我们在webservice服务器端开发webservice接口，然后发布webservice；</p><p><br/></p><p>然后我们通过一个Url调用webservice接口，比如发布的时候 ，url是&nbsp;http://192.168.1.103/helloWorld</p><p><br/></p><p>那我们请求的url就是&nbsp;http://192.168.1.103/helloWorld?wsdl &nbsp;</p><p><br/></p><p>我们在浏览器里输入，运行如下：</p><p><img src=\"/static/userImages/20160219/1455883676261078945.jpg\" title=\"1455883676261078945.jpg\" alt=\"QQ鎴浘20160219201122.jpg\"/></p><p><br/></p><p>这一大串xml标记，其实就是wsdl （Web Services Description Language） 也就是Web Service描述语言，描述服务器端定义的webservice接口的相关信息，</p><p>当然我们不用花时间去学习这东西，毕竟这东西是一套规范，但是我们仔细观察，猜测，也能分析出一些猫腻来，这里wsdl:types就是定义了一些变量，wsdl:message相当于定义方法，</p><p>wsdl:portType相当与调用与返回，下面的话，就是一些操作。这东西不必要去研究细节，搞这东西会晕死的。有工具给我处理。我们角度要站得高。</p><p><br/></p><p>客户端通过这个url请求，获得wsdl规范的xml文档片段信息，然后这里又涉及到一个新的概念SOAP（Simple Object Access Protocol）即简单对象访问协议，我们通过这个协议，来实现客户端，服务器端消息交互，SOAP使用XML消息调用远程方法；当然交互的媒介就是xml，具体交互内容根据wsdl文档描述来。</p><p><br/></p><p>这个就是大体的一个webservie执行过程。<img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/> 当然，我作为一个开发者，我觉得一般的应用，Ajax跨域调用，以JSON作为交互媒介也不错。当然也要根据具体情况来。比如有大量的对象，集合类型，webservice还是有他的强项的。</p><p><br/></p><p><br/></p><p><br/></p>',9,'webservice cxf'),(55,'我的第一辆代步车-别克英朗',' 2015年折腾了好几个月，把驾照搞定了。至于买车，东看看西看看。最终选了别克英朗作为第一辆入门代步车。开了几个月，体验不错。今天回丈母娘家，自己洗车。省了20块。 等这量车开报废了，变身老司机，准备入手奥迪A4L，或者奥迪A6L。','2016-02-21 17:02:21',88,14,'<p><img src=\"http://img.baidu.com/hi/jx2/j_0013.gif\"/> 2015年折腾了好几个月，把驾照搞定了。至于买车，东看看西看看。最终选了别克英朗作为第一辆入门代步车。开了几个月，体验不错。</p><p>今天回丈母娘家，自己洗车。省了20块。</p><p><br/></p><p><img src=\"http://blog.java1234.com/static/userImages/20160221/1456045138917057522.jpg\" title=\"1456045138917057522.jpg\" style=\"white-space: normal;\"/></p><p><br/></p><p><img src=\"/static/userImages/20160221/1456045138542012090.jpg\" style=\"\" title=\"1456045138542012090.jpg\"/></p><p><img src=\"/static/userImages/20160221/1456045138542074202.jpg\" style=\"\" title=\"1456045138542074202.jpg\"/></p><p><img src=\"/static/userImages/20160221/1456045138542027541.jpg\" style=\"width: 598px; height: 905px;\" title=\"1456045138542027541.jpg\" width=\"598\" height=\"905\"/></p><p><br/></p><p><br/></p><p><img src=\"http://img.baidu.com/hi/jx2/j_0011.gif\"/> 等这量车开报废了，变身老司机，准备入手奥迪A4L，或者奥迪A6L。</p><p><br/></p><p><br/></p>',5,''),(56,'cxf处理一些Map等复杂类型','前面讲的一些都是简单类型,cxf都支持。但是有些复杂类型，cxf是不支持，比如常用的Map类型；下面我们在前面的实例基础上在加一个方法，比如我们现在有个需求，获取所有用用户以及对应的每个用户所有角色信息；服务器端：HelloWorld接口加方法：/**  * 获取所有用户以及对应的角色     * @return  ','2016-02-22 17:46:30',5,0,'<p>前面讲的一些都是简单类型,cxf都支持。但是有些复杂类型，cxf是不支持，比如常用的Map类型；<br/></p><p><br/></p><p>下面我们在前面的实例基础上在加一个方法，比如我们现在有个需求，获取所有用用户以及对应的每个用户所有角色信息；</p><p><br/></p><p>服务器端：<br/></p><p><br/></p><p>HelloWorld接口加方法：</p><pre class=\"brush:java;toolbar:false\">/**\n &nbsp;*&nbsp;获取所有用户以及对应的角色\n    &nbsp;*&nbsp;@return\n  &nbsp;*/\n  public&nbsp;Map&lt;String,List&lt;Role&gt;&gt;&nbsp;getRoles();</pre><p><br/></p><p>HelloWorldImpl实现类加方法实现：<br/></p><pre class=\"brush:java;toolbar:false\">public&nbsp;Map&lt;String,&nbsp;List&lt;Role&gt;&gt;&nbsp;getRoles()&nbsp;{\n       Map&lt;String,List&lt;Role&gt;&gt;&nbsp;map=new&nbsp;HashMap&lt;String,List&lt;Role&gt;&gt;();\n        List&lt;Role&gt;&nbsp;roleList1=new&nbsp;ArrayList&lt;Role&gt;();\n     roleList1.add(new&nbsp;Role(1,&quot;技术总监&quot;));\n     roleList1.add(new&nbsp;Role(2,&quot;架构师&quot;));\n      map.put(&quot;java1234&quot;,&nbsp;roleList1);\n        List&lt;Role&gt;&nbsp;roleList2=new&nbsp;ArrayList&lt;Role&gt;();\n     roleList2.add(new&nbsp;Role(1,&quot;程序员&quot;));\n      map.put(&quot;jack&quot;,&nbsp;roleList2);\n        return&nbsp;map;\n  }</pre><p><br/></p><p>然后我们启动Server类：发现报错：</p><p><img src=\"/static/userImages/20160222/1456134575421042758.jpg\" title=\"1456134575421042758.jpg\" alt=\"QQ鎴浘20160222175231.jpg\"/></p><p>这个报错信息说，不支持该类型；</p><p><br/></p><p>这里我们有好几种解决方案，这里我们用最常用的一种，使用适配器，把cxf不能接受的类型通过适配器，转能接受的类型。</p><p><br/></p><p>我们使用@XmlJavaTypeAdapter注解，加在接口定义上，完整接口代码如下：</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\nimport&nbsp;java.util.List;\nimport&nbsp;java.util.Map;\n\nimport&nbsp;javax.jws.WebService;\nimport&nbsp;javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n\nimport&nbsp;com.java1234.adapter.MapAdapter;\nimport&nbsp;com.java1234.entity.Role;\nimport&nbsp;com.java1234.entity.User;\n\n@WebService\npublic&nbsp;interface&nbsp;HelloWorld&nbsp;{\n\n public&nbsp;String&nbsp;say(String&nbsp;str);\n \n  public&nbsp;List&lt;Role&gt;&nbsp;getRoleByUser(User&nbsp;user);\n  \n  /**\n   &nbsp;*&nbsp;获取所有用户以及对应的角色\n    &nbsp;*&nbsp;@return\n  &nbsp;*/\n  @XmlJavaTypeAdapter(MapAdapter.class)\n public&nbsp;Map&lt;String,List&lt;Role&gt;&gt;&nbsp;getRoles();\n}</pre><p><br/></p><p>这里参数需要一个实现了XmlAdapter类的适配器类；</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.adapter;\n\nimport&nbsp;java.util.HashMap;\nimport&nbsp;java.util.List;\nimport&nbsp;java.util.Map;\n\nimport&nbsp;javax.xml.bind.annotation.adapters.XmlAdapter;\n\nimport&nbsp;com.java1234.entity.Role;\n\n/**\n&nbsp;*&nbsp;Map适配器\n&nbsp;*&nbsp;@author&nbsp;Administrator\n&nbsp;*\n&nbsp;*/\npublic&nbsp;class&nbsp;MapAdapter&nbsp;extends&nbsp;XmlAdapter&lt;MyRole[],&nbsp;Map&lt;String,List&lt;Role&gt;&gt;&gt;{\n\n   /**\n   &nbsp;*&nbsp;适配转换&nbsp;&nbsp;MyRole[]&nbsp;-&gt;&nbsp;Map&lt;String,&nbsp;List&lt;Role&gt;&gt;\n    &nbsp;*/\n  @Override\n public&nbsp;Map&lt;String,&nbsp;List&lt;Role&gt;&gt;&nbsp;unmarshal(MyRole[]&nbsp;v)&nbsp;throws&nbsp;Exception&nbsp;{\n        Map&lt;String,&nbsp;List&lt;Role&gt;&gt;&nbsp;map=new&nbsp;HashMap&lt;String,List&lt;Role&gt;&gt;();\n      for(int&nbsp;i=0;i&lt;v.length;i++){\n          MyRole&nbsp;r=v[i];\n           map.put(r.getKey(),&nbsp;r.getValue());\n       }\n     return&nbsp;map;\n  }\n\n   /**\n   &nbsp;*&nbsp;适配转换&nbsp;&nbsp;Map&lt;String,&nbsp;List&lt;Role&gt;&gt;&nbsp;-&gt;&nbsp;MyRole[]\n    &nbsp;*/\n  @Override\n public&nbsp;MyRole[]&nbsp;marshal(Map&lt;String,&nbsp;List&lt;Role&gt;&gt;&nbsp;v)&nbsp;throws&nbsp;Exception&nbsp;{\n      MyRole[]&nbsp;roles=new&nbsp;MyRole[v.size()];\n        int&nbsp;i=0;\n     for(String&nbsp;key:v.keySet()){\n          roles[i]=new&nbsp;MyRole();\n           roles[i].setKey(key);\n         roles[i].setValue(v.get(key));\n            i++;\n      }\n     return&nbsp;roles;\n    }\n\n   \n  \n\n}</pre><p>这里的话XmlAdapter要加两个参数，XmlAdapter&lt;ValueType,BoundType&gt;&nbsp;</p><p>ValueType是cxf能接收的类型，这里我用了数组；</p><p>BoundType是cxf不能接受的类型，也就是我例子里的需求的Map类型；</p><p><br/></p><p>这里大家会看到，还有一个MyRole自定义类型，key:value。我们搞成两个属性，具体实现如下：<br/></p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.adapter;\n\nimport&nbsp;java.util.List;\n\nimport&nbsp;com.java1234.entity.Role;\n\n/**\n&nbsp;*&nbsp;自定义实体&nbsp;cxf能接受\n&nbsp;*&nbsp;@author&nbsp;Administrator\n&nbsp;*\n&nbsp;*/\npublic&nbsp;class&nbsp;MyRole&nbsp;{\n\n private&nbsp;String&nbsp;key;\n private&nbsp;List&lt;Role&gt;&nbsp;value;\n \n  public&nbsp;String&nbsp;getKey()&nbsp;{\n       return&nbsp;key;\n  }\n public&nbsp;void&nbsp;setKey(String&nbsp;key)&nbsp;{\n      this.key&nbsp;=&nbsp;key;\n }\n public&nbsp;List&lt;Role&gt;&nbsp;getValue()&nbsp;{\n       return&nbsp;value;\n    }\n public&nbsp;void&nbsp;setValue(List&lt;Role&gt;&nbsp;value)&nbsp;{\n        this.value&nbsp;=&nbsp;value;\n }\n \n  \n}</pre><p><br/></p><p>OK 这样就行了。我们运行Server类，发布webservice接口：</p><p><img src=\"/static/userImages/20160222/1456134226937065109.jpg\" title=\"1456134226937065109.jpg\" alt=\"QQ鎴浘20160222174638.jpg\"/></p><p><br/></p><p><br/></p><p>然后就到了webservice客户端，我们用wsdl2java工具生成下最新代码，具体过程前面讲过，这里不重复讲：</p><p>生成代码如下：</p><p><img src=\"/static/userImages/20160222/1456134312484067804.jpg\" title=\"1456134312484067804.jpg\" alt=\"QQ鎴浘20160222174813.jpg\"/></p><p><br/></p><p>我们修改下Client类：</p><pre class=\"brush:java;toolbar:false\">package&nbsp;com.java1234.webservice;\n\nimport&nbsp;java.util.List;\n\npublic&nbsp;class&nbsp;Client&nbsp;{\n\n    public&nbsp;static&nbsp;void&nbsp;main(String[]&nbsp;args)&nbsp;{\n     HelloWorldService&nbsp;service=new&nbsp;HelloWorldService();\n      HelloWorld&nbsp;helloWorld=service.getHelloWorldPort();\n       //System.out.println(helloWorld.say(&quot;java1234&quot;));\n       /*User&nbsp;user=new&nbsp;User();\n     user.setUserName(&quot;jack&quot;);\n       user.setPassword(&quot;123456&quot;);\n     List&lt;Role&gt;&nbsp;roleList=helloWorld.getRoleByUser(user);\n        for(Role&nbsp;role:roleList){\n         System.out.println(role.getId()+&quot;,&quot;+role.getRoleName());\n        }*/\n       MyRoleArray&nbsp;array=helloWorld.getRoles();\n     List&lt;MyRole&gt;&nbsp;roleList=array.item;\n      for(int&nbsp;i=0;i&lt;roleList.size();i++){\n           MyRole&nbsp;my=roleList.get(i);\n           System.out.print(my.key+&quot;:&quot;);\n           for(Role&nbsp;r:my.value){\n                System.out.print(r.getId()+&quot;,&quot;+r.getRoleName()+&quot;&nbsp;&quot;);\n         }\n         System.out.println();\n     }\n }\n}</pre><p><br/></p><p>运行下:</p><p><img src=\"/static/userImages/20160222/1456134352140052359.jpg\" title=\"1456134352140052359.jpg\" alt=\"QQ鎴浘20160222174853.jpg\"/></p><p><br/></p><p>OK,这样就实现了复杂类型的调用；</p><p><br/></p><p>完整代码：<a href=\"http://pan.baidu.com/s/1kTUseOZ\" target=\"_blank\" title=\"http://pan.baidu.com/s/1kTUseOZ\">http://pan.baidu.com/s/1kTUseOZ</a></p>',9,'webservice cxf'),(57,'as','adsad','2022-10-03 14:41:45',1,0,'<p>adsad<br/></p>',2,NULL),(58,'aaaa','asdadsad','2022-10-03 14:51:23',3,0,'<p>asdadsad<img src=\"/static/userImages/20221003/1664779876484077809.png\" title=\"1664779876484077809.png\" alt=\"logo.png\"/></p>',2,NULL),(59,'ad','','2022-10-03 14:51:59',1,0,'<p><img src=\"/static/userImages/20221003/1664779913904041164.png\" title=\"1664779913904041164.png\" alt=\"image.png\"/></p>',1,NULL),(60,'123','213 var ue = UE.getEditor(\'editor\',{         autoFloatEnabled:false//是否保持toolbar位置不懂         });','2022-10-03 14:59:47',2,1,'<p>213</p><pre class=\"brush:html;toolbar:false\">&nbsp;var&nbsp;ue&nbsp;=&nbsp;UE.getEditor(&#39;editor&#39;,{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;autoFloatEnabled:false//是否保持toolbar位置不懂\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</pre><p><br/></p>',2,NULL),(61,'qeq','qeqw','2022-10-03 15:34:17',0,0,'<p>qeqw</p>',2,NULL),(62,'123','qwe','2022-10-03 15:41:13',1,0,'<p>qwe</p>',2,NULL),(63,'lucene','lucene','2022-10-03 15:44:23',1,0,'<p>lucene</p>',3,NULL),(64,'java lucene使用','package com.etjava.lucene;import java.io.StringReader;import java.nio.file.Paths;import java.util.Date;import java.util.LinkedList;import java.util.List;im','2022-10-03 17:00:26',6,0,'<pre class=\"brush:java;toolbar:false\">package&nbsp;com.etjava.lucene;\n\nimport&nbsp;java.io.StringReader;\nimport&nbsp;java.nio.file.Paths;\nimport&nbsp;java.util.Date;\nimport&nbsp;java.util.LinkedList;\nimport&nbsp;java.util.List;\n\nimport&nbsp;org.apache.lucene.analysis.TokenStream;\nimport&nbsp;org.apache.lucene.analysis.cn.smart.SmartChineseAnalyzer;\nimport&nbsp;org.apache.lucene.document.Document;\nimport&nbsp;org.apache.lucene.document.Field;\nimport&nbsp;org.apache.lucene.document.StringField;\nimport&nbsp;org.apache.lucene.document.TextField;\nimport&nbsp;org.apache.lucene.index.DirectoryReader;\nimport&nbsp;org.apache.lucene.index.IndexReader;\nimport&nbsp;org.apache.lucene.index.IndexWriter;\nimport&nbsp;org.apache.lucene.index.IndexWriterConfig;\nimport&nbsp;org.apache.lucene.queryparser.classic.QueryParser;\nimport&nbsp;org.apache.lucene.search.BooleanClause;\nimport&nbsp;org.apache.lucene.search.BooleanQuery;\nimport&nbsp;org.apache.lucene.search.IndexSearcher;\nimport&nbsp;org.apache.lucene.search.Query;\nimport&nbsp;org.apache.lucene.search.ScoreDoc;\nimport&nbsp;org.apache.lucene.search.TopDocs;\nimport&nbsp;org.apache.lucene.search.highlight.Fragmenter;\nimport&nbsp;org.apache.lucene.search.highlight.Highlighter;\nimport&nbsp;org.apache.lucene.search.highlight.QueryScorer;\nimport&nbsp;org.apache.lucene.search.highlight.SimpleHTMLFormatter;\nimport&nbsp;org.apache.lucene.search.highlight.SimpleSpanFragmenter;\nimport&nbsp;org.apache.lucene.store.Directory;\nimport&nbsp;org.apache.lucene.store.FSDirectory;\n\nimport&nbsp;com.etjava.bean.Blog;\nimport&nbsp;com.etjava.util.DateUtil;\nimport&nbsp;com.etjava.util.StringUtil;\n/**\n&nbsp;*&nbsp;	&nbsp;全文检索\n&nbsp;*&nbsp;@author&nbsp;etjava\n&nbsp;*\n&nbsp;*/\n\npublic&nbsp;class&nbsp;ContentLucene&nbsp;{\n\n	private&nbsp;Directory&nbsp;dir;\n	\n	/**\n	&nbsp;*&nbsp;获取IndexWriter实例\n	&nbsp;*&nbsp;@return\n	&nbsp;*&nbsp;@throws&nbsp;Exception\n	&nbsp;*/\n	private&nbsp;IndexWriter&nbsp;getWriter()throws&nbsp;Exception{\n		dir=FSDirectory.open(Paths.get(&quot;C://lucene&quot;));\n		SmartChineseAnalyzer&nbsp;analyzer=new&nbsp;SmartChineseAnalyzer();\n		IndexWriterConfig&nbsp;iwc=new&nbsp;IndexWriterConfig(analyzer);\n		IndexWriter&nbsp;writer=new&nbsp;IndexWriter(dir,&nbsp;iwc);\n		return&nbsp;writer;\n	}\n	\n	/**\n	&nbsp;*&nbsp;添加博客索引\n	&nbsp;*&nbsp;@param&nbsp;blog\n	&nbsp;*&nbsp;@throws&nbsp;Exception\n	&nbsp;*/\n	public&nbsp;void&nbsp;addIndex(Blog&nbsp;blog)throws&nbsp;Exception{\n		IndexWriter&nbsp;writer=getWriter();\n		Document&nbsp;doc=new&nbsp;Document();\n		//&nbsp;StringField&nbsp;方法不需要作为分词保存&nbsp;&nbsp;TextField&nbsp;是需要作为分词保存\n		doc.add(new&nbsp;StringField(&quot;id&quot;,String.valueOf(blog.getId()),Field.Store.YES));\n		doc.add(new&nbsp;TextField(&quot;title&quot;,blog.getTitle(),Field.Store.YES));\n		doc.add(new&nbsp;StringField(&quot;releaseDate&quot;,DateUtil.formatDate(new&nbsp;Date(),&nbsp;&quot;yyyy-MM-dd&quot;),Field.Store.YES));\n		doc.add(new&nbsp;TextField(&quot;content&quot;,blog.getContentNoTag(),Field.Store.YES));\n		writer.addDocument(doc);\n		writer.close();\n	}\n	\n	/**\n	&nbsp;*&nbsp;	全文检索&nbsp;-&nbsp;匹配标题内容为主\n	&nbsp;*&nbsp;@param&nbsp;keyword\n	&nbsp;*&nbsp;@return\n	&nbsp;*&nbsp;@throws&nbsp;Exception\n	&nbsp;*/\n	public&nbsp;List&lt;Blog&gt;&nbsp;search(String&nbsp;keyword)&nbsp;throws&nbsp;Exception{\n		List&lt;Blog&gt;&nbsp;list&nbsp;=&nbsp;new&nbsp;LinkedList&lt;&gt;();\n		//&nbsp;读取词片内容\n		dir&nbsp;=&nbsp;FSDirectory.open(Paths.get(&quot;c://lucene&quot;));\n		IndexReader&nbsp;reader&nbsp;=&nbsp;DirectoryReader.open(dir);\n		//&nbsp;\n		IndexSearcher&nbsp;is&nbsp;=&nbsp;new&nbsp;IndexSearcher(reader);\n		//&nbsp;多条件查询&nbsp;title,content\n		BooleanQuery.Builder&nbsp;query&nbsp;=&nbsp;new&nbsp;BooleanQuery.Builder();\n		SmartChineseAnalyzer&nbsp;analyzer&nbsp;=&nbsp;new&nbsp;SmartChineseAnalyzer();\n		//&nbsp;title内容查询\n		QueryParser&nbsp;parser&nbsp;=&nbsp;new&nbsp;QueryParser(&quot;title&quot;,analyzer);\n		Query&nbsp;q&nbsp;=&nbsp;parser.parse(keyword);//&nbsp;解析title中词片\n		//&nbsp;content内容查询\n		QueryParser&nbsp;parser2&nbsp;=&nbsp;new&nbsp;QueryParser(&quot;content&quot;,analyzer);\n		Query&nbsp;q2&nbsp;=&nbsp;parser2.parse(keyword);//&nbsp;解析content中词片\n		\n		//&nbsp;BooleanClause.Occur.SHOULD&nbsp;查询条件&nbsp;SHOULD&nbsp;|&nbsp;的关系\n		query.add(q,BooleanClause.Occur.SHOULD);\n		query.add(q2,BooleanClause.Occur.SHOULD);\n		//&nbsp;开始检索&nbsp;query.build()&nbsp;多条件时使用booleanQuery.build&nbsp;进行构造&nbsp;&nbsp;&nbsp;1000&nbsp;表示返回的记录数\n		TopDocs&nbsp;hits&nbsp;=&nbsp;is.search(query.build(),&nbsp;1000);\n//&nbsp;计算得分&nbsp;-&nbsp;根据title内容计算&nbsp;&nbsp;得分高的会放在最前边\n		QueryScorer&nbsp;score&nbsp;=&nbsp;new&nbsp;QueryScorer(q);\n		//&nbsp;代码高亮显示\n		Fragmenter&nbsp;fragmenter&nbsp;=&nbsp;new&nbsp;SimpleSpanFragmenter(score);\n		//&nbsp;替换html标签\n		SimpleHTMLFormatter&nbsp;formater&nbsp;=&nbsp;new&nbsp;SimpleHTMLFormatter(&quot;&lt;b&gt;&lt;font&nbsp;color=red&gt;&quot;,&quot;&lt;/font&gt;&lt;/b&gt;&quot;);\n		//&nbsp;高亮显示\n		Highlighter&nbsp;highlighter&nbsp;=&nbsp;new&nbsp;Highlighter(formater,score);\n		highlighter.setTextFragmenter(fragmenter);\n		\n		for(ScoreDoc&nbsp;scoreDoc&nbsp;:&nbsp;hits.scoreDocs)&nbsp;{\n			Document&nbsp;doc&nbsp;=&nbsp;is.doc(scoreDoc.doc);\n			Blog&nbsp;blog=new&nbsp;Blog();\n			blog.setId(Integer.parseInt(doc.get(&quot;id&quot;)));\n			String&nbsp;title=doc.get(&quot;title&quot;);\n			String&nbsp;content=doc.get(&quot;content&quot;);\n			blog.setReleaseDateStr(doc.get(&quot;releaseDate&quot;));\n			if(title!=null){\n				TokenStream&nbsp;tokenStream=analyzer.tokenStream(&quot;title&quot;,&nbsp;new&nbsp;StringReader(title));\n				//&nbsp;设置title高亮\n				String&nbsp;hTitle=highlighter.getBestFragment(tokenStream,&nbsp;title);\n				if(StringUtil.isEmpty(hTitle)){\n					blog.setTitle(title);\n				}else{\n					blog.setTitle(hTitle);\n				}\n			}\n			if(content!=null){\n				TokenStream&nbsp;tokenStream=analyzer.tokenStream(&quot;content&quot;,&nbsp;new&nbsp;StringReader(content));\n				//&nbsp;设置content高亮显示\n				String&nbsp;hContent=highlighter.getBestFragment(tokenStream,&nbsp;content);\n				if(StringUtil.isEmpty(hContent)){\n					if(content.length()&lt;=200){\n						blog.setContent(content);						\n					}else{\n						blog.setContent(content.substring(0,&nbsp;200));	\n					}\n				}else{\n					blog.setContent(hContent);\n				}\n			}\n			list.add(blog);\n		}\n		return&nbsp;list;\n	}\n}</pre><p><br/></p>',1,NULL),(65,'adadsadsadasdsdsa','asdsadsadsadsadsadsa','2022-10-03 17:37:38',1,0,'<p><img src=\"/static/userImages/20221003/1664789847702089870.png\" title=\"1664789847702089870.png\" alt=\"image.png\"/>asdsadsadsadsadsadsa</p>',2,NULL),(76,'CSS1','啊打算萨达','2022-10-03 17:43:16',3,0,'<pre class=\"brush:css;toolbar:false\">&lt;!DOCTYPE&nbsp;html&gt;\n&lt;html&gt;	\n&lt;head&gt;\n&lt;meta&nbsp;charset=&quot;utf-8&quot;&gt;&nbsp;\n&lt;title&gt;菜鸟教程(runoob.com)&lt;/title&gt;&nbsp;\n&lt;style&gt;&nbsp;\ndiv\n{\n	width:100px;\n	height:75px;\n	background-color:red;\n	border:1px&nbsp;solid&nbsp;black;\n}\ndiv#div2\n{\n	transform:rotate(30deg);\n	-ms-transform:rotate(30deg);&nbsp;/*&nbsp;IE&nbsp;9&nbsp;*/\n	-webkit-transform:rotate(30deg);&nbsp;/*&nbsp;Safari&nbsp;and&nbsp;Chrome&nbsp;*/\n}\n&lt;/style&gt;\n&lt;/head&gt;\n&lt;body&gt;\n\n&lt;div&gt;你好。这是一个&nbsp;DIV&nbsp;元素。&lt;/div&gt;\n\n&lt;div&nbsp;id=&quot;div2&quot;&gt;你好。这是一个&nbsp;DIV&nbsp;元素。&lt;/div&gt;\n\n&lt;/body&gt;\n&lt;/html&gt;</pre><p><br/></p>',1,NULL),(77,'121','12','2022-10-03 19:48:52',3,0,'<p>12</p>',3,NULL),(91,'ETJAVA123','2222ETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAE','2022-10-04 11:36:01',6,0,'<p>2222ETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVAETJAVA</p>',3,'AAS DDD'),(92,'ABCDE2','ASDASDASD2','2022-10-04 23:27:48',12,5,'<p>ASDASDASD2</p>',11,NULL);

/*Table structure for table `t_blogtype` */

DROP TABLE IF EXISTS `t_blogtype`;

CREATE TABLE `t_blogtype` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `typeName` varchar(32) DEFAULT NULL,
  `orderNo` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=101 DEFAULT CHARSET=utf8;

/*Data for the table `t_blogtype` */

insert  into `t_blogtype`(`id`,`typeName`,`orderNo`) values (1,'Java核心基础',1),(2,'Mysql',2),(3,'Tomcat',3),(4,'IT之路',6),(5,'随心生活',7),(7,'shiro',4),(9,'webservice',5),(10,'jsoup',4),(11,'web',1),(19,'2',122),(100,'未分类',1);

/*Table structure for table `t_comments` */

DROP TABLE IF EXISTS `t_comments`;

CREATE TABLE `t_comments` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userAddr` varchar(64) DEFAULT NULL COMMENT '用户IP地址',
  `blogId` int(11) DEFAULT NULL COMMENT '所属博客',
  `content` text COMMENT '评论内容',
  `commonDate` datetime DEFAULT NULL COMMENT '评论时间',
  `state` int(11) DEFAULT NULL COMMENT '审核状态',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8;

/*Data for the table `t_comments` */

insert  into `t_comments`(`id`,`userAddr`,`blogId`,`content`,`commonDate`,`state`) values (1,'1.1.1.1',52,'阿斯顿撒大苏打的是','2022-02-02 00:00:00',0),(2,'2.2.2.2',52,'adsadassdadsadsa','2022-03-03 00:00:00',0),(3,'1.2.3.4',52,'ABCDEF','2022-10-02 22:04:27',2),(10,'1.2.3.4',52,'ABCDEF','2022-10-02 22:04:39',0),(13,'1.2.3.4',52,'ABCDEF','2022-10-02 22:04:39',0),(14,'1.2.3.4',52,'ABCDEF','2022-10-02 22:04:39',0),(16,'0:0:0:0:0:0:0:1',3,'asd','2022-10-02 23:05:53',2),(17,'0:0:0:0:0:0:0:1',3,'eqw','2022-10-03 00:03:08',1),(18,'0:0:0:0:0:0:0:1',3,'eqw','2022-10-03 00:03:29',2),(19,'0:0:0:0:0:0:0:1',3,'123','2022-10-03 00:03:50',1),(20,'0:0:0:0:0:0:0:1',3,'12321','2022-10-03 00:04:50',1),(21,'0:0:0:0:0:0:0:1',3,'123','2022-10-03 00:06:16',2),(22,'0:0:0:0:0:0:0:1',3,'123','2022-10-03 00:06:42',2),(23,'0:0:0:0:0:0:0:1',3,'123','2022-10-03 00:06:45',2),(24,'0:0:0:0:0:0:0:1',3,'123','2022-10-03 00:06:45',2),(25,'0:0:0:0:0:0:0:1',3,'123','2022-10-03 00:21:34',1),(26,'0:0:0:0:0:0:0:1',52,'1','2022-10-03 08:11:08',1),(27,'0:0:0:0:0:0:0:1',52,'1','2022-10-03 08:11:29',1),(28,'0:0:0:0:0:0:0:1',52,'2','2022-10-03 08:11:38',1),(29,'0:0:0:0:0:0:0:1',60,'13','2022-10-03 15:00:11',1),(30,'0:0:0:0:0:0:0:1',79,'123','2022-10-03 20:40:49',1),(31,'0:0:0:0:0:0:0:1',79,'123','2022-10-03 20:40:59',2),(32,'0:0:0:0:0:0:0:1',92,'ASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDASDsadsadSADDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD','2022-10-04 23:28:15',1),(33,'0:0:0:0:0:0:0:1',92,'asdas','2022-10-04 23:30:00',1),(34,'0:0:0:0:0:0:0:1',92,'qwe','2022-10-04 23:30:12',1),(35,'0:0:0:0:0:0:0:1',92,'qe','2022-10-04 23:30:35',1),(36,'0:0:0:0:0:0:0:1',92,'123','2022-10-04 23:31:30',1);

/*Table structure for table `t_crawlerblog` */

DROP TABLE IF EXISTS `t_crawlerblog`;

CREATE TABLE `t_crawlerblog` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(256) DEFAULT NULL COMMENT '标题',
  `summary` varchar(512) DEFAULT NULL COMMENT '摘要',
  `releaseDate` datetime DEFAULT NULL COMMENT '发布时间',
  `clickHit` int(11) DEFAULT NULL COMMENT '阅读次数',
  `replyHit` int(11) DEFAULT NULL COMMENT '回复次数',
  `content` longtext,
  `typeId` int(11) DEFAULT NULL COMMENT '类型ID',
  `keyword` varchar(64) DEFAULT NULL COMMENT '关键字',
  `state` int(11) DEFAULT NULL COMMENT '发布状态 0未发布 1已发布',
  `originalUrl` varchar(1024) DEFAULT NULL COMMENT '原始地址',
  `createDate` datetime DEFAULT NULL COMMENT '抓取时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=48 DEFAULT CHARSET=utf8mb4;

/*Data for the table `t_crawlerblog` */

insert  into `t_crawlerblog`(`id`,`title`,`summary`,`releaseDate`,`clickHit`,`replyHit`,`content`,`typeId`,`keyword`,`state`,`originalUrl`,`createDate`) values (1,'30岁后的生活',NULL,NULL,0,0,'<p>人过了30岁就不怎么关心自己的年纪了，至少不像20多岁时候那样去关心自己的年龄。</p> \n<p>我想原因有很多种，其中之一就是人在年轻的时候，更加害怕老去，所以更加关心自己的年龄。</p> \n<p>而到了30岁之后呢，就不得不承认自己已经老了。</p> \n<p>这不是很明显的事情吗。周围的人已经不再叫你哥哥，而改叫你叔叔了。</p> \n<p>过了30岁之后，如何做自己更重要。确切的说是做真实的自己。</p> \n<p>坚持一件事情很重要。与其每天无所事事，不如做点有意义的事情。</p> \n<p>比如每天记录生活，做一些并不会带来经济利益但确实自己愿意做并且觉得有意义和滋养灵魂的事情。</p> \n<p>比如早起、健身、读书、跑步、欣赏美景、出去走走、买菜、喝茶、陪陪父母和家人、让他们开心、生活自律等等，这些都算是有意义的事情吧。</p> \n<p>这些事情，并没有让人觉得是在浪费时间，反而让人觉得，是在真正的放松。</p> \n<p>放松而不放纵，是为了更好的前行。</p> \n<p>&nbsp;</p>',100,NULL,0,'https://www.cnblogs.com/sparrow32/p/16758833.html','2022-10-06 23:55:03'),(2,'谣言检测（）——《Debunking Rumors on Twitter with Tree Transformer》',NULL,NULL,0,0,'<h1 id=\"tid-fEyQey\"><span style=\"font-size: 16px\">论文信息</span></h1> \n<blockquote> \n <p><span style=\"font-size: 16px\">论文标题：Debunking Rumors on Twitter with Tree Transformer</span><br><span style=\"font-size: 16px\">论文作者：Jing Ma、Wei Gao</span><br><span style=\"font-size: 16px\">论文来源：2020，COLING</span><br><span style=\"font-size: 16px\">论文地址：<a href=\"https://www.semanticscholar.org/paper/Debunking-Rumors-on-Twitter-with-Tree-Transformer-Ma-Gao/4d0221d305c0ad4843c9431fbf7e799005d51a96\" target=\"_blank\" rel=\"noopener\">download</a>&nbsp;</span><br><span style=\"font-size: 16px\">论文代码：download</span></p> \n</blockquote> \n<h1><span style=\"font-size: 16px\">1 Introduction</span></h1> \n<p><span style=\"font-size: 16px\">　　出发点：Existing conversation-based techniques for rumor detection either just <span style=\"color: rgba(255, 102, 0, 1)\">strictly follow tree edges</span> or <span style=\"color: rgba(255, 102, 0, 1)\">treat all the posts fully-connected</span> during feature learning.</span></p> \n<p><span style=\"font-size: 16px\">　　创新点：Propose a novel detection model based on tree transformer to better utilize user interactions in the dialogue where post-level self-attention plays the key role for aggregating the intra-/inter-subtree stances.</span></p> \n<p><span style=\"font-size: 16px\">　　例子：以 PLAN 模型为例子——一种帖子之间全连接的例子</span></p> \n<p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/06/a23903d6-7369-4972-b958-0ef9ad0329bf.png\" alt=\"\" loading=\"lazy\"></span></p> \n<p><span style=\"font-size: 16px\">　　结论：Post 之间全连接的模型只适合浅层模型，并不适合深层模型，这是由于 Post 一般只和其 Parent 相关吗，全连接导致 Post 之间的错误连接加重。</span></p> \n<h1><span style=\"font-size: 16px\">2&nbsp;Tree Transformer Model</span></h1> \n<div>\n <span style=\"font-size: 16px\">　　总体框架如下：</span>\n</div> \n<div>\n <span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/06/72917c9e-d7ca-4873-9229-dff4f76a066d.png\" alt=\"\" loading=\"lazy\"></span> \n <h2><span style=\"font-size: 16px\">2.1 Token-Level Tweet Representation&nbsp;</span></h2> \n <p><span style=\"font-size: 16px\">　　Transformer encoder 框架：</span></p> \n <p><span style=\"font-size: 16px\">　　　　<img src=\"http://localhost:8080/static/blogImages/2022/10/06/9d707303-e7c0-4ded-960a-599e9a0a4d15.png\" alt=\"\" loading=\"lazy\"></span></p> \n <p><span style=\"font-size: 16px\">　　给定一条表示为&nbsp;word sequence&nbsp; $x_{i}=\\left(w_{1} \\cdots w_{t} \\cdots w_{\\left|x_{i}\\right|}\\right)$ 的推文，每个 $w_{t} \\in \\mathbb{R}^{d}$ 是一个 $d$ 维向量，可以用预先训练的单词嵌入初始化。我们使用多头自注意网络（MH-SAN）将每个 $w_{i}$ 映射到一个固定大小的隐藏向量中。MH-SAN 的核心思想是共同关注来自不同位置的不同表示子空间的单词。更具体地说，MH-SAN 首先将输入字序列 $x_i$ 转换为具有不同线性投影的多个子空间：</span></p> \n <div>\n  <span style=\"font-size: 16px\">　　　　$Q_{i}^{h}, K_{i}^{h}, V_{i}^{h}=x_{i} \\cdot W_{Q}^{h}, \\quad x_{i} \\cdot W_{K}^{h}, \\quad x_{i} \\cdot W_{V}^{h} \\quad\\quad\\quad(1)$</span>\n </div> \n <div> \n  <p><span style=\"font-size: 16px\">　　其中，$\\left\\{Q_{i}^{h}, K_{i}^{h}, V_{i}^{h}\\right\\}$ 分别为 query、key 和 value representations，$\\left\\{W_{Q}^{h}, W_{K}^{h}, W_{V}^{h}\\right\\} $ 表示与第 $h$ 个头关联的参数矩阵。然后，应用 attention function 来生成输出状态。</span></p> \n  <p><span style=\"font-size: 16px\">　　　　$O_{i}^{h}=\\operatorname{softmax}\\left(\\frac{Q_{i}^{h} \\cdot K_{i}^{h^{\\top}}}{\\sqrt{d_{h}}}\\right) \\cdot V_{i}^{h}&nbsp; \\quad\\quad\\quad(2)$</span></p> \n  <p><span style=\"font-size: 16px\">　　其中，$\\sqrt{d_{h}}$ 是 放缩因子，$d_{h}$ 表示第 $h$ 个头的子空间的维数。最后，表示的输出可以看作是所有头 $O_{i}=\\left[O_{i}^{1}, O_{i}^{2}, \\cdots, O_{i}^{n}\\right] \\in&nbsp; &nbsp;\\mathbb{R}^{\\left|x_{i}\\right| \\times d}$ 的连接，$n$ 为头数，然后是一个归一化层（layerNorm）和前馈网络（FFN）。</span></p> \n  <p><span style=\"font-size: 16px\">　　　　$\\begin{array}{l}B_{i}=\\operatorname{layerNorm}\\left(O_{i} \\cdot W_{B}+O_{i}\\right) \\\\H_{i}=\\operatorname{FFN}\\left(B_{i} \\cdot W_{S}+B_{i}\\right)\\end{array}&nbsp; \\quad\\quad\\quad(3)$</span></p> \n </div> \n <div> \n  <p><span style=\"font-size: 16px\">　　其中 $H_{i}=\\left[h_{1} ; \\ldots ; h_{\\left|x_{i}\\right|}\\right] \\in \\mathbb{R}^{\\left|x_{i}\\right| \\times d}$ 是表示 tweet $x_i$ 中所有单词的矩阵，$W_{B}$ 和 $W_{h}$ 包含 transformation 的权值。最后，我们通过 maxpooling 所有相关 words 的向量，得到了 $x_i$ 的表示：</span></p> \n  <p><span style=\"font-size: 16px\">　　　　$s_{i}=\\max -\\operatorname{pooling}\\left(h_{1}, \\ldots, h_{\\left|x_{i}\\right|}\\right)&nbsp;\\quad\\quad\\quad(4)$</span></p> \n  <p><span style=\"font-size: 16px\">　　其中，$s_{i} \\in \\mathbb{R}^{1 \\times d}$ 为 $d$ 维向量，$|\\cdot|$ 为单词数。</span></p> \n </div> \n <h2><span style=\"font-size: 16px\">2.2 Post-Level Tweet Representation</span></h2> \n <div>\n  <span style=\"font-size: 16px\">　　Why we choose Cross-check all the posts in the same subtree to enhance the representation learning：</span>\n </div> \n <div> \n  <p><span style=\"font-size: 16px\">　　(1) posts are generally short in nature thus the stance expressed in each node is closely correlated with the responsive context;</span></p> \n  <p><span style=\"font-size: 16px\">　　(2) posts in the same subtree direct at the individual opinion expressed in the root of the subtree.</span></p> \n </div> \n <div>\n  <span style=\"font-size: 16px\">　　(3)&nbsp;Coherent opinions can be captured by comparing ALL responsive posts in the same subtree, that lower weight the incorrect information.</span>\n </div> \n <div>\n  <span style=\"font-size: 16px\">&nbsp;</span>\n </div> \n <div>\n  <span style=\"font-size: 16px\"><strong>Bottom-Up Transformer</strong></span>\n </div> \n <p><span style=\"font-size: 16px\">　　Figure 2(c) 说明了本文的 tree transformer 结构，它 cross-check 从底部子树到上部子树的 post。具体来说，给定一个有根于 $x_j$ 的子树，假设 $\\mathcal{V}(j)=\\left\\{x_{j}, \\ldots, x_{k}\\right\\}$ 表示子树中的节点集合，即 $x_j$ 及其直接响应节点。然后，我们在 $\\mathcal{V}(j)$ 上应用一个 post-level subtree attention（a transformer-based block as shown in Figure 2(b)），以得到 $\\mathcal{V}(j)$ 中每个节点的细化表示：</span></p> \n <p><span style=\"font-size: 16px\">　　　　$\\left[s_{j}^{\\prime} ; \\ldots ; s_{k}^{\\prime}\\right]=\\operatorname{TRANS}\\left(\\left[s_{j} ; \\ldots ; s_{k}\\right], \\Theta_{T}\\right) \\quad\\quad\\quad(5)$</span></p> \n <p><span style=\"font-size: 16px\">　　其中，$TRANS&nbsp; (\\cdot)$ 是具有如 Eq. 2-4 中所示的相似形式的 transform function，$\\Theta_{T}$ 包含了 transformer 的参数。因此，$s_{*}^{\\prime}$ 是基于子树的上下文得到的 $s_{*}$ 的细化表示。请注意，每个节点都可以被视为不同子树中的父节点或子节点，例如，在 Figure 2(a) 中，$x_{2}$ 可以是 $T\\left(x_{2}\\right)$ 的父节点，也可以是 $T(r)$ 的子节点。因此，一部分的节点在我们的 from bottom subtree to upper subtree 模型中结果两次层次细化：(1)通过与父节点相比来捕获立场 stance，(2) 通过关注邻居节点来获得较低权重的不准确信息，例如，一个父母支持一个错误的声明可能会细化如果大多数响应驳斥父节点。</span></p> \n <div> \n  <div>\n   <span style=\"font-size: 16px\"><strong>Top-Down Transformer</strong></span>\n  </div> \n </div> \n <p><span style=\"font-size: 16px\">　　Top-down transformer 的方向与 bottom-up transformer 相反，沿着信息传播的方向，其架构如 Figure 2 (d) 所示。同样的，其学习到的表示也通过捕获立场和自我纠正上下文信息得到增强。</span></p> \n <div> \n  <h1><span style=\"font-size: 16px\">2.3 The overall Model</span></h1> \n  <p><span style=\"font-size: 16px\">　　为了共同捕获整个树中表达的观点，我们利用一个注意力层来选择具有准确信息的重要帖子，这是基于细化的节点表示而获得的。这将产生：</span></p> \n  <p><span style=\"font-size: 16px\">　　　　$\\begin{array}{l}\\alpha_{i}=\\frac{\\exp \\left(s_{i}^{\\prime} \\cdot \\mu^{\\top}\\right)}{\\sum\\limits_{j} \\exp \\left(s_{j}^{\\prime} \\cdot \\mu^{\\top}\\right)} \\\\\\tilde{s}=\\sum\\limits_{i} \\alpha_{i} \\cdot s_{i}^{\\prime}\\end{array}\\quad\\quad\\quad(6)$</span></p> \n  <p><span style=\"font-size: 16px\">　　其中，$s_{i}^{\\prime}$ 由 Bottom-Up Transformer 或 Top-Down Transformer 得到，$\\mu \\in \\mathbb{R}^{1 \\times d}$ 是注意力机制的参数。这里的 $\\alpha_{i}$ 是节点 $x_i$ 的注意权值，用于生成整个树的表示 $\\tilde{s}$。最后，我们使用一个全连接的输出层来预测谣言类上的概率分布。</span></p> \n  <p><span style=\"font-size: 16px\">　　$\\hat{y}=\\operatorname{softmax}\\left(V_{o} \\cdot \\tilde{s}+b_{o}\\right) \\quad\\quad\\quad(7)$</span></p> \n  <p><span style=\"font-size: 16px\">　　其中，$V_{o}$ 和 $b_{o}$ 是输出层中的权值和偏差。</span></p> \n  <p><span style=\"font-size: 16px\">　　此外，还有一种直接的方法可以将 Bottom-Up transformer 与 Top-Down transformer 的树表示连接起来，以获得更丰富的树表示，然后将其输入上述的 $softmax (\\cdot)$ 函数进行谣言预测。</span></p> \n  <p><span style=\"font-size: 16px\">　　我们所有的模型都经过训练，以最小化预测的概率分布和地面真实值的概率分布之间的平方误差：</span></p> \n  <span style=\"font-size: 16px\">　　　　$L(y, \\hat{y})=\\sum_{n=1}^{N} \\sum_{c=1}^{C}\\left(y_{c}-\\hat{y}_{c}\\right)^{2}+\\lambda\\|\\Theta\\|_{2}^{2} \\quad\\quad\\quad(8)$</span> \n  <p><span style=\"font-size: 16px\">　　其中 $y_{c}$ 是 ground-truth label ，$\\hat{y}_{c}$ 是类C的预测概率，$N$ 是训练的树数，C 是类的数量，$\\|.\\|_{2}$ 是所有模型参数 $\\Theta$ 上的 $L_{2}$ 正则化项，$\\lambda$ 是权衡系数。</span></p> \n  <h1><span style=\"font-size: 16px\">3 Experiments</span></h1> \n </div> \n <div>\n  <span style=\"font-size: 16px\"><strong>Datasets</strong></span>\n </div> \n <p><span style=\"font-size: 16px\">　　使用 TWITTER 和 PHEME 数据集进行实验，按照传播树深度将两个数据集划分为 TWITTER-S (PHEME-S)和 TWITTER-D (PHEME-D) 一共4个数据集，下表展示数据集的统计情况：</span></p> \n <div>\n  <span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/06/43bb717a-6534-4c6d-993e-0806b519ce3d.png\" alt=\"\" loading=\"lazy\"></span> \n  <p><span style=\"font-size: 16px\"><strong>Experiment</strong></span></p> \n </div> \n <div>\n  　　\n  <img src=\"http://localhost:8080/static/blogImages/2022/10/06/43e4b1c6-8cc3-46b9-9362-5d800066b626.png\" alt=\"\" loading=\"lazy\"> \n  <p><strong>Early Rumor Detection Performance</strong></p> \n </div> \n <div>\n  　　\n  <img src=\"http://localhost:8080/static/blogImages/2022/10/06/8973f69f-0381-47b2-b09d-f15da2fa97d6.png\" alt=\"\" loading=\"lazy\"> \n </div> \n</div>',100,NULL,0,'https://www.cnblogs.com/BlairGrowing/p/16758351.html','2022-10-06 23:55:14'),(3,'JavaScript之无题之让人烦躁的模块化',NULL,NULL,0,0,'<p>　　我怎么记得我好像写过相关类型的文章，但是我找遍了我的博客没有～那就再写一遍吧，其实模块化的核心内容也算不上是复杂，只不过需要整理一下，规划一下罢了。嘻嘻。</p> \n<p>　　开始写标题的时候我就在纠结一件事情，就是，先吃喜欢吃的，还是后吃喜欢吃的，翻译过来就是我应该先写CommonJS和ES6 Module，还是先写CMD和AMD。嗯，我决定了，<strong>谁先做好了我就先吃谁</strong>。</p> \n<p>　　其实模块化的缘由很简单，就一句话，不对，就一个词，两个字，<strong>分类</strong>。如果一定让我在加一点，那应该是“<strong>隔离</strong>”。没了～～但是这么少不太好，我举个可能不那么恰当的例子吧。<strong><br></strong></p> \n<p>　　刚开始这个世界上只有三个人，起名字的时候会“刻意”的避开彼此已经叫过的名字，他们在一起生活，日子欣欣向荣，一片美好，对未来充满了期待。</p> \n<p>　　时间飞逝，三个人变成了三十人，他们勉强还是住在一起，起名字的时候虽然费事一点，但是也还能不重复，日子还是欣欣向荣，一片美好，对未来充满了期待。</p> \n<p>　　时间又飞逝，三十人变成了三百人，那这不太好管理了，于是三位首领就说，你们有领导能力的几个人站出来，组成各自的部落，去吧，我相信你们可以的。于是每个部落住在一起，部落与部落之间的人可以重名，叫名字的时候再加上一个部落的名称呗，嗯~又一片欣欣向荣。</p> \n<p>　　时间继续飞逝，三百人变成了三千人，这三千人住在几个大部落里也很不方便，你拿我的苹果，我偷了你得猪，这肯定不行，有碍于社会的稳定发展，于是三个创始者叫上部落的组长说，我们给每个人分一块地，盖一个房子，把三五个人分割成一个家庭，家庭之间由部落作为纽带，关联彼此，在形式上又相互独立，不可以随便拿别家的苹果。很完美~</p> \n<p>　　时间飞飞飞飞逝，三千人变成了三百万人……我们需要<strong>法律</strong>了。</p> \n<p>　　OK，上面的小例子，人，就是函数，部落就是命名空间，房子就是IIFE，法律就是后续发展的模块化规范。那么我们依照上面的描述，如何转换成代码？</p> \n<h3>一、社会的起源与法律的雏形</h3> \n<p>　　最开始的时候，浏览器只需要简单的图文展示就是可以了，没什么复杂的交互和逻辑的处理，所以，当我们只有三个人的时候，我们可以很自由，很随意：</p> \n<div class=\"cnblogs_code\"> \n <pre>function<span> a(){}\n\nfunction b(){}</span></pre> \n</div> \n<p>　　随着Web的发展，交互的增多，项目的扩大，很容易有人也声明了同样名称的函数，于是纷争开始了，那咋解决纷争呢？嗯，命名空间也就是拆分部落，就像这样：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">var</span> zaking1 =<span style=\"color: rgba(0, 0, 0, 1)\"> {\n    a:</span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\">(){},\n    b:</span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\">(){}\n}\n</span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> zaking2 =<span style=\"color: rgba(0, 0, 0, 1)\"> {\n    a:</span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\">(){},\n    b:</span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\">(){}\n}</span></pre> \n</div> \n<p>　　但是这样并不能真正的解决问题，因为虽然从形式上区分了部落，但是部落之间没有任何的隔离，部落内部也是混乱的，所以各个首领就制定了一个方案，IIFE，利用闭包的特性，来实现数据的隔离，暴露出对外的入口：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">var</span> module = (<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> () {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> name = \"zaking\"<span style=\"color: rgba(0, 0, 0, 1)\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> getName() {\n    console.log(name);\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> { getName };\n})();\nmodule.getName();</span></pre> \n</div> \n<p>　　我们盖好了房子，还给房子建好了可以出入的门，但是我怎么邀请别人进来呢？</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">var</span> module = (<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> (neighbor) {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> name = \"zaking\"<span style=\"color: rgba(0, 0, 0, 1)\">;\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> getName() {\n    console.log(name </span>+ \"和邻居：\" +<span style=\"color: rgba(0, 0, 0, 1)\"> neighbor);\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> { getName };\n})(</span>\"xiaowangba\"<span style=\"color: rgba(0, 0, 0, 1)\">);\nmodule.getName();</span></pre> \n</div> \n<p>　　传个参数呗，这就是依赖注入。在这个阶段，最有代表性的就是jQuery了，它的封闭性的核心实现，跟上面的代码几乎无异，我们可以看下jQuery的模块的实现：</p> \n<div class=\"cnblogs_code\"> \n <pre>(<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> (global, factory) {\n  factory(global);\n})(</span><span style=\"color: rgba(0, 0, 255, 1)\">typeof</span> window !== \"undefined\" ? window : <span style=\"color: rgba(0, 0, 255, 1)\">this</span>, <span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> (window, noGlobal) {\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (<span style=\"color: rgba(0, 0, 255, 1)\">typeof</span> noGlobal === \"undefined\"<span style=\"color: rgba(0, 0, 0, 1)\">) {\n    window.jQuery </span>= window.$ =<span style=\"color: rgba(0, 0, 0, 1)\"> jQuery;\n  }\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> jQuery;\n});</span></pre> \n</div> \n<p>　　当然我这里略了很多，你看它，无非就是一个闭包，传入了window和jQuery本身，然后再绑定到window上，这样，我们就只能访问到暴露出来的$以及$上的方法和属性，我们根本无法修改内部的数据。</p> \n<p>　　OK，到了这个阶段，其实算是一个转折点，我们有了初步的法律，还需要后续针对法律的完善，</p> \n<h3>二、法律的初现与CommonJs</h3> \n<p>　　随着社会的发展，出现一种规则已成必然，于是commonJs统领举起模块化的大旗，让JavaScript迈向了另一个阶段。<span>commonJs最初由&nbsp;<code>JavaScript</code>&nbsp;社区中的&nbsp;<code>Mozilla</code>&nbsp;的工程师<code>Kevin Dangoor</code>在Google Groups中创建了一个ServerJs小组。该组织的目标是为web服务器、桌面和命令行应用程序以及浏览器构建JavaScript生态系统。嗯，它的野心很大~，后来，他就就把ServerJs改成了commonJs，毕竟ServerJs的范围有点小，commonJs更符合他们的初衷。</span></p> \n<p><span>　　而后，在同一年的年底，NodeJs出现了，Javascript不仅仅可以用于浏览器，在服务器端也开始攻城略地。NodeJs的初衷是基于commonJs社区的模块化规范，但是NodeJs并没有完全遵循于社区的一些腐朽过时的约束，它实现了自己的想法。</span></p> \n<p><span>　　commonJs规范的写法，如果大家写过NodeJs一定都有所了解，大概是这样的：</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> a.js</span>\nmodule.exports = \'zaking\'\n<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> b.js</span>\nconst a = require(\"./a\"<span style=\"color: rgba(0, 0, 0, 1)\">);\nconsole.log(a); </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> zaking</span></pre> \n</div> \n<p>　　看起来挺简单的，但是这里隐藏了一些不那么容易被理解的特性。</p> \n<p>　　在NodeJs中，一个文件就是一个模块，有自己的作用域，在一个文件里面定义的函数、对象都是私有的，对其他文件不可见。并且，<strong>当第一次加载某个模块的时候，NodeJ会缓存该模块，待再次加载的时候</strong>，会直接从模块中取出module.exports属性返回。比如：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> a.js</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">var</span> name = \"zaking\"<span style=\"color: rgba(0, 0, 0, 1)\">;\nexports.name </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> name;\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> b.js</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">var</span> a = require(\"./a.js\"<span style=\"color: rgba(0, 0, 0, 1)\">);\nconsole.log(a.name); </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> zaking</span>\na.name = \"xiaoba\"<span style=\"color: rgba(0, 0, 0, 1)\">;\n</span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> b = require(\"./a.js\"<span style=\"color: rgba(0, 0, 0, 1)\">);\nconsole.log(b.name); </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> xiaoba</span></pre> \n</div> \n<p>　　诶？为啥你写的是“exports.”，不是module.exports？NodeJs在实现CommonJs规范的时候为了方便，给每个模块都提供了一个exports私有变量，指向module.exports。<strong>有一点要尤其注意，<code>exports</code>&nbsp;是模块内的私有局部变量，它只是指向了&nbsp;<code>module.exports</code>，所以直接对&nbsp;<code>exports</code>&nbsp;赋值是无效的，这样只是让&nbsp;<code>exports</code>&nbsp;不再指向&nbsp;<code>module.exports</code>了而已。</strong></p> \n<p><strong>　　</strong>我们回到上面的代码，按理来说，我第二次引入的b的name应该是“zaking”啊。但是实际上，<strong>在第一次引入之后的引入，并不会再次执行模块的内容，只是返回了缓存的结果。</strong></p> \n<p><strong>　　另外一个核心的点是，我们导入的是导出值的拷贝，也就是说一旦引入之后，模块内部关于该值的变化并不会被影响。</strong></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> a.js</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">var</span> name = \"zaking\"<span style=\"color: rgba(0, 0, 0, 1)\">;\n</span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> changeName() {\n  name </span>= \"xiaowangba\"<span style=\"color: rgba(0, 0, 0, 1)\">;\n}\nexports.name </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> name;\nexports.changeName </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> changeName;\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> b.js</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">var</span> a = require(\"./a.js\"<span style=\"color: rgba(0, 0, 0, 1)\">);\nconsole.log(a.name); </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> zaking</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">a.changeName();\nconsole.log(a.name); </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> zaking</span></pre> \n</div> \n<p>　　嗯，一切看起来都很不错。</p> \n<h3>三、争奇斗艳，百家争鸣</h3> \n<p>　　在上一小节，我们简单介绍了模块化的始祖也就是CommonJs以及实现了该规范的NodeJs的一些核心内容。但是NodeJs的实现的一个关键的点是，它在读取或者说加载模块的时候是同步的，这在服务器没什么问题，但是对于浏览器来说，这个问题就很严重，因为大量的同步模块加载意味着大量的白屏等待时间。</p> \n<p>　　基于这样的问题，从CommonJs中独立出了AMD规范。</p> \n<h4>1、AMD规范与RequireJs</h4> \n<p>　　AMD，即Asynchronous Module Definition，翻译过来就是异步模块化规范，它的主要目的就是解决CommonJs不能在浏览器中使用的问题。但是RequireJs在实现上，希望可以通吃，也就是可以在任何宿主环境下使用。</p> \n<p>　　我们先来看个例子：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">&lt;!</span><span style=\"color: rgba(255, 0, 255, 1)\">DOCTYPE html</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">html </span><span style=\"color: rgba(255, 0, 0, 1)\">lang</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"en\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">head</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">meta </span><span style=\"color: rgba(255, 0, 0, 1)\">charset</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"UTF-8\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">meta </span><span style=\"color: rgba(255, 0, 0, 1)\">http-equiv</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"X-UA-Compatible\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> content</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"IE=edge\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">meta </span><span style=\"color: rgba(255, 0, 0, 1)\">name</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"viewport\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> content</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"width=device-width, initial-scale=1.0\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">title</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>Document<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">title</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">head</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">script </span><span style=\"color: rgba(255, 0, 0, 1)\">src</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"https://requirejs.org/docs/release/2.3.6/comments/require.js\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">script</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">body</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">body</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">script</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span><strong><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\"> require([</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">\"</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">./a</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">\"</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">]); </span></strong><span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">script</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">html</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span></pre> \n</div> \n<p>　　然后，我们的a.js是这样的：</p> \n<div class=\"cnblogs_code\"> \n <pre>define(<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> () {\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> fun1() {\n    alert(</span>\"it works\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n  }\n\n  fun1();\n});</span></pre> \n</div> \n<p>　　define用来声明一个模块，require导入。我们还可以这样：</p> \n<div class=\"cnblogs_code\"> \n <pre>require([\"./a\"], <span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> () {\n  alert(</span>\"load finished\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n});</span></pre> \n</div> \n<p>　　导入前置依赖的模块，在第二个参数也就是回调中执行。RequireJs会在所有的模块解析完成后执行回调函数。就算你倒入了一个没有使用的模块，RequireJs也一样会加载：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">&lt;!</span><span style=\"color: rgba(255, 0, 255, 1)\">DOCTYPE html</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">html </span><span style=\"color: rgba(255, 0, 0, 1)\">lang</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"en\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">head</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">meta </span><span style=\"color: rgba(255, 0, 0, 1)\">charset</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"UTF-8\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">meta </span><span style=\"color: rgba(255, 0, 0, 1)\">http-equiv</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"X-UA-Compatible\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> content</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"IE=edge\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">meta </span><span style=\"color: rgba(255, 0, 0, 1)\">name</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"viewport\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> content</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"width=device-width, initial-scale=1.0\"</span> <span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">title</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>Document<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">title</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">head</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">script </span><span style=\"color: rgba(255, 0, 0, 1)\">src</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"https://requirejs.org/docs/release/2.3.6/comments/require.js\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">script</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">body</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">body</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">script</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">\n    require([</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">\"</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">./a</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">\"</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">, </span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">\"</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">./b</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">\"</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\">], </span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 255, 1)\">function</span><span style=\"background-color: rgba(245, 245, 245, 1); color: rgba(0, 0, 0, 1)\"> (a, b) {\n      a.fun1();\n    });\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">script</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">html</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span></pre> \n</div> \n<p>　　然后分别是a.js和b.js：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> a.js</span>\ndefine(<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> () {\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> fun1() {\n    alert(</span>\"it works fun1\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n  }\n\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> {\n    fun1: fun1,\n  };\n});\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> b.js</span>\ndefine(<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> () {\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\"> fun2() {\n    alert(</span>\"it works fun2\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n  }\n\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> {\n    fun2: fun2,\n  };\n});</span></pre> \n</div> \n<p>　　结果大家可以试一试～</p> \n<p>　　以上就是RequireJs的简单用法，我们据此知道了两个核心内容，RequireJs基于AMD规范，RequireJs会加载你引入的所有模块，哪怕你并不会真的用到它。</p> \n<h4>2、CMD规范与SeaJs</h4> \n<p>　　由于RequireJs的一些问题，又出现了基于CMD规范的SeaJs，SeaJs和RequireJs有一个最大的不同就是RequireJs希望可以通吃，但是SeaJs则更专注于浏览器，哦对了，CMD的全称叫做：Common Module Definition，即通用模块规范。</p> \n<p>　　SeaJs的简单用法如下：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 所有模块都通过 define 来定义</span>\ndefine(<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\">(require, exports, module) {\n\n  </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 通过 require 引入依赖</span>\n  <span style=\"color: rgba(0, 0, 255, 1)\">var</span> a = require(\'xxx\'<span style=\"color: rgba(0, 0, 0, 1)\">)\n  </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> b = require(\'yyy\'<span style=\"color: rgba(0, 0, 0, 1)\">)\n\n  </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 通过 exports 对外提供接口</span>\n  exports.doSomething =<span style=\"color: rgba(0, 0, 0, 1)\"> ...\n\n  </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 或者通过 module.exports 提供整个接口</span>\n  module.exports =<span style=\"color: rgba(0, 0, 0, 1)\"> ...\n\n})\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> a.js</span>\ndefine(<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\">(require, exports, module){\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> name = \'morrain\'\n    <span style=\"color: rgba(0, 0, 255, 1)\">var</span> age = 18<span style=\"color: rgba(0, 0, 0, 1)\">\n\n    exports.name </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> name\n    exports.getAge </span>= () =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> age\n})\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> b.js</span>\ndefine(<span style=\"color: rgba(0, 0, 255, 1)\">function</span><span style=\"color: rgba(0, 0, 0, 1)\">(require, exports, module){\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> name = \'lilei\'\n    <span style=\"color: rgba(0, 0, 255, 1)\">var</span> age = 15\n    <span style=\"color: rgba(0, 0, 255, 1)\">var</span> a = require(\'a.js\'<span style=\"color: rgba(0, 0, 0, 1)\">)\n\n    console.log(a.name) </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> \'morrain\'</span>\n    console.log(a.getAge()) <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">18</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">\n    exports.name </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> name\n    exports.getAge </span>= () =&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> age\n})</span></pre> \n</div> \n<p>　　上面的代码是从网上抄的，大概说明白了基本的使用方法。我们可以看到，SeaJs的导入和导出的方式，跟NodeJs好像～～而SeaJs从书写形式上，更像是CommonJs和AMD的结合。当然，我只是说书写形式上。</p> \n<p>　　而AMD和CMD，RequireJs和SeaJs，都是由社区发起的，并没有语言层面的规范，包括CommonJs以及NodeJs，所以，这个时代还是一个百花争艳，没有统一的时代，不过在现在，这些都不重要了。如果非要我说些什么，那就是，忘记这两个东西，去学下面的重点。</p> \n<h3>四、大一统</h3> \n<p>　　百花争艳的时代确实有些烦人，这个那个那个这个，又都不被官方认可，还好，官方终于还是出手了，ES6的出现，在语言层面上就提出了对于模块化的规范，也就是<strong>ES6 Module</strong>。它太重要了，具体语法我就不多说了，文末的链接附上了阮一峰大神的《ES6入门指南》关于ES6 Module的地址。</p> \n<p>　　所以到了ES6的时候，你要学习的就是ES6 Module，NodeJs也在逐步实现对ES6 Module的支持。最终，秦始皇会一统天下，这是必然的结果。</p> \n<p>　　这篇文章到这里就结束了，说实话，模块化的问题和历史由来已久，从萌芽到统一，至少十几年的过程，而市面上也已有大量的文章介绍彼此的区别和各自的特点，我写来写去，也不过是复制一遍，毫无意义。</p> \n<p>　　但是我又想学一下模块化，以及模块化的历史，额……，请原谅我的无知，所以才有了这篇文章，但是写着写着，发现我能表达出来的东西并不多，因为都是故事，都是历史，并且对于未来的开发好像也没什么实际的意义和价值。</p> \n<p>　　所以，在如此纠结的心态下有了这篇文章，原谅我无知又想逼逼的心情吧。</p> \n<p>　　最后的最后，如果你想学习模块化，在现阶段，只需要去深入学习ES6 Module，和学习一下NodeJs的CommonJs，以及了解一下各模块化的区别即可，因为现在是即将统一，还未完全统一的时候。</p> \n<p>&nbsp;</p> \n<h3>参考资料：</h3> \n<p>　　https://wiki.commonjs.org/wiki/CommonJS</p> \n<p>　　https://github.com/seajs/seajs/issues/242</p> \n<p>　　https://es6.ruanyifeng.com/#docs/module</p>',100,NULL,0,'https://www.cnblogs.com/zaking/p/16732719.html','2022-10-06 23:55:15'),(4,'CPS攻击案例（一）——基于脉冲宽度调制PWM的无人机攻击',NULL,NULL,0,0,'<span data-cke-copybin-start=\"1\"><span data-cke-copybin-start=\"1\">​</span></span> \n<p><strong><span id=\"cke_bm_962S\">&nbsp;本文系原创，转载请说明出处</span></strong></p> \n<p>Please Subscribe Wechat Official Account：信安科研人，获取更多的原创安全资讯</p> \n<p>原论文链接：<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"46\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"sec22-dayanikli.pdf (usenix.org)\" href=\"https://www.usenix.org/system/files/sec22-dayanikli.pdf\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://www.usenix.org/system/files/sec22-dayanikli.pdf\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fwww.usenix.org%2Fsystem%2Ffiles%2Fsec22-dayanikli.pdf%22%2C%22text%22%3A%22sec22-dayanikli.pdf%20(usenix.org)%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%220sCbIb-1665062133804%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"sec22-dayanikli.pdf (usenix.org)\" data-widget=\"csdnlink\" rel=\"noopener\">sec22-dayanikli.pdf (usenix.org)</a></span></p> \n<p id=\"main-toc\"><strong>目录</strong></p> \n<p id=\"%E6%91%98%E8%A6%81-toc\"><a href=\"#%E6%91%98%E8%A6%81\" rel=\"noopener\">摘要</a></p> \n<p id=\"%E4%B8%80%20%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF-toc\"><a href=\"#%E4%B8%80%20%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF\" rel=\"noopener\">一 知识背景</a></p> \n<p id=\"1.1%20CPS-toc\"><a href=\"#1.1%20CPS\" rel=\"noopener\">1.1 CPS</a></p> \n<p id=\"1.2%20%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6PWM-toc\"><a href=\"#1.2%20%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6PWM\" rel=\"noopener\">1.2 脉冲宽度调制PWM</a></p> \n<p id=\"%E4%BA%8C%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6%E6%80%9D%E8%B7%AF-toc\"><a href=\"#%E4%BA%8C%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6%E6%80%9D%E8%B7%AF\" rel=\"noopener\">二 攻击方案研究思路</a></p> \n<p id=\"2.1%20%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF-toc\"><a href=\"#2.1%20%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF\" rel=\"noopener\">2.1 研究背景</a></p> \n<p id=\"2.2%20%E7%81%B5%E6%84%9F%E4%B8%8E%E5%8A%A8%E6%9C%BA-toc\"><a href=\"#2.2%20%E7%81%B5%E6%84%9F%E4%B8%8E%E5%8A%A8%E6%9C%BA\" rel=\"noopener\">2.2 灵感与动机</a></p> \n<p id=\"2.3%20PWM%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E6%9C%BA%E7%90%86-toc\"><a href=\"#2.3%20PWM%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E6%9C%BA%E7%90%86\" rel=\"noopener\">2.3 PWM控制执行器的机理</a></p> \n<p id=\"2.3.1%20PWM%E4%BF%A1%E5%8F%B7%E6%90%BA%E5%B8%A6%E8%87%B4%E5%8A%A8%E6%95%B0%E6%8D%AE-toc\"><a href=\"#2.3.1%20PWM%E4%BF%A1%E5%8F%B7%E6%90%BA%E5%B8%A6%E8%87%B4%E5%8A%A8%E6%95%B0%E6%8D%AE\" rel=\"noopener\">2.3.1 PWM信号携带致动数据</a></p> \n<p id=\"%C2%A0%20%C2%A02.3.2%20%E8%87%B4%E5%8A%A8%E5%99%A8%E4%BD%BF%E7%94%A8PWM%E7%9A%84%E4%B8%8A%E5%8D%87%E6%B2%BF%E5%92%8C%E4%B8%8B%E9%99%8D%E6%B2%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E7%A1%AE%E5%AE%9A%E8%87%B4%E5%8A%A8%E6%95%B0%E6%8D%AE-toc\"><a href=\"#%C2%A0%20%C2%A02.3.2%20%E8%87%B4%E5%8A%A8%E5%99%A8%E4%BD%BF%E7%94%A8PWM%E7%9A%84%E4%B8%8A%E5%8D%87%E6%B2%BF%E5%92%8C%E4%B8%8B%E9%99%8D%E6%B2%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E7%A1%AE%E5%AE%9A%E8%87%B4%E5%8A%A8%E6%95%B0%E6%8D%AE\" rel=\"noopener\">&nbsp; &nbsp;2.3.2 致动器使用PWM的上升沿和下降沿之间的持续时间确定致动数据</a></p> \n<p id=\"2.4%20%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A-toc\"><a href=\"#2.4%20%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A\" rel=\"noopener\">2.4 攻击场景设定</a></p> \n<p id=\"%E4%B8%89%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E3%80%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E9%AA%8C%E8%AE%BE%E5%A4%87-toc\"><a href=\"#%E4%B8%89%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E3%80%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E9%AA%8C%E8%AE%BE%E5%A4%87\" rel=\"noopener\">三 攻击方案、原理与实验设备</a></p> \n<p id=\"3.1%20%C2%A0%E6%B5%8B%E8%AF%95%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%E5%AF%B9%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BD%B1%E5%93%8D-toc\"><a href=\"#3.1%20%C2%A0%E6%B5%8B%E8%AF%95%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%E5%AF%B9%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BD%B1%E5%93%8D\" rel=\"noopener\">3.1 &nbsp;测试攻击波形对通信信号的影响</a></p> \n<p id=\"3.1.1%20%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%E2%85%A0%EF%BC%9ABLOCK-toc\"><a href=\"#3.1.1%20%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%E2%85%A0%EF%BC%9ABLOCK\" rel=\"noopener\">3.1.1 攻击波形Ⅰ：BLOCK</a></p> \n<p id=\"3.1.2%20%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%C2%A0%E2%85%A0%E2%85%A0%20%EF%BC%9ABLOCK%20%26%20ROTATE-toc\"><a href=\"#3.1.2%20%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%C2%A0%E2%85%A0%E2%85%A0%20%EF%BC%9ABLOCK%20%26%20ROTATE\" rel=\"noopener\">3.1.2 攻击波形&nbsp;ⅠⅠ ：BLOCK &amp; ROTATE</a></p> \n<p id=\"3.1.3%C2%A0%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%20III%EF%BC%9A%E5%AE%8C%E5%85%A8%E6%8E%A7%E5%88%B6-toc\"><a href=\"#3.1.3%C2%A0%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%20III%EF%BC%9A%E5%AE%8C%E5%85%A8%E6%8E%A7%E5%88%B6\" rel=\"noopener\">3.1.3&nbsp;攻击波形 III：完全控制</a></p> \n<p id=\"%C2%A03.1.4%20%E5%90%84%E6%B3%A2%E5%BD%A2%E5%AF%B9%E6%AF%94-toc\"><a href=\"#%C2%A03.1.4%20%E5%90%84%E6%B3%A2%E5%BD%A2%E5%AF%B9%E6%AF%94\" rel=\"noopener\">&nbsp;3.1.4 各波形对比</a></p> \n<p id=\"3.2%20%E5%AE%9E%E4%BE%8B%E6%94%BB%E5%87%BB-toc\"><a href=\"#3.2%20%E5%AE%9E%E4%BE%8B%E6%94%BB%E5%87%BB\" rel=\"noopener\">3.2 实例攻击</a></p> \n<p id=\"%E5%9B%9B%20%E8%AF%95%E9%AA%8C%E7%BB%93%E6%9E%9C-toc\"><a href=\"#%E5%9B%9B%20%E8%AF%95%E9%AA%8C%E7%BB%93%E6%9E%9C\" rel=\"noopener\">四 试验结果</a></p> \n<hr> \n<h1 id=\"%E6%91%98%E8%A6%81\">摘要</h1> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;攻击者通过放置在己方无人机上的电磁干扰部件，构造三种不同的攻击波形，作用到无人机控制器与伺服电机之间通讯的PWM电缆，构造的波形与PWM电缆中的PWM波耦合，因原PWM波携带指令数据，耦合后数据变更，进而阻塞或修改指令数据，进而影响伺服电机的操作，最终对无人机进行攻击，达到干扰进入我方空域的敌方无人机，甚至控制敌方无人机，与常规的炮火对空攻击不同，此攻击方式花费较小。</p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"45\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/1cf85f88-ab40-42f4-89a7-fc3876de7644.jpeg\" alt=\"\" width=\"832\" height=\"428\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/1cf85f88-ab40-42f4-89a7-fc3876de7644.jpeg\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F2522ee94172840d193a9a1d5fd1c020a.jpeg%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22832%22%2C%22height%22%3A%22428%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<hr> \n<p>&nbsp;</p> \n<h1 id=\"%E4%B8%80%20%E7%9F%A5%E8%AF%86%E8%83%8C%E6%99%AF\">一 知识背景</h1> \n<h2 id=\"1.1%20CPS\">1.1 CPS</h2> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; CPS是cyber-physical system的缩写，也就是<strong>信息物理系统</strong>。</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; CPS由四大组件构成：执行器、传感器、控制器以及被控对象，基本执行流程如下图</p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"44\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fb489ce99dfe8461e8b67ab19f65b6caf.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22417%22%2C%22height%22%3A%22228%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/896f7370-a6ad-4ff7-951b-ca23e33c12e0.png\" alt=\"\" width=\"417\" height=\"228\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/896f7370-a6ad-4ff7-951b-ca23e33c12e0.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;传感器将系统变量（例如加速度）转换为电（数字或模拟）信号并将它们发送到控制器；控制器处理传感器数据并决定如何影响系统的未来状态，并向执行器（例如电机）发送致动信号。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p> \n<h2 id=\"1.2%20%E8%84%89%E5%86%B2%E5%AE%BD%E5%BA%A6%E8%B0%83%E5%88%B6PWM\">1.2 脉冲宽度调制PWM</h2> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; <strong>脉冲宽度调制</strong>（英语：<strong>Pulse-width modulation</strong>，缩写：<strong>PWM</strong>），简称<strong>脉宽调制</strong>，<strong>是将<strong><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"43\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"模拟信号\" href=\"https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E8%A8%8A%E8%99%9F\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E9%A1%9E%E6%AF%94%E8%A8%8A%E8%99%9F\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E9%25A1%259E%25E6%25AF%2594%25E8%25A8%258A%25E8%2599%259F%22%2C%22text%22%3A%22%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22PjwZXb-1665062133803%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"模拟信号\" data-widget=\"csdnlink\" rel=\"noopener\">模拟信号</a></span></strong>变换为脉冲</strong>的一种技术，一般变换后脉冲的周期固定，但脉冲的<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"42\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"工作周期\" href=\"https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%BD%9C%E9%80%B1%E6%9C%9F\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%B7%A5%E4%BD%9C%E9%80%B1%E6%9C%9F\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E5%25B7%25A5%25E4%25BD%259C%25E9%2580%25B1%25E6%259C%259F%22%2C%22text%22%3A%22%E5%B7%A5%E4%BD%9C%E5%91%A8%E6%9C%9F%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22RFfvxK-1665062133803%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"工作周期\" data-widget=\"csdnlink\" rel=\"noopener\">工作周期</a>会依模拟信号的大小而改变。</span></p> \n<p>&nbsp; &nbsp; &nbsp;</p> \n<p><strong>（1）提出背景：模拟信号有很多问题</strong></p> \n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>&nbsp;参考：<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"41\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"数字信号和模拟信号_一剑何风情的博客-CSDN博客_数字信号\" href=\"https://blog.csdn.net/weixin_37641832/article/details/87958637\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://blog.csdn.net/weixin_37641832/article/details/87958637\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fblog.csdn.net%2Fweixin_37641832%2Farticle%2Fdetails%2F87958637%22%2C%22text%22%3A%22%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%E5%92%8C%E6%A8%A1%E6%8B%9F%E4%BF%A1%E5%8F%B7_%E4%B8%80%E5%89%91%E4%BD%95%E9%A3%8E%E6%83%85%E7%9A%84%E5%8D%9A%E5%AE%A2-CSDN%E5%8D%9A%E5%AE%A2_%E6%95%B0%E5%AD%97%E4%BF%A1%E5%8F%B7%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22jnUy8T-1665062133803%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"数字信号和模拟信号_一剑何风情的博客-CSDN博客_数字信号\" data-widget=\"csdnlink\" rel=\"noopener\">数字信号和模拟信号_一剑何风情的博客-CSDN博客_数字信号</a></span></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在模拟电路中，模拟信号的值可以连续进行变化，在时间和值的幅度上都几乎没有限制，基本上可以取任何实数值，所以能通过代表任意值对设备进行操作。</p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"40\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/230504ee-8289-4a37-aacf-381cd818ce00.png\" alt=\"在这里插入图片描述\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/230504ee-8289-4a37-aacf-381cd818ce00.png\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F20190226235309127.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70%22%2C%22alt%22%3A%22%E5%9C%A8%E8%BF%99%E9%87%8C%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0%22%2C%22width%22%3A%22%22%2C%22height%22%3A%22%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>但模拟电路有诸多的问题</strong>：例如控制信号容易随时间漂移，难以调节；功耗大；易受噪声和环境干扰等。生成模拟信号对于数字电路而言往往需要额外的数字-模拟转换器。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp;<strong><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"39\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"数字电路\" href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%2595%25B0%25E5%25AD%2597%25E7%2594%25B5%25E8%25B7%25AF%22%2C%22text%22%3A%22%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22kIzRwq-1665062133802%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"数字电路\" data-widget=\"csdnlink\" rel=\"noopener\">数字电路</a></span></strong></strong>在任何时刻，其输出只可能为ON和OFF两种状态，所以数字信息丢失能力弱，抗干扰能力强。</p> \n<p><strong>（2）如何用数字信号表示模拟信号</strong></p> \n<p>&nbsp; &nbsp; &nbsp;&nbsp;<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"38\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/780c9b8d-35de-4c84-8fe7-8976cf736459.png\" alt=\"在这里插入图片描述\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/780c9b8d-35de-4c84-8fe7-8976cf736459.png\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F20190227000850472.png%3Fx-oss-process%3Dimage%2Fwatermark%2Ctype_ZmFuZ3poZW5naGVpdGk%2Cshadow_10%2Ctext_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzY0MTgzMg%3D%3D%2Csize_16%2Ccolor_FFFFFF%2Ct_70%22%2C%22alt%22%3A%22%E5%9C%A8%E8%BF%99%E9%87%8C%E6%8F%92%E5%85%A5%E5%9B%BE%E7%89%87%E6%8F%8F%E8%BF%B0%22%2C%22width%22%3A%22%22%2C%22height%22%3A%22%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>模拟信号数字化一般需要三个步骤：<strong>采样、量化和编码。</strong></p> \n<p><strong>1 采样：</strong>按时间间隔进行采样。如上图，每 1s 进行一次采样（<strong>采样的频率被称为采样率</strong>）。</p> \n<p><strong>2 量化：</strong>因为模拟信号本质上是一连串连续的值，我们可以对这些值进行等级划分（量化的等级），这样步骤一的采集到的样品就可以被划分到不同的等级。</p> \n<p><strong>3 编码：</strong>步骤二中的不同等级可以表示不同的编码（如果该采样时间段内，波的面积小于二分之一，则认为是0，大于则是1）。则连续的模拟信号最终可以转化 0101 的数字信号。</p> \n<p>综上，不难得出，随着采样率和量化等级的增加，转换后的数字信号的曲线也就越能贴近模拟信号的曲线（对比上图的原曲线和黄色曲线）。</p> \n<p><strong>（3）PWM技术</strong></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>PWM技术是一种对模拟信号<strong><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"37\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"电平\" href=\"https://zh.wikipedia.org/wiki/%E7%94%B5%E5%B9%B3\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E7%94%B5%E5%B9%B3\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E7%2594%25B5%25E5%25B9%25B3%22%2C%22text%22%3A%22%E7%94%B5%E5%B9%B3%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%222TV5c8-1665062133802%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"电平\" data-widget=\"csdnlink\" rel=\"noopener\">电平</a></span></strong>的数字<strong><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"36\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"编码\" href=\"https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A0%81\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E7%25BC%2596%25E7%25A0%2581%22%2C%22text%22%3A%22%E7%BC%96%E7%A0%81%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22vCoO1f-1665062133802%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"编码\" data-widget=\"csdnlink\" rel=\"noopener\">编码</a></span></strong>方法</strong>，通过使用高分辨率<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"35\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"计数器\" href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E5%99%A8\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E8%AE%A1%E6%95%B0%E5%99%A8\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E8%25AE%25A1%25E6%2595%25B0%25E5%2599%25A8%22%2C%22text%22%3A%22%E8%AE%A1%E6%95%B0%E5%99%A8%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22fLQyEX-1665062133802%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"计数器\" data-widget=\"csdnlink\" rel=\"noopener\">计数器</a>（调制频率）调制<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"34\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"方波\" href=\"https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%A2\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E6%96%B9%E6%B3%A2\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%2596%25B9%25E6%25B3%25A2%22%2C%22text%22%3A%22%E6%96%B9%E6%B3%A2%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22NyHf9S-1665062133802%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"方波\" data-widget=\"csdnlink\" rel=\"noopener\">方波</a>的<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"33\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"占空比\" href=\"https://zh.wikipedia.org/wiki/%E5%8D%A0%E7%A9%BA%E6%AF%94\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%8D%A0%E7%A9%BA%E6%AF%94\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E5%258D%25A0%25E7%25A9%25BA%25E6%25AF%2594%22%2C%22text%22%3A%22%E5%8D%A0%E7%A9%BA%E6%AF%94%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22mkZdsV-1665062133801%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"占空比\" data-widget=\"csdnlink\" rel=\"noopener\">占空比</a>，从而实现对一个模拟信号的电平进行编码。</span></span></span></p> \n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;占空比（</strong>Duty Ratio，Duty Cycle）表示在一个周期内，工作时间与总时间的比值。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方波示例见下图上往下数第二行</p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"32\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fa130dc26dd2c4291a7ae44a3aa82635a.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22295%22%2C%22height%22%3A%22310%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/dcdbb7ec-e593-4bc1-b66f-4adc9e57ffcf.png\" alt=\"\" width=\"295\" height=\"310\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/dcdbb7ec-e593-4bc1-b66f-4adc9e57ffcf.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;其最大的优点是从处理器（<strong>CPS种抽象为控制器</strong>）到被控对象之间的所有信号都是数字形式的，无需再进行<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"31\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"数模转换\" href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E6%2595%25B0%25E6%25A8%25A1%25E8%25BD%25AC%25E6%258D%25A2%22%2C%22text%22%3A%22%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22YWx6mO-1665062133801%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"数模转换\" data-widget=\"csdnlink\" rel=\"noopener\">数模转换</a>过程；而且对噪声的抗干扰能力也大大增强（<strong><span style=\"text-decoration: underline\">噪声只有在强到足以将<strong><span style=\"text-decoration: underline\"><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"30\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"逻辑值\" href=\"https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%80%BC\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E9%80%BB%E8%BE%91%E5%80%BC\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E9%2580%25BB%25E8%25BE%2591%25E5%2580%25BC%22%2C%22text%22%3A%22%E9%80%BB%E8%BE%91%E5%80%BC%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%227p6nG5-1665062133801%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"逻辑值\" data-widget=\"csdnlink\" rel=\"noopener\">逻辑值</a></span></span></strong>改变时，才可能对数字信号产生实质的影响</span></strong>），这也是PWM在通讯等信号传输行业得到大量应用的主要原因。</span></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;模拟信号能否使用PWM进行编码调制，仅依赖<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"29\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"带宽\" href=\"https://zh.wikipedia.org/wiki/%E5%B8%A6%E5%AE%BD\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E5%B8%A6%E5%AE%BD\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E5%25B8%25A6%25E5%25AE%25BD%22%2C%22text%22%3A%22%E5%B8%A6%E5%AE%BD%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22rAhICf-1665062133800%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"带宽\" data-widget=\"csdnlink\" rel=\"noopener\">带宽</a>，这即意味着只要有足够的带宽，任何模拟信号值均可以采用PWM技术进行调制编码。</span></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;在信号接收端，需将信号解调还原为模拟信号。</strong></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目前在很多微型控制器(MCU)内部都包含有PWM控制器模块。</p> \n<p><strong>（4）PWM信号的调制方法</strong></p> \n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; 参考维基百科</strong></p> \n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; </strong>先介绍一下调制出的脉冲波：</p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"28\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F5f4c426a217a459cbff44eff2dc912ef.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22460%22%2C%22height%22%3A%22228%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/07d8a045-f328-4436-8c55-4ad20d6446a2.png\" alt=\"\" width=\"460\" height=\"228\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/07d8a045-f328-4436-8c55-4ad20d6446a2.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;调制出的脉冲波为方波，T为周期，D为一个工作循环，低值ymin，高值ymax，波的平均值计算公式为：</p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"27\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Ff49f053fd91a4a15a7506237e8cac12d.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22263%22%2C%22height%22%3A%2267%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/bca71aeb-33d0-4102-a167-f243a3177d4a.png\" alt=\"\" width=\"263\" height=\"67\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/bca71aeb-33d0-4102-a167-f243a3177d4a.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;算的结果为：</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"26\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/c97ce876-1299-4f20-9009-c2b4b311873a.png\" alt=\"\" width=\"504\" height=\"41\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/c97ce876-1299-4f20-9009-c2b4b311873a.png\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F10654a15629d43beb457ffc342846e97.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22504%22%2C%22height%22%3A%2241%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;很多情况下，ymin为0，所以可以简化为：</p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"25\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F509ad2209b1645a69e124526ca07e80c.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22147%22%2C%22height%22%3A%2251%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/4b7d5b5f-568d-4416-9c48-d42a2fbe870c.png\" alt=\"\" width=\"147\" height=\"51\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/4b7d5b5f-568d-4416-9c48-d42a2fbe870c.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;其实就是个长方形面积计算公式。。。。。。。。。</p> \n<p>有很多<strong>调制方法</strong>，包括（太难描述，具体请看维基百科链接）：</p> \n<ul> \n <li>微分调制</li> \n <li>积分-微分调制</li> \n <li>空间向量调制</li> \n <li>直接转矩控制</li> \n <li>事件比例</li> \n</ul> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 最简单的调制方法：只需要使用锯齿波或<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"24\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"三角波\" href=\"https://zh.wikipedia.org/wiki/%E4%B8%89%E8%A7%92%E6%B3%A2\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E4%B8%89%E8%A7%92%E6%B3%A2\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E4%25B8%2589%25E8%25A7%2592%25E6%25B3%25A2%22%2C%22text%22%3A%22%E4%B8%89%E8%A7%92%E6%B3%A2%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22OckTN7-1665062133799%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"三角波\" data-widget=\"csdnlink\" rel=\"noopener\">三角波</a>(可以简单地使用<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"23\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"震荡器\" href=\"https://zh.wikipedia.org/wiki/%E9%9C%87%E7%9B%AA%E5%99%A8\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.wikipedia.org/wiki/%E9%9C%87%E7%9B%AA%E5%99%A8\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E9%259C%2587%25E7%259B%25AA%25E5%2599%25A8%22%2C%22text%22%3A%22%E9%9C%87%E8%8D%A1%E5%99%A8%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22bTDNVq-1665062133799%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"震荡器\" data-widget=\"csdnlink\" rel=\"noopener\">震荡器</a>来产生)，以及一个比较器。当参考的信号值(图二的红色波)比锯齿波(图二的蓝色波)来的大，则脉冲调制后的结果会在高状态，反之，则在低状态。</span></span></p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"22\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fa8be9cae66d341078f5da5fd27a2e8c9.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22464%22%2C%22height%22%3A%22464%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/d282aecb-32dd-41f7-b55a-2096d8b54fa7.png\" alt=\"\" width=\"464\" height=\"464\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/d282aecb-32dd-41f7-b55a-2096d8b54fa7.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp;</p> \n<hr> \n<h1 id=\"%E4%BA%8C%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E7%A0%94%E7%A9%B6%E6%80%9D%E8%B7%AF\">二 攻击方案研究思路</h1> \n<p><strong>术语：</strong></p> \n<ul> \n <li><strong>intentional electromagnetic interference (IEMI) 故意电磁干扰，</strong>故意电磁干扰 (IEMI) 允许攻击者改变致动信号以干扰或控制致动器。（本文的攻击手法验证方法）</li> \n <li><strong>False Actuation Injection (FAI) 假致动</strong><strong>注入</strong>（本文的攻击手法）</li> \n <li><strong>electromagnetic</strong> （EM）</li> \n <li><strong>unmanned aerial vehicle</strong> (UAV) 无人机</li> \n</ul> \n<h2 id=\"2.1%20%E7%A0%94%E7%A9%B6%E8%83%8C%E6%99%AF\">2.1 研究背景</h2> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"21\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F61e6fe8ad402450d8bcd704863c139ff.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22468%22%2C%22height%22%3A%22279%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/d4980d5f-0d01-4b05-ae43-8cbef1c20425.png\" alt=\"\" width=\"468\" height=\"279\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/d4980d5f-0d01-4b05-ae43-8cbef1c20425.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 无人机的CPS可以简述为上图，从上图中可以看到无人机的CPS系统主要有三个攻击点：攻击者可以利用EM波来阻碍或操纵致动数据，传感器数据或通信信号，分别见上图中的点1、2和3。本文主要针对<strong>FAI攻击</strong>提出方案，也就是上图的点1——<strong>攻击者旨在通过IEMI阻碍或操纵</strong>致动<strong>器。</strong></p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 控制器通常将致动数据 (例如电动机的速度或旋转角度) 编码到的脉冲宽度调制 (PWM) 信号用于控制执行器。因此，PWM信号的完整性非常重要，因为致动数据的任何阻塞或改变都会导致物理部件的失去控制。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，在对固定翼无人机UAV的攻击期间，如果攻击者阻止控制面 (例如，无人机的副翼) 的致动，则受害者UAV可以容易地坠毁。即使使用特定的致动器，攻击者也可以控制控制面 (例如，副翼) 以迫使UAV遵循不安全的轨迹。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本文关注的是攻击者<strong>如何在一定距离内获得这种效果，而又不会破坏传统的数字保护</strong>，例如控制器和执行器之间的加密通信。</p> \n<p>&nbsp;</p> \n<h2 id=\"2.2%20%E7%81%B5%E6%84%9F%E4%B8%8E%E5%8A%A8%E6%9C%BA\">2.2 灵感与动机</h2> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;法拉第感应定律指出，垂直于导体回路的<strong>时变磁场</strong>会在导体的端子处产生感应电压 。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;攻击者可以通过使用特定波形来<strong>影响传送PWM信号的电路</strong>(例如，印刷电路板或电缆上的迹线) 来利用这种现象，从而通过改变表示PWM信号的电压来操纵目标致动器的操作。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;&nbsp;&nbsp;在某些条件下 (例如，当攻击者利用共振攻击受害者时)，感应电压足够大是可以阻止或操纵致动数据。</strong></p> \n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; 现有的IEMI工作都是从传感器、控制器出发，</strong>攻击以获取物理设备的控制权，本文参考的论文则是<strong>第一个使用IEMI干扰并控制执行器的工作</strong>。</p> \n<p>&nbsp;</p> \n<h2 id=\"2.3%20PWM%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E5%99%A8%E7%9A%84%E6%9C%BA%E7%90%86\">2.3 PWM控制执行器的机理</h2> \n<h3 id=\"2.3.1%20PWM%E4%BF%A1%E5%8F%B7%E6%90%BA%E5%B8%A6%E8%87%B4%E5%8A%A8%E6%95%B0%E6%8D%AE\">2.3.1 PWM信号携带致动数据</h3> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PWM信号通过信号中编码的信息 (例如，旋转角度或速度) 来控制致动器。攻击者旨在<span style=\"text-decoration: underline\">阻止成功传输（阻塞攻击）</span>或<span style=\"text-decoration: underline\">更改此信息（篡改与注入攻击）</span>以操纵执行器运动。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>&nbsp;如图2a所示，PWM信号是具有20 ms的固定周期tPWM的矩形波形。持续时间thigh在1ms和2ms之间变化，并携带致动信息，该致动信息是诸如旋转角度或速度之类的致动数据。</strong></p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"20\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fe0b4ba69fc8343609c73ca158bd2a1fb.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22457%22%2C%22height%22%3A%22312%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/7d06a647-e52e-4f32-a5a0-89a3773a4eae.png\" alt=\"\" width=\"457\" height=\"312\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/7d06a647-e52e-4f32-a5a0-89a3773a4eae.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在本节中，<span style=\"text-decoration: underline\">将针对 PWM 携带旋转角度数据的伺服电机应用</span>说明 PWM 操作；然而，相同的机制（即，数据编码到thigh）也被直流电机应用于传递转速 (rpm) 信息。</p> \n<blockquote> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伺服电机（servo motor ）是指在<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"19\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"伺服系统\" href=\"https://baike.baidu.com/item/%E4%BC%BA%E6%9C%8D%E7%B3%BB%E7%BB%9F/2387700?fromModule=lemma_inlink\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://baike.baidu.com/item/%E4%BC%BA%E6%9C%8D%E7%B3%BB%E7%BB%9F/2387700?fromModule=lemma_inlink\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E4%25BC%25BA%25E6%259C%258D%25E7%25B3%25BB%25E7%25BB%259F%2F2387700%3FfromModule%3Dlemma_inlink%22%2C%22text%22%3A%22%E4%BC%BA%E6%9C%8D%E7%B3%BB%E7%BB%9F%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22KlOWND-1665062133798%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"伺服系统\" data-widget=\"csdnlink\" rel=\"noopener\">伺服系统</a>中控制<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"18\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"机械元件\" href=\"https://baike.baidu.com/item/%E6%9C%BA%E6%A2%B0%E5%85%83%E4%BB%B6/5485756?fromModule=lemma_inlink\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://baike.baidu.com/item/%E6%9C%BA%E6%A2%B0%E5%85%83%E4%BB%B6/5485756?fromModule=lemma_inlink\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E6%259C%25BA%25E6%25A2%25B0%25E5%2585%2583%25E4%25BB%25B6%2F5485756%3FfromModule%3Dlemma_inlink%22%2C%22text%22%3A%22%E6%9C%BA%E6%A2%B0%E5%85%83%E4%BB%B6%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22bPMQFP-1665062133797%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"机械元件\" data-widget=\"csdnlink\" rel=\"noopener\">机械元件</a>运转的发动机，是一种补助马达间接变速装置。</span></span></p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伺服电机可以控制速度，位置精度非常准确，可以将电压信号转化为<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"17\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"转矩\" href=\"https://baike.baidu.com/item/%E8%BD%AC%E7%9F%A9/6531115?fromModule=lemma_inlink\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://baike.baidu.com/item/%E8%BD%AC%E7%9F%A9/6531115?fromModule=lemma_inlink\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E8%25BD%25AC%25E7%259F%25A9%2F6531115%3FfromModule%3Dlemma_inlink%22%2C%22text%22%3A%22%E8%BD%AC%E7%9F%A9%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22qOVT8k-1665062133797%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"转矩\" data-widget=\"csdnlink\" rel=\"noopener\">转矩</a>和转速以驱动控制对象。</span></p> \n <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;伺服电机转子转速受输入信号控制，并能快速反应，在自动控制系统中，用作执行元件，且具有机电时间常数小、线性度高等特性，可把所收到的电信号转换成电动机轴上的角位移或角速度输出。分为直流和<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"16\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"交流伺服电动机\" href=\"https://baike.baidu.com/item/%E4%BA%A4%E6%B5%81%E4%BC%BA%E6%9C%8D%E7%94%B5%E5%8A%A8%E6%9C%BA/1433887?fromModule=lemma_inlink\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://baike.baidu.com/item/%E4%BA%A4%E6%B5%81%E4%BC%BA%E6%9C%8D%E7%94%B5%E5%8A%A8%E6%9C%BA/1433887?fromModule=lemma_inlink\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fbaike.baidu.com%2Fitem%2F%25E4%25BA%25A4%25E6%25B5%2581%25E4%25BC%25BA%25E6%259C%258D%25E7%2594%25B5%25E5%258A%25A8%25E6%259C%25BA%2F1433887%3FfromModule%3Dlemma_inlink%22%2C%22text%22%3A%22%E4%BA%A4%E6%B5%81%E4%BC%BA%E6%9C%8D%E7%94%B5%E5%8A%A8%E6%9C%BA%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22zSomIg-1665062133797%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"交流伺服电动机\" data-widget=\"csdnlink\" rel=\"noopener\">交流伺服电动机</a>两大类，其主要特点是，当信号电压为零时无自转现象，转速随着转矩的增加而匀速下降。</span></p> \n</blockquote> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 通用伺服电机的总体旋转角度为90 °（<strong>注：不难理解一个主机翼顺时针转90°和逆时针转90°基本上能够覆盖所有操作角度</strong>），并随着thigh的增加沿顺时针方向旋转。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;例如，thigh&nbsp;= 1ms、1.5ms和2ms分别对应于旋转角度-45 ° 、0 ° 和45 °，如下图的2b、2c和2d所示。</p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"15\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/f5a3bc83-72e2-4db2-8ff5-7fd8e182ba85.png\" alt=\"\" width=\"1200\" height=\"466\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/f5a3bc83-72e2-4db2-8ff5-7fd8e182ba85.png\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F342f4303ae6a49d9af70a3cbc3fd0c66.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221200%22%2C%22height%22%3A%22466%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<h3 id=\"%C2%A0%20%C2%A02.3.2%20%E8%87%B4%E5%8A%A8%E5%99%A8%E4%BD%BF%E7%94%A8PWM%E7%9A%84%E4%B8%8A%E5%8D%87%E6%B2%BF%E5%92%8C%E4%B8%8B%E9%99%8D%E6%B2%BF%E4%B9%8B%E9%97%B4%E7%9A%84%E6%8C%81%E7%BB%AD%E6%97%B6%E9%97%B4%E7%A1%AE%E5%AE%9A%E8%87%B4%E5%8A%A8%E6%95%B0%E6%8D%AE\">&nbsp; &nbsp;2.3.2 致动器使用PWM的上升沿和下降沿之间的持续时间确定致动数据</h3> \n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;致动器有两种选择来处理PWM编码的信号对应的致动数据：</strong></p> \n<ul> \n <li>首先，通过检查PWM脉冲的上升沿和下降沿;</li> \n <li>其次，可能用低通滤波器取PWM的平均值。</li> \n</ul> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实验观察到，致动器对施加到PWM输入的低幅度DC信号不响应，<strong>这表明用于确定致动数据的是PWM的上升沿和下降沿之间的持续时间。</strong></p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 问题来了，什么是上升沿和下降沿？数字电平从0变为1 的那一瞬间叫作上升沿 ，从1到0的那一瞬间叫作下降沿。</p> \n<p>&nbsp; &nbsp;</p> \n<h2 id=\"2.4%20%E6%94%BB%E5%87%BB%E5%9C%BA%E6%99%AF%E8%AE%BE%E5%AE%9A\">2.4 攻击场景设定</h2> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FAI 攻击低功耗且无法追踪，并且只通过 EM 耦合攻击来改变受害者的 PWM 信号。最大攻击功率限制为 20W，可通过 COTS 放大器获得。</p> \n<p><strong>场景一&nbsp;</strong></p> \n<p>第一种攻击场景中要求功率较低，攻击者旨在阻止驱动数据以使受害者的驱动控制无效，但不注入错误命令。</p> \n<p><strong>场景二</strong></p> \n<p>在第二种攻击场景中，攻击者需要注入虚假驱动数据来控制受害者的驱动器。</p> \n<p>攻击者可以访问放大器和天线等射频组件，以及有关受害系统拓扑的信息，例如 PWM 电缆长度。</p> \n<hr> \n<h1 id=\"%E4%B8%89%20%E6%94%BB%E5%87%BB%E6%96%B9%E6%A1%88%E3%80%81%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E9%AA%8C%E8%AE%BE%E5%A4%87\">三 攻击方案、原理与实验设备</h1> \n<h2 id=\"3.1%20%C2%A0%E6%B5%8B%E8%AF%95%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%E5%AF%B9%E9%80%9A%E4%BF%A1%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%BD%B1%E5%93%8D\">3.1 &nbsp;测试攻击波形对通信信号的影响</h2> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"14\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F739cf027b3c4477d8759c895b6b52ce8.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22454%22%2C%22height%22%3A%22292%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/0ceb7f9c-3afc-466a-be93-70d22acb7d46.png\" alt=\"\" width=\"454\" height=\"292\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/0ceb7f9c-3afc-466a-be93-70d22acb7d46.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>蓝色虚线框是受害者系统，也就是无人机系统，红色虚线框是攻击者。</p> \n<p><strong>首先看受害者这边有什么：从左往右看</strong></p> \n<p>Futaba是带有地面无线电控制器的无人机系统，该控制器将操作人员的控制命令发送给无人机；&nbsp;</p> \n<p>无人机中的自动驾驶仪Pixhawk，将控制器发来的控制信息转为PWM信号，并发送给伺服电机；</p> \n<p>再就是Servo Motor，就是接受PWM信号的伺服电机，最底下那个实线蓝色框就是无人机的电机们。</p> \n<p><strong>再看看攻击者这边有什么：从右往左看</strong></p> \n<p>先是包络发生器，什么是包咯发生器呢？</p> \n<blockquote> \n <p>&nbsp;Envelope generators provide a means for shaping the waveforms to produce a more musical character. Most commonly, envelope generators are used to modulate amplitude over a period of time. They come in a variety of configurations, but the most prevalent type of envelope generator is an ADSR envelope.</p> \n <p>包络发生器提供了一种塑造波形的方法，以产生更具音乐性的特征。最常见的是，包络发生器用于在一段时间内调制振幅。它们有多种配置，但最流行的包络生成器类型是ADSR包络。</p> \n</blockquote> \n<p>好好好，说白了就是一种塑造波的仪器，产生攻击波形。</p> \n<p>然后送到真正的波形生成器，生成波。</p> \n<p>在所有攻击场景中，攻击波形载波都由Rohde&amp;Schwarz SMU 200矢量信号发生器生成。</p> \n<p>在其他两种攻击中，Keysight 33600A波形发生器将会被添加到包络生成模块中。</p> \n<p><strong>再看看两个圈外的东西</strong></p> \n<p>BUFFER，电压缓冲器，用于消除可能使 PWM 波形失真的负载。</p> \n<p><strong>Combiner，因为这是个有线实验，而不是直接无限实验，所以这里要这么看：</strong></p> \n<p><strong>1、做这个有线系统的实验是为了找到能够产生有效攻击的攻击波形和其他参数</strong></p> \n<p><strong>2、要做的是对执行器的攻击，所以需要从控制器到执行器的流程中，找到攻击点，因此，这里的combiner其实就是攻击点，在Pixhawk和伺服电机的通信流程之间。</strong></p> \n<p><strong>3、combiner要做的就是将产生的攻击波与正常操作下自动驾驶仪发送的含有控制指令的PWM波相互作用下的结果</strong></p> \n<h3 id=\"3.1.1%20%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%E2%85%A0%EF%BC%9ABLOCK\">3.1.1 攻击波形Ⅰ：BLOCK</h3> \n<p><strong>实验步骤：</strong></p> \n<ol> \n <li>通过地面无线电控制器建立伺服控制。</li> \n <li>注入块波形从 -30 dBm 开始，增量为 1 dBm</li> \n <li>检测成功攻击的最小 Vp（即地面控制器无法控制伺服旋转）。</li> \n</ol> \n<p><strong>攻击原理：</strong></p> \n<p><strong>（1）攻击手段</strong></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块攻击的攻击波是一个频率为fa的连续波信号，如下图的黑色连续波，然后电缆里面传输的是蓝色框框的PWM波，这连续波能够和PWM耦合，经过包络检波器产生感应电压，阻止伺服电机服务，从而干扰无人机的飞行。</p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"13\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fbeafd43f88f64d11a6476f46635f4337.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22364%22%2C%22height%22%3A%22250%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/bc605347-5351-4fd5-b5f5-d89b1f0af67d.png\" alt=\"\" width=\"364\" height=\"250\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/bc605347-5351-4fd5-b5f5-d89b1f0af67d.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p><strong>（2）攻击机理</strong></p> \n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>这个信号能够在受害者的PWM电路中感应出一个电压，从而阻止伺服系统检测到上升沿和下降沿。</p> \n<p><strong>问：为什么能够在PWM电路中感应出一个电压？为什么感应出电压就能阻止伺服系统？攻击波和PWM波之间是如何作用的？</strong></p> \n<div class=\"cke_widget_wrapper cke_widget_block cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"12\" data-cke-widget-wrapper=\"1\"> \n <p class=\"img-center cke_widget_element\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F3af4840ef326487aa4f21d727c1e11ae.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22505%22%2C%22height%22%3A%22223%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22center%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_image_resizer_wrapper\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/4e81ab49-b1c1-4d05-af39-9d80f25e1a10.png\" alt=\"\" width=\"505\" height=\"223\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/4e81ab49-b1c1-4d05-af39-9d80f25e1a10.png\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​</span></span></p> \n <span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span>\n</div> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第一个问题为什么能感应出电压，依据是法律第感应定律，即直于导体回路的时变磁场会在导体的端子处产生感应电压，通过传入的电磁波耦合产生电压。&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如图，从左至右，分别为耦合攻击波形、保护二极管、修正后的波形和低通滤波器、PWM输入到电机处。</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 文章说到，保护二极管和低通滤波器中的电容Cv和Rv能够在原理上等价为“envelope detector”，又名包络检波器。</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这玩意是用来干什么的呢？<strong>包络检波器</strong>（英语：<strong>envelope detector</strong>）是以高频信号为输入信号并提供原始信号的<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"11\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"包络\" href=\"https://zh.m.wikipedia.org/w/index.php?title=%E5%8C%85%E7%BB%9C%E5%87%BD%E6%95%B0&amp;action=edit&amp;redlink=1\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.m.wikipedia.org/w/index.php?title=%E5%8C%85%E7%BB%9C%E5%87%BD%E6%95%B0&amp;action=edit&amp;redlink=1\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.m.wikipedia.org%2Fw%2Findex.php%3Ftitle%3D%25E5%258C%2585%25E7%25BB%259C%25E5%2587%25BD%25E6%2595%25B0%26action%3Dedit%26redlink%3D1%22%2C%22text%22%3A%22%E5%8C%85%E7%BB%9C%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22RxtmQE-1665062133795%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"包络\" data-widget=\"csdnlink\" rel=\"noopener\">包络</a>（英语：<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"10\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"Envelope (waves)\" href=\"https://en.wikipedia.org/wiki/Envelope_(waves)\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://en.wikipedia.org/wiki/Envelope_(waves)\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FEnvelope_(waves)%22%2C%22text%22%3A%22Envelope%20(waves)%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22uwE4YF-1665062133794%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"Envelope (waves)\" data-widget=\"csdnlink\" rel=\"noopener\">Envelope (waves)</a>）的一种电子线路。电路中的<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"9\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"电容器\" href=\"https://zh.m.wikipedia.org/wiki/%E7%94%B5%E5%AE%B9%E5%99%A8\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.m.wikipedia.org/wiki/%E7%94%B5%E5%AE%B9%E5%99%A8\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.m.wikipedia.org%2Fwiki%2F%25E7%2594%25B5%25E5%25AE%25B9%25E5%2599%25A8%22%2C%22text%22%3A%22%E7%94%B5%E5%AE%B9%E5%99%A8%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22jS5gml-1665062133782%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"电容器\" data-widget=\"csdnlink\" rel=\"noopener\">电容器</a>会在上升沿充电，并在信号下降时通过<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"8\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"电阻器\" href=\"https://zh.m.wikipedia.org/wiki/%E9%9B%BB%E9%98%BB%E5%99%A8\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.m.wikipedia.org/wiki/%E9%9B%BB%E9%98%BB%E5%99%A8\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.m.wikipedia.org%2Fwiki%2F%25E9%259B%25BB%25E9%2598%25BB%25E5%2599%25A8%22%2C%22text%22%3A%22%E7%94%B5%E9%98%BB%E5%99%A8%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22NkbQiN-1665062133782%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"电阻器\" data-widget=\"csdnlink\" rel=\"noopener\">电阻器</a>缓慢释放电荷。串联的二极管将输入信号<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_csdnlink cke_widget_selected\" data-cke-display-name=\"a\" data-cke-filter=\"off\" data-cke-widget-id=\"7\" data-cke-widget-wrapper=\"1\"><a class=\"cke_widget_editable cke_widget_element\" title=\"整流\" href=\"https://zh.m.wikipedia.org/wiki/%E6%95%B4%E6%B5%81%E5%99%A8\" data-cke-enter-mode=\"2\" data-cke-saved-href=\"https://zh.m.wikipedia.org/wiki/%E6%95%B4%E6%B5%81%E5%99%A8\" data-cke-widget-data=\"%7B%22url%22%3A%22https%3A%2F%2Fzh.m.wikipedia.org%2Fwiki%2F%25E6%2595%25B4%25E6%25B5%2581%25E5%2599%25A8%22%2C%22text%22%3A%22%E6%95%B4%E6%B5%81%22%2C%22desc%22%3A%22%22%2C%22icon%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22isCard%22%3Afalse%2C%22hasResquest%22%3Atrue%2C%22iconDefault%22%3A%22https%3A%2F%2Fcsdnimg.cn%2Frelease%2Fblog_editor_html%2Frelease2.2.0%2Fckeditor%2Fplugins%2FCsdnLink%2Ficons%2Ficon-default.png%3Ft%3DM85B%22%2C%22id%22%3A%22MVg4rM-1665062133781%22%2C%22classes%22%3Anull%7D\" data-cke-widget-editable=\"text\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-link-icon=\"https://csdnimg.cn/release/blog_editor_html/release2.2.0/ckeditor/plugins/CsdnLink/icons/icon-default.png?t=M85B\" data-link-title=\"整流\" data-widget=\"csdnlink\" rel=\"noopener\">整流</a>，只在正输入端比负输入端电位高的时候允许电流流过。</span></span></span></span></span></p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 那么就好解释了：</p> \n<blockquote> \n <p>1、通过PWM电缆耦合的攻击波形由二极管整流，仅留下正周期（水平坐标轴上的波）。</p> \n <p>2、在第一个整流周期中，电容器被充电到电压峰值。</p> \n <p>3、 然而，由于攻击波形的高频/低周期性质和并联r-c电路的相对较高的时间常数，电容器不能在周期之间放电 。</p> \n <p>4、此外，包括二极管和Rv，Cv在内的整个电路只不过是一个包络检测器，在早期的无线电中广泛用作AM解调器 。</p> \n <p>5、攻击成功的很大原因是二极管的整流，因为整流引入了攻击者的低频成分，即envelope。</p> \n <p>6、实验观察到Futaba和HiTec伺服控制器板由二极管保护组成，这是成功控制这些伺服系统的原因。 &nbsp; &nbsp; &nbsp; &nbsp;</p> \n</blockquote> \n<p>&nbsp;</p> \n<p><strong>（3）攻击效率</strong></p> \n<p><strong>&nbsp; &nbsp; &nbsp; &nbsp; </strong>攻击的效率取决于频率（fa）和与受害者共振频率（fv）。攻击者可以使用受害者的共振频率来增加攻击距离。下一大节讨论检测受害共振的分析和实验方法。</p> \n<p><strong>（4）实验结果</strong></p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"6\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/6958e31d-4505-4153-bc5d-0fee92bfd2d3.png\" alt=\"\" width=\"820\" height=\"238\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/6958e31d-4505-4153-bc5d-0fee92bfd2d3.png\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fe9d3b151e9ef40268c7de079100b7875.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22820%22%2C%22height%22%3A%22238%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑&nbsp; &nbsp; &nbsp; 第二行第一列对应的是上一张实验图中伺服电机的各组成电机，可以观察到，所有伺服模型都可以用不同的攻击功率（VP）来阻塞。</span></span></span></span></p> \n<h3 id=\"3.1.2%20%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%C2%A0%E2%85%A0%E2%85%A0%20%EF%BC%9ABLOCK%20%26%20ROTATE\">3.1.2 攻击波形&nbsp;ⅠⅠ ：BLOCK &amp; ROTATE</h3> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 上节的块波的作用简单说就是阻止旋转角数据向致动器传输，那么这一节需要做到，注入错误的致动数据。</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 具体思想可以简述为：利用一种波形掩盖或消除原有的旋转数据，然后注入构造好的错误致动数据，掩盖方式可以为宽脉冲（thigh&gt;2ms）</p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"5\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/6011abfc-0f2c-4273-bb81-146a2b69e766.jpeg\" alt=\"\" width=\"1200\" height=\"360\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/6011abfc-0f2c-4273-bb81-146a2b69e766.jpeg\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F9c9b4f515bbf4e01aa2d9622a2a5bd08.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221200%22%2C%22height%22%3A%22360%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>让无人机机翼停转：</p> \n<p>（1）上图可以看到，正常旋转的范围是1～2ms，作者实验观察到，当thigh&gt;2ms时，PWM所携带的信号全被覆盖，所有的伺服模型电机都保持原形。</p> \n<p>（2）当Eflite和Hitec伺服器锁定时 (即，外部扭矩不能移动它)，观察到双叶伺服器自由移动。</p> \n<p>（3）当PWM通道中没有旋转角数据时，Eflite和Hitec的响应可能是保持伺服旋转稳定。</p> \n<p>注入错误的旋转指令信号：</p> \n<p>（1）使用额外的正弦脉冲来注入错误的旋转角度信息 (图4b中的 “旋转” 脉冲)。</p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"4\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/f72282ec-37fa-4eb4-a319-1c3fa4b0a4be.jpeg\" alt=\"\" width=\"584\" height=\"371\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/f72282ec-37fa-4eb4-a319-1c3fa4b0a4be.jpeg\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F2ec4554715824c00908094bb8b11f0bd.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22584%22%2C%22height%22%3A%22371%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>&nbsp;</p> \n<p>（2）旋转脉冲的持续时间(trotate的宽度)决定了注入受害者系统的错误旋转角度。例如，攻击者可以使用trotate = 1ms的Block &amp; Rotate波形 (图4b) 将伺服机构旋转到-45 °。</p> \n<p><strong>批注：很多这种信号注入攻击，注入指令的前一步都是阻塞原有的服务，然后将自己构造的命令注入到这个信道以劫持通信。</strong></p> \n<p>&nbsp;</p> \n<h3 id=\"3.1.3%C2%A0%E6%94%BB%E5%87%BB%E6%B3%A2%E5%BD%A2%20III%EF%BC%9A%E5%AE%8C%E5%85%A8%E6%8E%A7%E5%88%B6\">3.1.3&nbsp;攻击波形 III：完全控制</h3> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"3\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/cb2287bb-fb72-4471-8653-2843443de1ff.jpeg\" alt=\"\" width=\"573\" height=\"368\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/cb2287bb-fb72-4471-8653-2843443de1ff.jpeg\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fc477c914197f45c3a032396a2defe03f.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22573%22%2C%22height%22%3A%22368%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个无人机可以操作（即左右旋转45度）的时间范围trotate，从下图可以得知为[1ms,2ms]：</p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"2\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/6011abfc-0f2c-4273-bb81-146a2b69e766.jpeg\" alt=\"\" width=\"1200\" height=\"360\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/6011abfc-0f2c-4273-bb81-146a2b69e766.jpeg\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F9c9b4f515bbf4e01aa2d9622a2a5bd08.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221200%22%2C%22height%22%3A%22360%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>tPWM为20ms，那么这个占空比就是[1/20,2/20]也就是5%到10%。<strong>攻击1和攻击2都是在固定的占空比范围内进行操作，那么超过这个占空比呢？</strong></p> \n<p><strong>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</strong>因为thigh的范围和trotate相关，要做一些电机操作，所以是固定的[1,2]，所以只能通过变小tPWM来增大占空比。</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 实验观察到，当这个tPWM变小到2.5ms的时候，也就是占空比范围到[40%,80%]的时候，在这个范围内，无人机内的每个伺服服务组件都可以通过增加PWM的占空比来控制：</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 例如，注入thigh=1ms，就能控制无人机往左转。&nbsp;</p> \n<h3 id=\"%C2%A03.1.4%20%E5%90%84%E6%B3%A2%E5%BD%A2%E5%AF%B9%E6%AF%94\">&nbsp;3.1.4 各波形对比</h3> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 拿三种攻击波形对比一下：</p> \n<p><span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"1\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/9afd4b2a-b2fa-4781-89f5-79f93af30e46.jpeg\" alt=\"\" width=\"694\" height=\"143\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/9afd4b2a-b2fa-4781-89f5-79f93af30e46.jpeg\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2F098d03d7f6e847cfb0d5c92aec95a062.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%22694%22%2C%22height%22%3A%22143%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;黑色的连续波是攻击波形，然后我这上上节也说到了，这个黑色连续波会和蓝色PWM波耦合形成新的波，（<strong>注意：这两个蓝色的PWM波的间距就是tPWM，为20ms</strong>）然后这个新的波能对伺服电机产生对应的效果，然后本质是切割磁感线产生感应电压。</p> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; a是持续不间断的连续波，b和c都是间断的波形，b的间断目的是先覆盖后注入（在tPWM时间内）。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;块波形可防止在每个测试频率下传输致动数据传输，并且观察到在所有测试的伺服模型上都是有效的。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block &amp; Rotate 和 Full Control使攻击者能够通过将旋转角数据注入PWM通道来完全控制特定的伺服模型。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Block &amp; Rotate适用于经过测试的双叶和HiTec伺服器型号。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全控制波形利用了原始PWM的低占空比特性，并且非常频繁地注入错误的致动数据以在不需要同步的情况下控制受害致动器。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;完全控制适用于所有双叶模型，并为攻击者提供伺服旋转的 “完全控制”，即顺时针和逆时针旋转。</p> \n<p>&nbsp;</p> \n<h2 id=\"3.2%20%E5%AE%9E%E4%BE%8B%E6%94%BB%E5%87%BB\">3.2 实例攻击</h2> \n<p>&nbsp; &nbsp; &nbsp; &nbsp; 这实验做出来能干什么就不用说了吧，最显而易见的，敌方无人机来了可以直接给他控制辽。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;他们要做个什么事捏？&nbsp;因为这个干扰和注入的距离是有限的，远距离电波容易被反射、吸收、屏蔽，近距离的电波穿透力更强，所以要架设在己方无人机上，飞到敌方无人机附近去干扰和控制。<span class=\"cke_widget_wrapper cke_widget_inline cke_widget_image cke_image_nocaption cke_widget_selected\" data-cke-display-name=\"图像\" data-cke-filter=\"off\" data-cke-widget-id=\"0\" data-cke-widget-wrapper=\"1\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/0999a375-a070-4e23-967e-c296891416b2.jpeg\" alt=\"\" width=\"1200\" height=\"551\" class=\"cke_widget_element\" data-cke-saved-src=\"http://localhost:8080/static/blogImages/2022/10/06/0999a375-a070-4e23-967e-c296891416b2.jpeg\" data-cke-widget-data=\"%7B%22hasCaption%22%3Afalse%2C%22src%22%3A%22https%3A%2F%2Fimg-blog.csdnimg.cn%2Fe0799249244d482f886a848e538af67b.png%22%2C%22alt%22%3A%22%22%2C%22width%22%3A%221200%22%2C%22height%22%3A%22551%22%2C%22lock%22%3Atrue%2C%22align%22%3A%22none%22%2C%22classes%22%3Anull%7D\" data-cke-widget-keep-attr=\"0\" data-cke-widget-upcasted=\"1\" data-widget=\"image\"><span class=\"cke_reset cke_widget_drag_handler_container\"><img src=\"https://img2022.cnblogs.com/blog/1481865/202210/1481865-20221006212631862-1374003700.gif\" width=\"15\" height=\"15\" class=\"cke_reset cke_widget_drag_handler\" title=\"点击并拖拽以移动\" data-cke-widget-drag-handler=\"1\"><span class=\"cke_image_resizer\" title=\"点击并拖拽以改变尺寸\">​<span class=\"cke_widget_edit_container\" title=\"编辑图片\">编辑</span></span></span></span></p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;攻击者系统由光发射器和接收器、电池、射频模块、放大器和ZPSL天线组成，如图9b所示。受害者Pixhawk被编程为根据地面控制器的要求发起攻击。攻击控制信号作为光信号发送，以确保即使在高EMI下也能进行可靠的控制，例如在紧急情况下停止攻击。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RF开关对连续波信号进行调制，以生成块或完全控制波形。来自RF开关的攻击波形以20W的输出功率馈送到RF放大器，并且攻击波形从ZPSL天线辐射，该天线以攻击频率谐振并匹配到50Ω。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;受害无人机使用在PX4固件上运行的Pixhawk自动驾驶仪，该自动驾驶仪经过修改以控制来自地面/无线电控制器的IEMI攻击的持续时间和波形。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了可靠地测量高EMI中的副翼旋转，将正交编码器连接到右副翼伺服器，并在UAV的右翼上安装了隔离的Pixhawk (即，具有单独的DC电源)。作者为PX4固件开发了固件模块，该固件模块充当正交编码器的接口并记录副翼旋转角度。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;对于飞行，使用Pixhawk的稳定飞行模式，在此期间，俯仰和滚动设定点由飞行员从无线电/地面控制器提供。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然后，自动驾驶仪分别计算所需的升降舵和副翼旋转，以达到设定值。方向舵旋转和推力直接来自无线电/地面控制器。</p> \n<hr> \n<h1 id=\"%E5%9B%9B%20%E8%AF%95%E9%AA%8C%E7%BB%93%E6%9E%9C\">四 试验结果</h1> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20w的功率足以进行25厘米完全控制和50厘米块攻击。</p> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一些观察结果如下:</p> \n<ol> \n <li>无论天线大小如何，完全控制都需要比块攻击更多的功率。</li> \n <li>大型天线比较小的天线所需的功率要少得多。</li> \n <li>对于在da = 1m处的完全控制，对于大型和小型天线，所需功率分别为611W和3.3kW。但是，如果块的攻击距离为2m，则对于大型和小型天线，所需功率分别为532W和1.38kW。</li> \n <li>大型天线在近场中产生高磁场的能力是一种已知现象。对于经颅磁刺激 (TMS) 应用，其中磁场刺激大脑的特定区域，较大的环是优选的，以更好地 “穿透” 到大脑内层 。</li> \n</ol> \n<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;为了增加攻击距离，增加天线空间，超材料-人造磁导体，其功能为磁反射器，可以用来提高场功率3dB，降低攻击能力，保护追踪器从自己的攻击场。</p> \n<span data-cke-copybin-start=\"1\"><span data-cke-copybin-end=\"1\">​</span></span>',100,NULL,0,'https://www.cnblogs.com/welkinchan/p/16758558.html','2022-10-06 23:55:59'),(7,'分布式存储系统之Ceph集群存储池操作',NULL,NULL,0,0,'<p>　　前文我们了解了ceph的存储池、PG、CRUSH、客户端IO的简要工作过程、Ceph客户端计算PG_ID的步骤的相关话题，回顾请参考<a href=\"https://www.cnblogs.com/qiuhom-1874/p/16733806.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/qiuhom-1874/p/16733806.html</a>；今天我们来聊一聊在ceph上操作存储池相关命令的用法和说明；</p> \n<p>　　在ceph上操作存储池不外乎就是查看列出、创建、重命名和删除等操作，常用相关的工具都是“ceph osd pool”的子命令，ls、create、rename和rm等；</p> \n<p>　　1、创建存储池</p> \n<p>　　副本型存储池创建命令格式</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\"> ceph osd pool create &lt;pool-name&gt; &lt;pg-num&gt; [pgp-num] [replicated] [crush-rule-name] [expected-num-objects]\n</pre> \n</div> \n<p>　　提示：创建副本型存储池上面的必要选项有存储池的名称和PG的数量，后面可以不用跟pgp和replicated来指定存储池的pgp的数量和类型为副本型；即默认创建不指定存储池类型，都是创建的是副本池；</p> \n<p>　　纠删码池存储池创建命令格式</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\"> ceph osd pool create &lt;pool-name&gt; &lt;pg-num&gt; &lt;pgp-num&gt; erasure [erasure-code-profile] [crush-rule-name] [expected-num-objects]\n</pre> \n</div> \n<p>　　提示：创建纠删码池存储池，需要给定存储池名称、PG的数量、PGP的数量已经明确指定存储池类型为erasure；这里解释下PGP，所谓PGP（Placement Group for Placement purpose）就是用于归置的PG数量，其值应该等于PG的数量；&nbsp;crush-ruleset-name是用于指定此存储池所用的CRUSH规则集的名称，不过，引用的规则集必须事先存在；</p> \n<p>　　erasure-code-profile参数是用于指定纠删码池配置文件；未指定要使用的纠删编码配置文件时，创建命令会为其自动创建一个，并在创建相关的CRUSH规则集时使用到它；默认配置文件自动定义k=2和m=1，这意味着Ceph将通过三个OSD扩展对象数据，并且可以丢失其中一个OSD而不会丢失数据，因此，在冗余效果上，它相当于一个大小为2的副本池 ，不过，其存储空间有效利用率为2/3而非1/2。</p> \n<p>　　示例：创建一个副本池</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/2a4837aa-b877-42b3-ad3b-e7e5d7b0905e.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　示例：创建一个纠删码池</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/b412a7c9-9e3a-4e65-b545-d1de913d73ab.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　2、获取存储池的相关信息</p> \n<p>　　列出存储池：ceph osd pool ls&nbsp;[detail]</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ ceph osd pool ls \ntestpool\nrbdpool\n.rgw.root\ndefault.rgw.control\ndefault.rgw.meta\ndefault.rgw.log\ncephfs-metadatpool\ncephfs-datapool\nreppool\nerasurepool\n[cephadm@ceph-admin ~]$ ceph osd pool ls detail \npool 1 \'testpool\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 16 pgp_num 16 last_change 42 flags hashpspool stripe_width 0\npool 2 \'rbdpool\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 81 flags hashpspool,selfmanaged_snaps stripe_width 0 application rbd\n        removed_snaps [1~3]\npool 3 \'.rgw.root\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 84 owner 18446744073709551615 flags hashpspool stripe_width 0 application rgw\npool 4 \'default.rgw.control\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 87 owner 18446744073709551615 flags hashpspool stripe_width 0 application rgw\npool 5 \'default.rgw.meta\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 89 owner 18446744073709551615 flags hashpspool stripe_width 0 application rgw\npool 6 \'default.rgw.log\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 8 pgp_num 8 last_change 91 owner 18446744073709551615 flags hashpspool stripe_width 0 application rgw\npool 7 \'cephfs-metadatpool\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 64 pgp_num 64 last_change 99 flags hashpspool stripe_width 0 application cephfs\npool 8 \'cephfs-datapool\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 128 pgp_num 128 last_change 99 flags hashpspool stripe_width 0 application cephfs\npool 9 \'reppool\' replicated size 3 min_size 2 crush_rule 0 object_hash rjenkins pg_num 32 pgp_num 32 last_change 126 flags hashpspool stripe_width 0\npool 10 \'erasurepool\' erasure size 3 min_size 2 crush_rule 1 object_hash rjenkins pg_num 32 pgp_num 32 last_change 130 flags hashpspool stripe_width 8192\n\n[cephadm@ceph-admin ~]$ \n</pre> \n</div> \n<p>　　提示：后面接detail表示列出存储池的详细信息；</p> \n<p>　　获取存储池的统计数据：ceph osd pool stats [pool-name]</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ ceph osd pool stats reppool\npool reppool id 9\n  nothing is going on\n\n[cephadm@ceph-admin ~]$ ceph osd pool stats \npool testpool id 1\n  nothing is going on\n\npool rbdpool id 2\n  nothing is going on\n\npool .rgw.root id 3\n  nothing is going on\n\npool default.rgw.control id 4\n  nothing is going on\n\npool default.rgw.meta id 5\n  nothing is going on\n\npool default.rgw.log id 6\n  nothing is going on\n\npool cephfs-metadatpool id 7\n  nothing is going on\n\npool cephfs-datapool id 8\n  nothing is going on\n\npool reppool id 9\n  nothing is going on\n\npool erasurepool id 10\n  nothing is going on\n\n[cephadm@ceph-admin ~]$ \n</pre> \n</div> \n<p>　　提示：不指定存储池名称表示查看所有存储池的统计数据；</p> \n<p>　　显示存储池的用量信息：rados df 或者ceph df</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ rados df\nPOOL_NAME              USED OBJECTS CLONES COPIES MISSING_ON_PRIMARY UNFOUND DEGRADED RD_OPS     RD WR_OPS     WR \n.rgw.root           1.1 KiB       4      0     12                  0       0        0     27 18 KiB      4  4 KiB \ncephfs-datapool         0 B       0      0      0                  0       0        0      0    0 B      0    0 B \ncephfs-metadatpool  2.2 KiB      22      0     66                  0       0        0     49 51 KiB     46 13 KiB \ndefault.rgw.control     0 B       8      0     24                  0       0        0      0    0 B      0    0 B \ndefault.rgw.log         0 B     175      0    525                  0       0        0  16733 16 MiB  11158    0 B \ndefault.rgw.meta        0 B       0      0      0                  0       0        0      0    0 B      0    0 B \nerasurepool             0 B       0      0      0                  0       0        0      0    0 B      0    0 B \nrbdpool               389 B       5      0     15                  0       0        0     50 32 KiB     19 10 KiB \nreppool                 0 B       0      0      0                  0       0        0      0    0 B      0    0 B \ntestpool                0 B       0      0      0                  0       0        0      2  2 KiB      2  1 KiB \n\ntotal_objects    214\ntotal_used       10 GiB\ntotal_avail      890 GiB\ntotal_space      900 GiB\n[cephadm@ceph-admin ~]$ </pre> \n</div> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/475c8ac1-c161-45c2-9acc-b60c057171dc.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　提示：rados df和ceph df显示稍微有点差别，rados 信息比较全面但偏底层；ceph df人类比较容易看懂；</p> \n<p>　　3、存储池重命名</p> \n<p>　　命令格式：ceph osd pool rename old-name new-name</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/f739f654-4ccc-4259-b394-27add6d0cea9.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　4、删除存储池</p> \n<p>　　我们知道删除存储池意味着数据的丢失；所以ceph为了防止我们意外删除存储池实施了两个机制；我们要删除存储池，必须先禁用这两个机制；</p> \n<p>　　第一个机制是NODELETE标志，其值需要为false，默认也是false；即允许我们删除；第二个机制是集群范围的配置参数mon allow pool delete，其默认值为“false”，这表示默认不能删除存储池；即我们要删除存储池，需要将第二个机制mon allow pool delete 的值修改为true即可删除存储池；</p> \n<p>　　查看nodelete的值命令格式：ceph osd pool get pool-name nodelete</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/65f8b787-b6bb-474b-919c-222caf106e87.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　修改命令nodelete的值命令格式：ceph osd pool set pool-name nodelete false|true</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/67b32175-0e86-4312-b4b6-ea06655d84cc.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　提示：我们要删存储池，需要将nodelete的值设置为false，即不允许删除为假，即表示允许删除；</p> \n<p>　　修改mon allow pool delete的值命令格式：ceph tell mon.* injectargs --mon-allow-pool-delete={true|false}</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/6f535629-7ea4-49c6-9869-51d86c66eac7.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　提示：删除之前将其值设置为true，删除完成后再改为false；</p> \n<p>　　删除rep-pool存储池</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/9be9a088-d893-41e5-8945-72a68a137f52.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　提示：虽然我们进用了上述的两个防止意外删除存储池的机制外，我们在直接删除存储池ceph还会提示我们需要将存储池的名称写两遍以及加--yes-i-really-really-mean-it选项来确定删除存储池的操作；</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/85149264-89b2-48ad-a7a3-44f4f5757597.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　提示：删除需要删除的存储池以后，我们需要将mon allow pool delete的值修改为false防止后面误删除存储池；</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/e5f12978-202d-457a-a8ce-be8898115b9f.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　5、设置存储池配额</p> \n<p>　　Ceph支持为存储池设置可存储对象的最大数量（max_objects）和可占用的最大空间（max_bytes）两个纬度的配额，命令格式ceph osd pool set-quota &lt;pool-name&gt; max_objects|max_bytes &lt;val&gt;；获取存储池配额的相关信息命令格式：ceph osd pool get-quota &lt;pool-name&gt;；</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/22169f3d-f6b5-4577-a464-80b5e74b6aa5.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　6、配置存储池参数</p> \n<p>　　存储池的诸多配置属性保存于配置参数中，获取配置：ceph osd pool get &lt;pool-name&gt; &lt;key&gt;；设定配置：ceph osd pool set &lt;pool-name&gt; &lt;key&gt; &lt;value&gt;；</p> \n<p>　　存储池常用的可配置参数</p> \n<p>　　size：存储池中的对象副本数；</p> \n<p>　　min_size：I/O所需要的最小副本数；</p> \n<p>　　pg_num：存储池的PG数量；</p> \n<p>　　pgp_num：计算数据归置时要使用的PG的有效数量；</p> \n<p>　　crush_ruleset：用于在集群中映射对象归置的规则组；</p> \n<p>　　nodelete：控制是否可删除存储池；</p> \n<p>　　nopgchange：控制是否可更改存储池的pg_num和pgp_num；</p> \n<p>　　nosizechange：控制是否可更改存储池的大小；</p> \n<p>　　noscrub和nodeep-scrub：控制是否可整理或深层整理存储池以解决临时高I/O负载的问题；</p> \n<p>　　scrub_min_interval：集群负载较低时整理存储池的最小时间间隔；默认值为0，表示其取值来自于配置文件中的osd_scrub_min_interval参数；</p> \n<p>　　scrub_max_interval：整理存储池的最大时间间隔；默认值为0，表示其取值来自于配置文件中的osd_scrub_max_interval参数；</p> \n<p>　　deep_scrub_interval：深层整理存储池的间隔；默认值为0，表示其取值来自于配置文件中的osd_deep_scrub参数；</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/56ff8255-69a6-4700-9fc5-46ec2ae1a5eb.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　7、存储池快照</p> \n<p>　　关于存储池快照</p> \n<p>　　• 存储池快照是指整个存储池的状态快照；</p> \n<p>　　• 通过存储池快照，可以保留存储池状态的历史；</p> \n<p>　　• 创建存储池快照可能需要大量存储空间，具体取决于存储池的大小；</p> \n<p>　　创建存储池快照命令格式：&nbsp;ceph osd pool mksnap &lt;pool-name&gt; &lt;snap-name&gt;或者rados -p &lt;pool-name&gt; mksnap &lt;snap-name&gt;</p> \n<p>　　列出存储池的快照命令格式：rados -p &lt;pool-name&gt; lssnap</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ ceph osd pool mksnap cephfs-metadatpool metadatasnap1\ncreated pool cephfs-metadatpool snap metadatasnap1\n[cephadm@ceph-admin ~]$ rados -p cephfs-metadatpool lssnap\n1       metadatasnap1   2022.09.30 00:20:55\n1 snaps\n[cephadm@ceph-admin ~]$ \n</pre> \n</div> \n<p>　　回滚存储池至指定的快照命令格式：&nbsp;rados -p &lt;pool-name&gt; rollback &lt;pool-name&gt; &lt;snap-name&gt;</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ rados -p cephfs-metadatpool lssnap\n1       metadatasnap1   2022.09.30 00:20:55\n2       metadatasnap2   2022.09.30 00:22:35\n2 snaps\n[cephadm@ceph-admin ~]$ rados -p cephfs-metadatpool rollback  cephfs-metadatpool metadatasnap2\nrolled back pool cephfs-metadatpool to snapshot metadatasnap2\n[cephadm@ceph-admin ~]$ \n</pre> \n</div> \n<p>　　删除存储池快照命令格式：&nbsp;ceph osd pool rmsnap &lt;pool-name&gt; &lt;snap-name&gt;或 rados -p &lt;pool-name&gt; rmsnap &lt;snap-name&gt;</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ rados -p cephfs-metadatpool lssnap\n1       metadatasnap1   2022.09.30 00:20:55\n2       metadatasnap2   2022.09.30 00:22:35\n2 snaps\n[cephadm@ceph-admin ~]$ ceph osd pool rmsnap cephfs-metadatpool metadatasnap1\nremoved pool cephfs-metadatpool snap metadatasnap1\n[cephadm@ceph-admin ~]$ rados -p cephfs-metadatpool lssnap                   \n2       metadatasnap2   2022.09.30 00:22:35\n1 snaps\n[cephadm@ceph-admin ~]$ rados -p cephfs-metadatpool rmsnap metadatasnap2\nremoved pool cephfs-metadatpool snap metadatasnap2\n[cephadm@ceph-admin ~]$ rados -p cephfs-metadatpool lssnap\n0 snaps\n[cephadm@ceph-admin ~]$ \n</pre> \n</div> \n<p>　　提示：不用的快照建议及时清除；</p> \n<p>　　8、存储池数据压缩</p> \n<p>　　BlueStore存储引擎提供即时数据压缩，以节省磁盘空间，启用压缩命令格式：ceph osd pool set &lt;pool-name&gt; compression_algorithm snappy；压缩算法有none、zlib、lz4、zstd和snappy等几种，默认为snappy；zstd有较好的压缩比，但比较消耗CPU；lz4和snappy对CPU占用比例较低；不建议使用zlib；</p> \n<p>　　设置压缩模式命令格式：ceph osd pool set &lt;pool-name&gt; compression_mode aggressive ；压缩模式：none、aggressive、passive和force，默认值为none；&nbsp;none表示不压缩；&nbsp;passive表示若提示COMPRESSIBLE，则压缩；aggressive表示除非提示INCOMPRESSIBLE，否则就压缩；&nbsp;force表示始终压缩；</p> \n<p>　　其它可用的压缩参数</p> \n<p>　　compression_required_ratio：指定压缩比，取值格式为双精度浮点型，其值为SIZE_COMPRESSED/SIZE_ORIGINAL，即压缩后的大小与原始内容大小的比值，默认为.875；</p> \n<p>　　compression_max_blob_size：压缩对象的最大体积，无符号整数型数值，默认为0，表示没有限制；</p> \n<p>　　compression_min_blob_size：压缩对象的最小体积，无符号整数型数值，默认为0，表示没有限制；</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/656ea31e-dc3e-40da-92fd-6d236af6282a.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　提示：压缩最小体积和最大体积都是以字节为单位；</p> \n<p>　　全局压缩选项</p> \n<p>　　可在ceph配置文件中设置压缩属性，它将对所有的存储池生效；可设置的相关参数如下</p> \n<p>　　• bluestore_compression_algorithm<br>　　• bluestore_compression_mode<br>　　• bluestore_compression_required_ratio<br>　　• bluestore_compression_min_blob_size<br>　　• bluestore_compression_max_blob_size<br>　　• bluestore_compression_min_blob_size_ssd<br>　　• bluestore_compression_max_blob_size_ssd<br>　　• bluestore_compression_min_blob_size_hdd<br>　　• bluestore_compression_max_blob_size_hdd</p> \n<p>　　9、纠删码池配置文件</p> \n<p>　　列出纠删码配置文件命令格式：&nbsp;ceph osd erasure-code-profile ls</p> \n<p>　　获取指定的配置文件的相关内容：ceph osd erasure-code-profile get default</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ ceph osd erasure-code-profile ls\ndefault\n[cephadm@ceph-admin ~]$ ceph osd erasure-code-profile get default\nk=2\nm=1\nplugin=jerasure\ntechnique=reed_sol_van\n[cephadm@ceph-admin ~]$ \n</pre> \n</div> \n<p>　　自定义纠删码配置文件</p> \n<p>　　命令格式：ceph osd erasure-code-profile set &lt;name&gt; [&lt;directory=directory&gt;]&nbsp;&nbsp;[&lt;plugin=plugin&gt;] [&lt;crush-device-class&gt;] [&lt;crush-failure-domain&gt;]&nbsp;[&lt;key=value&gt; ...] [--force]</p> \n<p>　　• - directory：加载纠删码插件的目录路径，默认为/usr/lib/ceph/erasure-code；<br>　　• - plugin：用于生成及恢复纠删码块的插件名称，默认为jerasure；<br>　　• - crush-device-class：设备类别，例如hdd或ssd，默认为none，即无视类别；<br>　　• - crush-failure-domain：故障域，默认为host，支持使用的包括osd、host、rack、row和room等；</p> \n<p>　　• - --force：强制覆盖现有的同名配置文件；</p> \n<p>　　例如，如果所需的体系结构必须承受两个OSD的丢失，并且存储开销为30％；</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ ceph osd erasure-code-profile ls\ndefault\n[cephadm@ceph-admin ~]$ ceph osd erasure-code-profile set myprofile k=4 m=2 crush-failure-domain=osd\n[cephadm@ceph-admin ~]$ ceph osd erasure-code-profile ls\ndefault\nmyprofile\n[cephadm@ceph-admin ~]$ \n</pre> \n</div> \n<p>　　纠删码插件</p> \n<p>　　Ceph支持以插件方式加载使用的纠删编码插件，存储管理员可根据存储场景的需要优化选择合用的插件。目前，Ceph支持的插件包括如下三个：</p> \n<p>　　1、jerasure：最为通用的和灵活的纠删编码插件，它也是纠删码池默认使用的插件；不过，任何一个OSD成员的丢失，都需要余下的所有成员OSD参与恢复过程；另外，使用此类插件时，管理员还可以通过technique选项指定要使用的编码技术；</p> \n<p>　　　　• reed_sol_van：最灵活的编码技术，管理员仅需提供k和m参数即可；</p> \n<p><em id=\"__mceDel\">　　　　</em>• cauchy_good：更快的编码技术，但需要小心设置PACKETSIZE参数；<br>　　　　• reed_sol_r6_op、liberation、blaum_roth或liber8tion：仅支持使用m=2的编码技术，功能特性类同于RAID 6；</p> \n<p>　　2、&nbsp;lrc：全称为Locally Repairable Erasure Code，即本地修复纠删码，除了默认的m个编码块之外，它会额外在本地创建指定数量（l）的奇偶校验块，从而在一个OSD丢失时，可以仅通过l个奇偶校验块完成恢复；</p> \n<p>　　3、isa：仅支持运行在intel CPU之上的纠删编码插件，它支持reed_sol_van和cauchy两种技术；</p> \n<p>　　例如，下面的命令创建了一个使用lrc插件的配置文件LRCprofile，其本地奇偶校验块为3，故障域为osd</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[cephadm@ceph-admin ~]$ ceph osd erasure-code-profile set LRCprofile plugin=lrc k=4 m=2 l=3 crush-failure-domain=osd\n[cephadm@ceph-admin ~]$ ceph osd erasure-code-profile ls\nLRCprofile\ndefault\nmyprofile\n[cephadm@ceph-admin ~]$ </pre> \n</div> \n<p>&nbsp;</p>',100,NULL,0,'https://www.cnblogs.com/qiuhom-1874/p/16743611.html','2022-10-06 23:56:54'),(8,'将 N 叉树编码为二叉树',NULL,NULL,0,0,'<h1 id=\"将-n-叉树编码为二叉树\">将 N 叉树编码为二叉树</h1> \n<p>作者：<a href=\"https://www.cnblogs.com/greyzeng/\" target=\"_blank\" rel=\"noopener\">Grey</a></p> \n<p>原文地址：</p> \n<p><a href=\"https://www.cnblogs.com/greyzeng/p/16758370.html\" target=\"_blank\" rel=\"noopener\">博客园：将 N 叉树编码为二叉树</a></p> \n<p><a href=\"https://blog.csdn.net/hotonyhui/article/details/127187242\" target=\"_blank\" rel=\"noopener\">CSDN：将 N 叉树编码为二叉树</a></p> \n<h2 id=\"题目描述\">题目描述</h2> \n<p>将一棵n叉树编码为一棵二叉树，并对二叉树进行解码，得到原始的n叉树。 n叉树是一棵有根树，其中每个节点的子树不超过n个。 类似地，二叉树是一棵有根树，其中每个节点的子树不超过2个。 编码/解码算法的工作方式不受限制。 您只需要确保一个n叉树可以被编码为一个二叉树，并且这个二叉树可以被解码为原始的n叉树结构。</p> \n<p>题目链接：<a href=\"https://www.lintcode.com/problem/1530/\" target=\"_blank\" rel=\"noopener\">LintCode 1530 · Encode N-ary Tree to Binary Tree</a></p> \n<p>一棵 N 叉树的示例如下</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/2d4d472f-f8b6-418a-b0be-688d65413b2f.png\" alt=\"image\" loading=\"lazy\"></p> \n<p>二叉树的数据结构如下</p> \n<pre><code class=\"language-java\">class TreeNode {\n    public int val;\n    public TreeNode left, right;\n\n    public TreeNode(int val) {\n        this.val = val;\n        this.left = this.right = null;\n    }\n}\n</code></pre> \n<p>N 叉树的数据结构如下</p> \n<pre><code class=\"language-java\">class UndirectedGraphNode {\n     int label;\n     List&lt;UndirectedGraphNode&gt; neighbors;\n     UndirectedGraphNode(int x) {\n         label = x;\n         neighbors = new ArrayList&lt;UndirectedGraphNode&gt;();\n     }\n} \n</code></pre> \n<p>每个节点有属于自己的 label 值，也有若干个孩子节点，即<code>List&lt;UndirectedGraphNode&gt; neighbors</code>。</p> \n<p>我们需要实现如下两个方法</p> \n<pre><code class=\"language-java\">// N 叉树编码成 二叉树\nTreeNode encode(UndirectedGraphNode root)\n// 二叉树编码成 N 叉树\nUndirectedGraphNode decode(TreeNode root)\n</code></pre> \n<h2 id=\"主要思路\">主要思路</h2> \n<p>N 叉树编码成二叉树的方法是<strong>将 N 叉树中每个节点的子节点转换成自己左树的右边界或者右树的左边界</strong>，示例图如下</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/b6287a57-615d-4d45-931b-b19a15a1c39f.png\" alt=\"image\" loading=\"lazy\"></p> \n<p>二叉树编码成 N 叉树的方法就是<strong>把每个节点的左树右边界存到一个 List 里面，作为这个节点的子节点列表即可</strong>，就是上述示例图的逆过程。</p> \n<p>N 叉树编码成二叉树的过程就是一个深度优先遍历，首先</p> \n<pre><code class=\"language-java\">TreeNode head = new TreeNode(root.label);\n</code></pre> \n<p>表示二叉树的根节点就是 N 叉树的根节点，</p> \n<p>然后将根节点的孩子节点，调用递归，进行深度优先遍历，代码如下</p> \n<pre><code class=\"language-java\">// 将某个节点的孩子节点挂在其右树的左边界上\n// 将 N 叉树的根节点的孩子节点做深度优先遍历\n// 并将其挂在根节点的右树上\nhead.right = en(root.neighbors);\n\n// 深度优先遍历\nprivate TreeNode en(List&lt;UndirectedGraphNode&gt; neighbors) {\n        TreeNode c = null;\n        TreeNode head = null;\n        for (UndirectedGraphNode neighbor : neighbors) {\n            TreeNode node = new TreeNode(neighbor.label);\n            if (head == null) {\n                // 头节点为空，建出来\n                head = node;\n            } else {\n                // 否则挂在当前节点的右树的左边界上\n                c.left = node;\n            }\n            c = node;\n            c.right = en(neighbor.neighbors);\n        }\n        return head;\n}\n</code></pre> \n<p>将二叉树转换成 N 叉树的逻辑如下：</p> \n<p>首先</p> \n<pre><code class=\"language-java\">UndirectedGraphNode node = new UndirectedGraphNode(root.val);\n</code></pre> \n<p>表示：N 叉树的根节点也是二叉树的根节点。</p> \n<p>接着调用递归，将二叉树的右树构造出 N 叉树当前节点的孩子节点。</p> \n<pre><code class=\"language-java\">// 将二叉树的右树构造出 N 叉树当前节点的孩子节点\nnode.neighbors = de(root.right);\n\npublic ArrayList&lt;UndirectedGraphNode&gt; de(TreeNode root) {\n    ArrayList&lt;UndirectedGraphNode&gt; children = new ArrayList&lt;&gt;();\n    while (root != null) {\n        UndirectedGraphNode cur = new UndirectedGraphNode(root.val);\n        cur.neighbors = de(root.right);\n        children.add(cur);\n        root = root.left;\n    }\n    return children;\n}\n</code></pre> \n<p>其中 while 循环中就是不断的把当前节点的左树右边界加入到一个 List 中，最后返回。</p> \n<p>完整代码如下</p> \n<pre><code class=\"language-java\">public class Solution {\n    public UndirectedGraphNode decode(TreeNode root) {\n        if (root == null) {\n            return null;\n        }\n        UndirectedGraphNode node = new UndirectedGraphNode(root.val);\n        node.neighbors = de(root.right);\n        return node;\n    }\n\n    public ArrayList&lt;UndirectedGraphNode&gt; de(TreeNode root) {\n        ArrayList&lt;UndirectedGraphNode&gt; children = new ArrayList&lt;&gt;();\n        while (root != null) {\n            UndirectedGraphNode cur = new UndirectedGraphNode(root.val);\n            cur.neighbors = de(root.right);\n            children.add(cur);\n            root = root.left;\n        }\n        return children;\n    }\n\n    // 每个子节点转换成自己左树的右边界或者右树的左边界 + 深度优先遍历\n    // 编码\n    public TreeNode encode(UndirectedGraphNode root) {\n        if (root == null) {\n            return null;\n        }\n        TreeNode head = new TreeNode(root.label);\n        // 右树的左边界\n        head.right = en(root.neighbors);\n        return head;\n    }\n\n    private TreeNode en(List&lt;UndirectedGraphNode&gt; neighbors) {\n        TreeNode c = null;\n        TreeNode head = null;\n        for (UndirectedGraphNode neighbor : neighbors) {\n            TreeNode node = new TreeNode(neighbor.label);\n            if (head == null) {\n                // 头节点为空，建出来\n                head = node;\n            } else {\n                // 否则挂在当前节点的右树的左边界上\n                c.left = node;\n            }\n            c = node;\n            c.right = en(neighbor.neighbors);\n        }\n        return head;\n    }\n}\n</code></pre> \n<p>本文涉及到的所有图例见：<a href=\"https://www.processon.com/view/link/633ebe97e0b34d40be522c96\" target=\"_blank\" rel=\"noopener\">二叉树与N叉树的互相转换</a></p> \n<h2 id=\"更多\">更多</h2> \n<p><a href=\"https://github.com/GreyZeng/algorithm\" target=\"_blank\" rel=\"noopener\">算法和数据结构笔记</a></p>',100,NULL,0,'https://www.cnblogs.com/greyzeng/p/16758370.html','2022-10-06 23:56:57'),(9,'用深度强化学习玩FlappyBird',NULL,NULL,0,0,'<p><font face=\"仿宋\" size=\"4\">摘要：学习玩游戏一直是当今<font face=\"Times New Roman \" size=\"4\"><em>AI</em></font>研究的热门话题之一。使用博弈论/搜索算法来解决这些问题需要特别地进行周密的特性定义，使得其扩展性不强。使用深度学习算法训练的卷积神经网络模型（<font face=\"Times New Roman \" size=\"4\"><em>CNN</em></font>）自提出以来在图像处理领域的多个大规模识别任务上取得了令人瞩目的成绩。本文是要开发一个一般的框架来学习特定游戏的特性并解决这个问题，其应用的项目是受欢迎的手机游戏<font face=\"Times New Roman \" size=\"4\"><em>Flappy Bird</em></font>，控制游戏中的小鸟穿过一堆障碍物。本文目标是开发一个卷积神经网络模型，从游戏画面帧中学习特性，并训练模型在每一个游戏实例中采取正确的操作。本文综述了基于深度学习的卷积神经网络模型在模式识别（图像识别）中的应用，主要从典型的网络结构的构建、训练方法和性能表现3个方面进行介绍。</font></p> \n<ul> \n <li><strong><a href=\"#title1\" rel=\"noopener\"><font face=\"仿宋\" size=\"4\">简介及问题定义</font></a></strong></li> \n <li><strong><a href=\"#title2\" rel=\"noopener\"><font face=\"仿宋\" size=\"4\">相关工作与实现方法</font></a></strong></li> \n <li><strong><a href=\"#title3\" rel=\"noopener\"><font face=\"仿宋\" size=\"4\"><font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习算法</font></a></strong></li> \n <li><strong><a href=\"#title4\" rel=\"noopener\"><font face=\"仿宋\" size=\"4\">实验与结果</font></a></strong></li> \n</ul> \n<hr> \n<h1 id=\"1-前言\"><font face=\"华文行楷\" size=\"5\">1. 前言</font></h1> \n<p><font face=\"仿宋\" size=\"4\"> &nbsp;&nbsp;&nbsp;&nbsp;作为深度强化学习的一个很好的入门学习教程，用深度强化学习玩<font face=\"Times New Roman \" size=\"4\"><em>FlappyBird</em></font>这个示例一直是个很火的代码，网上也有不少的文章介绍。不过其大多从代码角度介绍，如果需要输入了解其理论与原理我们则需要更多论文资料。这里我翻译整理了相关论文并加入些自己的理解写在这篇博文中，详细可参考论文<a href=\"http://cs229.stanford.edu/proj2015/362_report.pdf\" target=\"_blank\" rel=\"noopener\"><font face=\"Times New Roman \" size=\"4\"><em>Deep Reinforcement Learning for Flappy Bird</em></font></a>，具体关于深度强化学习的代码介绍将在后面的博文中介绍。</font></p> \n<hr> \n<p><span id=\"title1\"></span></p> \n<h1 id=\"2-简介及问题定义\"><font face=\"华文行楷\" size=\"5\">2. 简介及问题定义</font></h1> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Times New Roman \" size=\"4\"><em>FlappyBird</em></font>是一款游戏，玩家控制的对象是游戏中的“小鸟”，在游戏运行瞬间有两个可以采取的动作：按下“上升”键，使得小鸟向上跳跃，而未按下任何按键时小鸟则以恒定速率下降。</font></p> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;如今，深度学习通过组合低层特征形成更加抽象的高层表示属性类别或特征，以发现数据的分布式特征表示，使得机器学习模型可以直接学习概念，如直接从原始图像数据进行物体类别分类。深层卷积神经网络采用平铺分层卷积滤波器层来模拟视野接受域的影响，在处理计算机视觉问题上，如分类和检测问题，获得了很大成功。本文目的是开发一个深层神经网络模型，具体地，是利用图像中的不同对象训练卷积神经网络，进行基于游戏画面场景状态分析进行图像识别分类。从原始像素中学习游戏的特性，并决定采取相应行动，本质上是一个对游戏场景中特定状态的模式识别过程，在此设计了一个强化学习系统，通过自主学习来玩这款游戏。</font></p> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;当通过很少预定的行为进行编程不能充分解决问题时，可采用强化学习方式，这是一种通过进行场景训练，使算法在输入未知和多维数据（如彩色图片）时做出正确的决策方式。通过这种方式，可以进行在线学习，而且算法可以学会自动对图像进行特征提取，对于训练中未出现的场景和状态也同样可以进行分类和预测。</font></p> \n<div align=\"center\"> \n <img width=\"300px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/0e30998c-22c5-4af5-b741-bfef7a36ed2a.png\" alt=\"功能演示动图\"> \n</div> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">图1.FlappyBird游戏</font>\n</div> \n<hr> \n<p><span id=\"title2\"></span></p> \n<h1 id=\"3-相关工作与实现方法\"><font face=\"华文行楷\" size=\"5\">3. 相关工作与实现方法</font></h1> \n<h2 id=\"31-相关工作\"><font face=\"楷体\" size=\"4\">3.1 相关工作</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;谷歌<font face=\"Times New Roman \" size=\"4\"><em>DeepMind</em></font>利用深度学习技术玩游戏的影响，为从一个完全不同的视角去看待人工智能问题铺平了道路。其最新成果人工智能<font face=\"Times New Roman \" size=\"4\"><em>AlphaGo</em></font>，在其与围棋大师的激烈竞争中向人们展示了深度学习的巨大潜力。<font face=\"Times New Roman \" size=\"4\"><em>DeepMind</em></font>以前仅仅根据游戏原始图片就能学习和玩2600种雅达利游戏。<font face=\"Times New Roman \" size=\"4\"><em>Mnih</em></font>等人，使用强化学习成功训练玩这些游戏的模型，在多种游戏[1]，[2]中超过了人类专家级别。他们提出了一种新的模型，即结合了深层神经网络的强化学习的深度<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>网络（<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>）模型，以深层神经网络作为近似函数代表<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习中的<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>值（动作值）。他们还论述了一些提高训练效率和稳定性的技术，使用以前经验的“经验回放”，从中随机抽取小批量来更新网络，以便将模型得到的经验和延迟更新联系起来，从而获得目标值（稍后详细介绍）以提高稳定性。该通道的另一个优点是完全无需标记的数据，该模型通过与游戏模拟器的交互，并随着时间的推移学会做出很好的决策。正是这种简单的学习模型以及在玩<font face=\"Times New Roman \" size=\"4\"><em>Atari</em></font>游戏时的惊人结果，启发我们采用一个类似的算法来完成本文所涉及的项目。</font></p> \n<h2 id=\"32-实现方法\"><font face=\"楷体\" size=\"4\">3.2 实现方法</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;本文是通过训练一个深度卷积神经网络模型（深度<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习网络）进行特定游戏状态下图像的识别与分类。深度<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习网络是一个经改进过的<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习算法训练得到的卷积神经网络，其输入是原始的游戏画面，输出是一个评价未来奖励的价值函数。人工智能系统的任务是提取游戏运行的图像，并输出从可采取的操作集合中提取的必要执行动作。这相当于一个分类问题，不过与常见的分类问题不同，这里没有带标记的数据来训练模型。可以采用强化学习，根据执行游戏并基于所观察到的奖励来评价一个给定状态下的动作，以此来进行模型训练。</font></p> \n<h2 id=\"33-构建模型\"><font face=\"楷体\" size=\"4\">3.3 构建模型</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;游戏中小鸟可以采取的动作是煽动翅膀向上飞（<span class=\"math inline\">\\(a＝1\\)</span>）或不做任何动作（<span class=\"math inline\">\\(a＝0\\)</span>）。当前状态（框架）是由经预处理的当前帧原始图像（<span class=\"math inline\">\\(X_t\\)</span>）与有限数量的先前帧图像（<span class=\"math inline\">\\(X_{t-1}\\)</span>, <span class=\"math inline\">\\(X_{t-2}\\)</span>,…）构成。这样，每一个状态都将唯一地对应小鸟运动到某一位置所遵循的运动轨迹，从而向模型提供实时信息，先前存储的帧数成为超参数。理想情况下，<span class=\"math inline\">\\(S_t\\)</span>是从<span class=\"math inline\">\\(t＝1\\)</span>开始的所有帧的函数，不过为了减少状态空间，只使用有限的数量帧。如前所述，当鸟撞到管道或屏幕边缘时，可以给其一个负面奖励，如果通过了间隙，可得到一个正面的奖励。这样可以像人类玩家一样，尽量避免死亡并尽可能多得分。因此，有两个奖励，分别是<font face=\"Times New Roman \" size=\"4\"><em>rewardPass</em></font>和<font face=\"Times New Roman \" size=\"4\"><em>rewardDie</em></font>。折扣系数（<span class=\"math inline\">\\(\\gamma\\)</span>）为0.9，用于从未来动作贴现的奖励。</font></p> \n<hr> \n<p><span id=\"title3\"></span></p> \n<h1 id=\"4-q学习算法\"><font face=\"华文行楷\" size=\"5\">4. <font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习算法</font></h1> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;强化学习的目标是使总回报（奖励）最大化。在<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习中，它是非策略的，迭代更新使用的是贝尔曼方程</font>$$Q_{i+1}(s,a)=r+ \\gamma \\underset{{a}\'}{max}{Q_{i}({s}\',{a}\') }$$<font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;其中<span class=\"math inline\">\\({s}\'\\)</span>和<span class=\"math inline\">\\({a}\'\\)</span>分别是下一帧的状态和动作，<span class=\"math inline\">\\(r\\)</span>是奖励，<span class=\"math inline\">\\(γ\\)</span>是折扣因子。<span class=\"math inline\">\\(Q_i (s,a)\\)</span>是为<span class=\"math inline\">\\((s,a)\\)</span>矩阵在第i次迭代的<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>值。这种更新迭代将收敛得到一个最佳的<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>函数。为了防止学习僵化，这个动作值函数可以用一个函数（这里为深度学习网络）近似，以便能更好概括不可预见的状态。学习算法的输入点由<span class=\"math inline\">\\(s_t\\)</span>, <span class=\"math inline\">\\(a_t\\)</span>, <span class=\"math inline\">\\(r_t\\)</span>, <span class=\"math inline\">\\(s_{t+1}\\)</span>,的列表构成，函数能够通过这些输入点来构建一个能最大限度提高整体回报并以此预测动作的模型。将这里的函数构建为一个卷积神经网络，并使用上述方程中的更新规则更新其参数。以下两个方程为使用损失函数及其梯度来模拟这个函数。</font></p> \n<p></p>\n<div class=\"math display\">\n \\[L=\\sum_{s,a,r,{s}\'}(Q(s,a;\\theta )-(r+\\gamma \\underset{{a}\'}{max}Q({s}\',{a}\';\\theta^{-})))^{2} \\]\n</div>\n<p></p>\n<p></p>\n<div class=\"math display\">\n \\[\\Delta_{\\theta} L=\\sum_{s,a,r,{s}\'}-2(Q(s,a;\\theta )-(r+\\gamma \\underset{{a}\'}{max}Q({s}\',{a}\';\\theta^{-})))\\Delta_{\\theta}Q(s,a;\\theta) \\]\n</div>\n<p></p>\n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;其中，<span class=\"math inline\">\\(\\theta\\)</span>是训练后的<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数， <span class=\"math inline\">\\(\\theta^{-}\\)</span>（在后面的章节中解释）是<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>值函数的非更新参数。因此，可以简单地使用上述损失函数的随机梯度下降法和反向传播算法更新神经网络权重（<span class=\"math inline\">\\(\\theta\\)</span>）。算法1是为训练而设计的算法，是一种加强探索的<span class=\"math inline\">\\(\\varepsilon\\)</span>贪婪算法。当训练进行时，有<span class=\"math inline\">\\(\\varepsilon\\)</span>的概率会随机选择动作或选择最优动作<span class=\"math inline\">\\(a_{opt}=arg max_{{a}\'} Q(s,{a}\';θ)\\)</span>,其中<span class=\"math inline\">\\(\\varepsilon\\)</span>随着更新次数的增加逐渐减小到0。</font></p> \n<h2 id=\"41-预处理\"><font face=\"楷体\" size=\"4\">4.1 预处理</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Times New Roman \" size=\"4\"><em>Flappy Bird</em></font>游戏直接输出的像素是284×512的，但为了节省内存将其缩小为84×84大小的图像，每帧图像色阶都是0-255。此外，为了提高卷积神经网络的精度，在这一步去除背景层并用纯黑色背景代替，以去除噪声，如图2所示。依次对所得游戏图像进行缩放、灰度化以及调整亮度处理。在当前帧进入一个状态之前，处理几帧图像叠加组合的多维图像数据（如在模型构建部分提到的），当前帧与先前帧重叠时，灰度稍有降低，当我们远离最新帧时强度降低。因此，这样输入的图像将提供关于小鸟当前所在轨迹的良好信息，其处理过程如图3所示。</font></p> \n<div align=\"center\"> \n <img width=\"300px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/4424cdbf-7858-4b3d-9b93-f13758b55770.png\" alt=\"功能演示动图\"> \n</div> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">图2.去除游戏背景</font>\n</div> \n<div align=\"center\"> \n <img width=\"700px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/211f86a5-0e8d-448e-a51d-04d08eda922b.png\" alt=\"功能演示动图\"> \n</div> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">图3. 图像处理流程图（其中红色块代表卷积层，绿色块代表最大池化层，蓝色部分代表全连接层）</font>\n</div> \n<h2 id=\"42-dqn结构\"><font face=\"楷体\" size=\"4\">4.2 <font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>结构</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;如图4所示，在当前模型结构中，有3个隐藏层。首先有两个卷积层，然后是两个完全连接层，最终完全连接层的输出是两个动作的得分，结果由损失函数得出。改进的损失函数自动进行<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习参数设置。遵循空间批量规范，在每个卷积层后都添加<font face=\"Times New Roman \" size=\"4\"><em>ReLu</em></font>和最大池化层。此外，在第一个仿射层（该批规范输出反馈到最终的仿射层）后是一个<font face=\"Times New Roman \" size=\"4\"><em>ReLu</em></font>激活函数和批量处理标准层。卷积层采用32个大小为3，步长为1，带有2×2最大池化核的滤波器。输入图像的大小84×84，每个时刻有两种可能的输出操作，每次动作将会获得一个得分值，以此决定最佳动作。</font></p> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">表1. 各层参数变化情况</font>\n</div> \n<table> \n <thead> \n  <tr> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Layer</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Input</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Filter size</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Stride</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Num filters</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Activation</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Output</em></font></th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>conv1</em></font></td> \n   <td style=\"text-align: center\">84×84×4</td> \n   <td style=\"text-align: center\">8×8</td> \n   <td style=\"text-align: center\">4</td> \n   <td style=\"text-align: center\">32</td> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>ReLU</em></font></td> \n   <td style=\"text-align: center\">20×20×32</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>pooling1</em></font></td> \n   <td style=\"text-align: center\">20×20×32</td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\">10×10×32</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>conv2</em></font></td> \n   <td style=\"text-align: center\">10×10×32</td> \n   <td style=\"text-align: center\">3×3</td> \n   <td style=\"text-align: center\">1</td> \n   <td style=\"text-align: center\">64</td> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>ReLU</em></font></td> \n   <td style=\"text-align: center\">8×8×64</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>pooling2</em></font></td> \n   <td style=\"text-align: center\">8×8×64</td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\">4×4×64</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>conv3</em></font></td> \n   <td style=\"text-align: center\">4×4×64</td> \n   <td style=\"text-align: center\">3×3</td> \n   <td style=\"text-align: center\">1</td> \n   <td style=\"text-align: center\">64</td> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>ReLU</em></font></td> \n   <td style=\"text-align: center\">2×2×64</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>pooling3</em></font></td> \n   <td style=\"text-align: center\">2×2×64</td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\">1×1×64</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Fc1</em></font></td> \n   <td style=\"text-align: center\">1×1×4</td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\">64×1</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Fc2</em></font></td> \n   <td style=\"text-align: center\">1×64</td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\"></td> \n   <td style=\"text-align: center\">2×1</td> \n  </tr> \n </tbody> \n</table> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;考虑到模型处理的精度，可以适当提高模型的复杂度，这里将卷积层的数目改进为3个，同时有3个池化层，两个全连接层，开始时叠加连续4帧预处理后的图像作为输入，表1详细列出了后的模型在每个步骤上的数据尺寸变化及各层参数。</font></p> \n<div align=\"center\"> \n <img width=\"600px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/38f0cff4-efe3-4807-a398-002c536efac2.png\" alt=\"功能演示动图\"> \n</div> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">图4. 卷积神经网络结构图</font>\n</div> \n<h2 id=\"43-经验回放与稳定性\"><font face=\"楷体\" size=\"4\">4.3 经验回放与稳定性</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;在<font face=\"Times New Roman \" size=\"4\"><em>Q</em></font>学习中，以连续方式记录的经验数据是高度相关的。若使用相同的顺序更新<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数，训练过程就会受到干扰。与从一个标记的数据集中采样小批量训练分类模型类似，这里同样应该在抽取出的获得更新的<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>经验中引入一定的随机性。为此设置一个经验回放存储器，用来存储每帧游戏画面的经验数据(<span class=\"math inline\">\\(s_t\\)</span>,<span class=\"math inline\">\\(a_t\\)</span>,<span class=\"math inline\">\\(r_t\\)</span>,<span class=\"math inline\">\\(s_{t+1}\\)</span>),直到达到其最大存储容量。重现的经验数据填充到一定的数量，随机抽取小批经验并用于进行<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数上的梯度下降。以固定的时间间隔更新<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数。由于小批量选择结果的随机性，用于更新<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数的数据是去相关的。</font><br> <font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;为了提高损失函数收敛的稳定性，使用方程2中提到的带参数<span class=\"math inline\">\\(\\theta ^{-}\\)</span>的贝尔曼更新方程重现<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>模型。参数<span class=\"math inline\">\\(\\theta ^{-}\\)</span>是每次<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>的<font face=\"Times New Roman \" size=\"4\"><em>C</em></font>值更新之后<span class=\"math inline\">\\(\\theta\\)</span>的更新值，用来计算算法1中<span class=\"math inline\">\\(y_j\\)</span>的值。</font></p> \n<h2 id=\"44-训练设计\"><font face=\"楷体\" size=\"4\">4.4 训练设计</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;整个<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>训练流程如算法1所示。如本节前面部分提到的，经验数据都存储在回放存储器中，每隔一段时间，从存储器随机采样出一小批样本，用于对<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数进行梯度下降运算。同网络参数<span class=\"math inline\">\\(\\theta ^{-}\\)</span>一样，必要时需要适当更新探索的概率。</font></p> \n<div align=\"center\"> \n <img width=\"552px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/2941158f-e0e4-4ab4-9b14-7cc281e1d4b0.png\" alt=\"功能演示动图\"> \n</div> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;游戏输出的得分作为唯一的评价指标，为了使结果具有健壮性，取几次游戏的平均得分而不是一次的得分。设置一个衰减值，使<span class=\"math inline\">\\(\\varepsilon\\)</span>因子在测试和训练中逐渐减小为零。这是在更多的训练和学习时，进行模型决策的保证。</font></p> \n<hr> \n<p><span id=\"title4\"></span></p> \n<h1 id=\"5-实验与结果\"><font face=\"华文行楷\" size=\"5\">5. 实验与结果</font></h1> \n<h2 id=\"51-训练参数\"><font face=\"楷体\" size=\"4\">5.1 训练参数</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;模型参数：<font face=\"Times New Roman \" size=\"4\"><em>Flappy Bird</em></font>游戏每秒播放10帧，最近的4帧图像处理后进行组合，生成一个状态；贴现因子<span class=\"math inline\">\\(\\gamma\\)</span>设置为0.9；奖励设置：<font face=\"Times New Roman \" size=\"4\"><em>rewardPass = + 1.0</em></font>, <font face=\"Times New Roman \" size=\"4\"><em>rewardDie=-1.0</em></font>。</font></p> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数：探索概率<span class=\"math inline\">\\(\\varepsilon\\)</span>在600000更新中从0.6线性下降到0。回放存储器的大小设置为20000，每有500次经验，就对存储器数据进行一次小批量采样。每次<font face=\"Times New Roman \" size=\"4\"><em>C</em></font>更新到100时，目标模型<span class=\"math inline\">\\(\\theta ^{-}\\)</span>的参数更新一次。小批量的32次经验数据中，随机抽取每5帧更新<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数。</font></p> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;训练参数：来更新<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>参数的梯度下降更新法是学习率为<span class=\"math inline\">\\(1e-6\\)</span>，<span class=\"math inline\">\\(β_1=0.9\\)</span>，<span class=\"math inline\">\\(β_2=0.95\\)</span>的<font face=\"Times New Roman \" size=\"4\"><em>Adam</em></font>优化器。在试错基础上选择这些参数，用来观察损失值的收敛性。卷积权重初始化为均值为0，方差为<span class=\"math inline\">\\(1e-2\\)</span>的正态分布。</font></p> \n<h2 id=\"52-结果与分析\"><font face=\"楷体\" size=\"4\">5.2 结果与分析</font></h2> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;训练结束后，用模型测试了一些游戏状态，以检测是否能得出合理的结果。图5示出了一些游戏场景及其相应的预测分数，其结果显示模型准确地对状态进行了分类。</font></p> \n<div align=\"center\"> \n <img width=\"552px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/a713f27b-e160-412e-befa-98e8c17d6544.png\" alt=\"功能演示动图\"> \n</div> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">图5. 示例游戏场景及其相应的分数。（5a是一个鸟必须跳起来的场景，5b是一个鸟儿必须往下走的场景）</font>\n</div> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;为了更好地理解经过训练的卷积神经网络模型的工作原理，输出图像5b在经过卷积层后的图像，以实现可视化。可以看出，大多数激活显示出空隙和鸟的边缘处清晰的斑块（图6）。可以明显地推断，神经网络在学习寻找小鸟与空隙的相对位置。</font></p> \n<div align=\"center\"> \n <img width=\"520px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/c63158d3-373e-4eec-862f-a99a20bce1b2.png\" alt=\"功能演示动图\"> \n</div> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">图6. 卷积层激活</font>\n</div> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;在大多数的在雅达利游戏上所做得实验[3]，采用<font face=\"Times New Roman \" size=\"4\"><em>L2</em></font>的损失函数。这里尝试了<font face=\"Times New Roman \" size=\"4\"><em>L1</em></font>的损失函数（下式）来引入一些正则化。这使得学习率的图像一开始就非常陡峭，如图7所示。通过这两种情况可以看出，平均得分稳步上升，表明该模型正在稳步学习。</font></p> \n<p></p>\n<div class=\"math display\">\n \\[L=\\sum_{s,a,r,{s}\'}\\left |Q(s,a;\\theta )-(r+\\gamma \\underset{{a}\'}{max}Q({s}\',{a}\';\\theta^{-}) \\right | \\]\n</div>\n<p></p>\n<div align=\"center\"> \n <img width=\"800px\" src=\"http://localhost:8080/static/blogImages/2022/10/06/28e6a1ec-6fcf-4056-9041-29c82d2d67f3.png\" alt=\"功能演示动图\"> \n</div> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">图7. 两种不同损失函数的学习曲线</font>\n</div> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;从表2中可以看出，训练出的<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>模型取得了远超人类水平的良好成绩，在这样一个角色扮演的动画游戏中，可以看到，尽管有时鸟儿会死亡，但它总是力图通过水管间的空隙，最可能撞毁的是在间隙的边缘处。对此可以做的是提高模型的能力，可行的解决方案是使用不同的奖励方案，让小鸟走一条远离管道顶部和底部的路径。而人类玩家在玩游戏时也是尽力使小鸟保持在水管间隙中心位置，这同样可以通过一个精心设计的奖励方案实现。</font></p> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">表2. 两种损失函数下模型测试结果</font>\n</div> \n<table> \n <thead> \n  <tr> \n   <th style=\"text-align: center\"></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Human</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>DQN with L1</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>DQN with L2</em></font></th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Avg score</em></font></td> \n   <td style=\"text-align: center\">4.25</td> \n   <td style=\"text-align: center\">65</td> \n   <td style=\"text-align: center\">72</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Max score</em></font></td> \n   <td style=\"text-align: center\">21</td> \n   <td style=\"text-align: center\">215</td> \n   <td style=\"text-align: center\">309</td> \n  </tr> \n </tbody> \n</table> \n<h2 id=\"53-训练时间\"><font face=\"楷体\" size=\"4\">5.3 训练时间</font></h2> \n<div align=\"center\">\n <font face=\"仿宋\" size=\"3\">表3. 一定学习率时DQN的平均分</font>\n</div> \n<table> \n <thead> \n  <tr> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Training iterations</em></font></th> \n   <th style=\"text-align: center\"><font face=\"Times New Roman \" size=\"4\"><em>Score</em></font></th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td style=\"text-align: center\">99000</td> \n   <td style=\"text-align: center\">43.6</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\">199000</td> \n   <td style=\"text-align: center\">101.8</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\">299000</td> \n   <td style=\"text-align: center\">35.7</td> \n  </tr> \n  <tr> \n   <td style=\"text-align: center\">399000</td> \n   <td style=\"text-align: center\">201.3</td> \n  </tr> \n </tbody> \n</table> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;训练迭代的次数指的是<font face=\"Times New Roman \" size=\"4\"><em>DQN</em></font>更新的次数，结果如表3所示，可以看出，更多的训练次数并不意味着一定能提高模型预测结果的准确性（这里是对瞬时游戏状态下，最佳执行动作的判断分类）。实际上，更多次的训练存在许多不稳定性以及结果振荡情况，过多次数的训练，模型会出现过拟合情况。这些情况需要在进一步的研究中加以解决，一个可能采取的解决方法是训练时减小学习率或者构建复杂度神经网络模型。</font></p> \n<hr> \n<h1 id=\"6-结束语\"><font face=\"华文行楷\" size=\"5\">6. 结束语</font></h1> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;本文能够成功地运用深度的强化学习模型来玩游戏<font face=\"Times New Roman \" size=\"4\"><em>FlappyBird</em></font>，和传统的分类任务不同，这里进行图像识别任务采用的加强学习有个重要优点，即不需要带标记的数据，完成前面叙述的工作后即可保存训练好的模型。模型实现了特定游戏状态（模式）下，游戏执行的最佳动作预测，成功将一个游戏决策问题转换成对瞬时多维图像的分类识别问题并运用卷积神经网络加以解决。总的来说，结果显示了深度神经网络在处理图像信息上的能力，这为许多潜在的应用开辟了道路。</font></p> \n<p><font face=\"仿宋\" size=\"4\">&nbsp;&nbsp;&nbsp;&nbsp;除了强化学习的方式，完成<font face=\"Times New Roman \" size=\"4\"><em>FlappyBird</em></font>游戏也可以采用其他方法，如论文<a href=\"http://game.engineering.nyu.edu/wp-content/uploads/2016/04/exploring-game-space-FDG2015.pdf\" target=\"_blank\" rel=\"noopener\"><font face=\"Times New Roman \" size=\"4\"><em>Exploring Game Space Using Survival Analysis</em></font></a>的通过生存分析的方法，有兴趣的可以查阅原文。由于博主能力有限，博文中提及的方法与代码即使经过测试，也难免会有疏漏之处。希望您能热心指出其中的错误，以便下次修改时能以一个更完美更严谨的样子，呈现在大家面前。同时如果有更好的实现方法也请您不吝赐教。</font></p> \n<p><font face=\"仿宋\" size=\"4\">参考文献：</font><br> <font face=\"Times New Roman \" size=\"4\"><em>[1] C. Clark and A. Storkey. Teaching deep convolutional neural networks to play go. arXiv preprint arXiv:1412.3409, 2014. 1, 2<br> [2] V. Mnih, K. Kavukcuoglu, D. Silver, A. Graves, I. Antonoglou, D. Wierstra, and M. Riedmiller. Playing atari with deep reinforcement learning. arXiv preprint arXiv:1312.5602, 2013. 1, 2<br> [3] V. Mnih, K. Kavukcuoglu, D. Silver, A. A. Rusu, J. Veness, M. G. Bellemare, A. Graves, M. Riedmiller, A. K. Fidjeland, G. Ostrovski, et al. Human-level control through deep reinforcement learning. Nature, 518(7540):529–533, 2015. 3, 5<br> [4] D. Silver, A. Huang, C. J. Maddison, A. Guez, L. Sifre, G. van den Driessche, J. Schrittwieser, I. Antonoglou, V. Panneershelvam, M. Lanctot, et al. Mastering the game of go with deep neural networks and tree search. Nature, 529(7587):484–489, 2016. 1</em></font></p>',100,NULL,0,'https://www.cnblogs.com/sixuwuxian/p/16757476.html','2022-10-06 23:57:09'),(10,'条件期望：Conditional Expectation 举例详解之入门之入门之草履虫都说听懂了',NULL,NULL,0,0,'<p>我知道有很多人理解不了 “条件期望” (Conditional Expectation) 这个东西，有的时候没看清把随机变量看成事件，把 <span class=\"math inline\">\\(\\sigma\\)</span>-algebra 看成随机变量从而思路全错的时候，我也会觉得莫名奇妙。所以在这里用一个极其简单的例子解释一下，只要你是一只上过高中的草履虫那就能听懂。</p> \n<p></p>\n<div class=\"math display\">\n \\[\\]\n</div>\n<p></p>\n<p>我们来丢一枚质地均匀的硬币（意味着得到正面与反面的概率各为 <span class=\"math inline\">\\(\\frac{1}{2}\\)</span>），连丢两次并记录两次结果。那么很容易可以写出全集 <span class=\"math inline\">\\(\\Omega = \\left\\{ HH, HT, TH, TT \\right\\}\\)</span> ，<span class=\"math inline\">\\(H\\)</span> 和 <span class=\"math inline\">\\(T\\)</span> 分别代表正面和反面。现在是第一个需要稍加思考的地方，令 <span class=\"math inline\">\\(\\mathcal{G}\\)</span> 为一个 <span class=\"math inline\">\\(\\sigma\\)</span>-algebra，其中包括了第一次丢硬币结果的信息，请问 <span class=\"math inline\">\\(\\mathcal{G}\\)</span> 是什么？</p> \n<br> \n<hr> \n<br> \n<p>稍加思考，不难得出 <span class=\"math inline\">\\(\\mathcal{G} = \\left\\{\\Omega, ~ \\emptyset, ~ \\left\\{ HH, HT \\right\\}, ~ \\left\\{ TT, TH \\right\\} \\right\\}\\)</span>，这里也做出一个解释。首先要明确的是，<span class=\"math inline\">\\(\\Omega\\)</span> 中的元素 (例如 <span class=\"math inline\">\\(HH\\)</span>) 和 <span class=\"math inline\">\\(\\mathcal{G}\\)</span> 中的元素 (例如 <span class=\"math inline\">\\(\\left\\{ HH, HT \\right\\}\\)</span>) 之间的区别：前者是结果 (outcome)，后者是事件 (event)。我们对于一次 “抽样”，只能得到一种结果，例如 <span class=\"math inline\">\\(HH\\)</span>，代表丢两次硬币后得到两个正面的结果。但不同的结果由于共享某些特性，可以被划分在同一个事件当中，例如，丢两次硬币产生相同的结果应有两种，即同时为正面或同时为背面 (i.e. <span class=\"math inline\">\\(HH\\)</span> 或 <span class=\"math inline\">\\(TT\\)</span>)，它们归属于 “丢两次硬币产生相同的结果” 的事件：<span class=\"math inline\">\\(\\left\\{ HH, TT \\right\\}\\)</span>。回到问题，现在我们已知了第一次丢硬币后结果的信息，也就是 \"第一次丢硬币是正面还是背面\"，那么我们自然可以得出 <span class=\"math inline\">\\(\\mathcal{G}\\)</span> 是由集类：<span class=\"math inline\">\\(\\left\\{ \\left\\{ HH, HT \\right\\}, ~ \\left\\{TT, TH \\right\\} \\right\\}\\)</span> 生成的 <span class=\"math inline\">\\(\\sigma\\)</span>-algebra。这是因为第一次扔硬币的结果已经被确定——无论它是正面还是背面：如果是正面，那么结果无非两种：两次都正面或第一次正面第二次背面；如果是背面，结果也无非两种：两次都背面或第一次背面第二次正面。结合以下树结构，在得知第一次扔硬币结果的信息后，相当于从根 <span class=\"math inline\">\\(XX\\)</span> 来到了第一层 <span class=\"math inline\">\\(HX\\)</span> 或 <span class=\"math inline\">\\(TX\\)</span> （<span class=\"math inline\">\\(X\\)</span> 代表未知信息）。</p> \n<br> \n<hr> \n<br> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/9915244d-8bb0-4cab-8aae-451bd855fb05.png\" alt=\"image\" loading=\"lazy\"></p> \n<br> \n<hr> \n<br> \n<p>同时，这也从另一个角度说明为什么概率论最终需要引入 “测度” 的定义——为了描述一种信息变化的过程。当我们并不知道第一次扔硬币的结果时，在全空间 <span class=\"math inline\">\\(\\Omega\\)</span> 上定义的测度空间为 <span class=\"math inline\">\\((\\Omega, \\mathcal{F}, P)\\)</span>，其中：</p> \n<p></p>\n<div class=\"math display\">\n \\[\\mathcal{F}:= \\left\\{ \\Omega, ~ \\emptyset, ~ \\left\\{ HH \\right\\}, ~ \\left\\{ HT \\right\\}, ~ \\left\\{ TH \\right\\}, ~ \\left\\{ TT \\right\\}, ~ \\left\\{ HH, HT \\right\\}, \\ldots \\right\\} \\]\n</div>\n<p></p>\n<p>where <span class=\"math inline\">\\(\\mathcal{F}\\)</span> 的 cardinality: <span class=\"math inline\">\\(|\\mathcal{F}| = 2^{4} = 16\\)</span>。</p> \n<p></p>\n<div class=\"math display\">\n \\[\\]\n</div>\n<p></p>\n<p>而当已知第一次的信息后，<span class=\"math inline\">\\(\\sigma\\)</span>-algebra 随即收缩为：</p> \n<p></p>\n<div class=\"math display\">\n \\[\\mathcal{G}:= \\left\\{ \\Omega, ~ \\emptyset, ~ \\left\\{ HH, HT \\right\\}, ~ \\left\\{ TH, TT \\right\\} \\right\\} \\]\n</div>\n<p></p>\n<p></p>\n<div class=\"math display\">\n \\[\\]\n</div>\n<p></p>\n<p>现在考虑条件期望： <span class=\"math inline\">\\(\\mathbb{E}\\left[ X ~ | ~ \\mathcal{G} \\right]\\)</span>。其中，<span class=\"math inline\">\\(\\mathcal{G}\\)</span> 如上记作第一次丢完硬币后结果的全部信息，对于 <span class=\"math inline\">\\(\\forall w \\in \\Omega:\\)</span> 随机变量 <span class=\"math inline\">\\(X\\)</span> 定义为：</p> \n<p></p>\n<div class=\"math display\">\n \\[X(w) = \\begin{cases} a \\qquad \\mbox{if } ~ w = HH\\\\ b \\qquad \\mbox{if } ~ w = HT\\\\ c \\qquad \\mbox{if } ~ w = TH\\\\ d \\qquad \\mbox{if } ~ w = TT\\\\ \\end{cases} \\]\n</div>\n<p></p>\n<p>其中 <span class=\"math inline\">\\(a, b, c, d \\geq 0\\)</span>。</p> \n<br> \n<hr> \n<br> \n<h2 id=\"definition-conditional-expectation\">Definition. (Conditional Expectation)</h2> \n<p>令 <span class=\"math inline\">\\(X\\)</span> 为一个定义在 <span class=\"math inline\">\\((\\Omega, \\mathcal{F}, P)\\)</span> 上的非负随机变量。令 <span class=\"math inline\">\\(G_{1}, G_{2}, \\ldots\\)</span> 为一个两两不相交的事件序列，且对于 <span class=\"math inline\">\\(\\forall n \\in \\mathbb{N}^{+}: ~ P(G_{n}) &gt; 0\\)</span>，并且 <span class=\"math inline\">\\(\\bigcup\\limits_{n\\in\\mathbb{N}^{+}} G_{n} = \\Omega\\)</span>。令 <span class=\"math inline\">\\(\\mathcal{G}\\)</span> 为包含 <span class=\"math inline\">\\(\\left\\{ G_{1}, G_{2}, \\ldots \\right\\}\\)</span> 的最小 <span class=\"math inline\">\\(\\sigma\\)</span>-algebra，即，任意 <span class=\"math inline\">\\(\\mathcal{G}\\)</span> 的元素都可以写作 <span class=\"math inline\">\\(\\bigcup\\limits_{n \\in I} G_{n}\\)</span> 的形式，其中 <span class=\"math inline\">\\(I \\subset \\mathbb{N}^{+}\\)</span> (<span class=\"math inline\">\\(I\\)</span> 为 <span class=\"math inline\">\\(\\mathbb{N}^{+}\\)</span> 的某些子集)。那么：</p> \n<p></p>\n<div class=\"math display\">\n \\[\\mathbb{E}\\left[ X ~ | ~ \\mathcal{G} \\right](w) = \\mathbb{E}\\left[ X ~ | ~ G_{n} \\right] = \\frac{\\mathbb{E}\\left[ X \\cdot \\mathbb{I}_{G_{n}} \\right]}{P(G_{n})} \\qquad \\qquad \\mbox{if } w \\in G_{n} \\]\n</div>\n<p></p>\n<p>首先，<span class=\"math inline\">\\(\\mathbb{I}_{G_{n}}\\)</span>是一个随机变量，或者说函数：</p> \n<p></p>\n<div class=\"math display\">\n \\[\\mathbb{I}_{G_{n}}: \\Omega \\longrightarrow \\left\\{ 0, 1 \\right\\}, \\quad x \\longrightarrow \\mathbb{I}_{G_{n}}(x) = \\begin{cases} 1 \\qquad \\mbox{if } x \\in G_{n}\\\\ 0 \\qquad \\mbox{otherwise} \\end{cases} \\]\n</div>\n<p></p>\n<p>因此则可以判定，Conditional Expectation <span class=\"math inline\">\\(\\mathbb{E}\\left[ X ~ | ~ \\mathcal{G} \\right]\\)</span> 算出来也是一个随机变量，而并非常数。最后，我们可以发现一旦假设 <span class=\"math inline\">\\(w \\in G_{n}\\)</span>，那么一定意味着 <span class=\"math inline\">\\(w \\notin G_{k}, ~ \\forall k \\in \\mathbb{N}^{+}\\setminus\\left\\{n\\right\\}\\)</span>。</p> \n<br> \n<hr> \n<br> \n<p>回到扔硬币的例子。这里显然我们有：<span class=\"math inline\">\\(G_{1} = \\left\\{ HH, HT \\right\\}, ~ G_{2} = \\left\\{ TT, TH \\right\\}\\)</span>，且 <span class=\"math inline\">\\(G_{1} \\cup G_{2} = \\Omega\\)</span>。那么。我们现在只需要依次假设 <span class=\"math inline\">\\(w \\in G_{n}\\)</span>， 并求 <span class=\"math inline\">\\(\\frac{\\mathbb{E}\\left[ X \\cdot \\mathbb{I}_{G_{n}} \\right]}{P(G_{n})}\\)</span>，最后分类讨论逐点列出即可。</p> \n<p></p>\n<div class=\"math display\">\n \\[\\]\n</div>\n<p></p>\n<ul> \n <li>假设 <span class=\"math inline\">\\(w \\in G_{1} = \\left\\{ HH, HT \\right\\}\\)</span>，</li> \n</ul> \n<p></p>\n<div class=\"math display\">\n \\[ \\begin{align*} \\mathbb{E}\\left[ X ~ | ~ \\mathcal{G} \\right](w) &amp;= \\frac{\\mathbb{E}\\left[ X \\cdot \\mathbb{I}_{G_{1}}, ~ w \\in G_{1} \\right]}{P(G_{1})}\\\\ &amp;= \\frac{\\sum\\limits_{w \\in G_{1}}\\mathbb{E}\\left[ X \\cdot \\mathbb{I}_{G_{1}} ~ | ~ w \\in G_{1} \\right] \\cdot P\\big(\\left\\{ w \\right\\}\\big)}{P(G_{1})}\\\\ &amp;= \\frac{\\sum\\limits_{w \\in G_{1}} X(w) \\cdot P\\big(\\left\\{ w \\right\\}\\big)}{P(G_{1})}\\\\ &amp; = \\frac{X(HH) \\cdot P\\big( \\left\\{ HH \\right\\} \\big) + X(HT) \\cdot P\\big( \\left\\{ HT \\right\\} \\big)}{P\\big( \\left\\{ HH, HT \\right\\} \\big)}\\\\ &amp; = \\frac{\\frac{1}{4} \\cdot a + \\frac{1}{4} \\cdot b}{\\frac{1}{2}}\\\\ &amp; = \\frac{a + b}{2} \\end{align*} \\]\n</div>\n<p></p>\n<hr> \n<ul> \n <li>假设 <span class=\"math inline\">\\(w \\in G_{2} = \\left\\{ TT, TH \\right\\}\\)</span>，</li> \n</ul> \n<p></p>\n<div class=\"math display\">\n \\[ \\begin{align*} \\mathbb{E}\\left[ X ~ | ~ \\mathcal{G} \\right](w) &amp;= \\frac{\\mathbb{E}\\left[ X \\cdot \\mathbb{I}_{G_{2}}, ~ w \\in G_{2} \\right]}{P(G_{2})}\\\\ &amp;= \\frac{\\sum\\limits_{w \\in G_{2}}\\mathbb{E}\\left[ X \\cdot \\mathbb{I}_{G_{2}} ~ | ~ w \\in G_{2} \\right] \\cdot P\\big(\\left\\{ w \\right\\}\\big)}{P(G_{2})}\\\\ &amp;= \\frac{\\sum\\limits_{w \\in G_{2}} X(w) \\cdot P\\big(\\left\\{ w \\right\\}\\big)}{P(G_{2})}\\\\ &amp; = \\frac{X(TT) \\cdot P\\big( \\left\\{ TT \\right\\} \\big) + X(TH) \\cdot P\\big( \\left\\{ TH \\right\\} \\big)}{P\\big( \\left\\{ TT, TH \\right\\} \\big)}\\\\ &amp; = \\frac{\\frac{1}{4} \\cdot c + \\frac{1}{4} \\cdot d}{\\frac{1}{2}}\\\\ &amp; = \\frac{c + d}{2} \\end{align*} \\]\n</div>\n<p></p>\n<hr> \n<p>综上所述：</p> \n<p></p>\n<div class=\"math display\">\n \\[\\mathbb{E}\\left[ X ~ | ~ \\mathcal{G} \\right](w) = \\begin{cases} \\frac{a + b}{2} \\qquad \\mbox{if } ~ w \\in \\left\\{ HH, HT \\right\\}\\\\ \\frac{c + d}{2} \\qquad \\mbox{if } ~ w \\in \\left\\{ TT, TH \\right\\}\\\\ 0 \\qquad \\quad \\mbox{otherwise}\\\\ \\end{cases} \\]\n</div>\n<p></p>',100,NULL,0,'https://www.cnblogs.com/chetianjian/p/16758275.html','2022-10-06 23:57:11'),(11,'Vue3 Vite3 多环境配置 - 基于 vite 创建 vue3 全家桶项目(续篇）',NULL,NULL,0,0,'<p>在项目或产品的迭代过程中，通常会有多套环境，常见的有：</p> \n<ul> \n <li><em>dev</em>：开发环境</li> \n <li><em>sit</em>：集成测试环境</li> \n <li><em>uat</em>：用户接收测试环境</li> \n <li><em>pre</em>：预生产环境</li> \n <li><em>prod</em>：生产环境</li> \n</ul> \n<p>环境之间配置可能存在差异，如接口地址、全局参数等。在基于 <em>vue-cli （webpack）</em> 的项目中只需要添加 <em>.env.xxx</em> 文件，然后在 <em>package.json</em> 的 <em>scripts</em> 启动或打包命令中指定 <em>mode</em> 参数即可，获取环境变量时使用 <em>process.env.xxx</em>。<em>vite</em> 使用方式类似，但获取环境变量使用 <em>import.meta.env</em>。</p> \n<h2 id=\"1-环境变量和模式\">1 环境变量和模式</h2> \n<p>上面提到，vite 中使用 <em>import.meta.env</em> 的方式来获取环境变量。在 <em>main.ts</em> 中添加如下代码进行测试：</p> \n<pre><code class=\"language-typescript\">const env = import.meta.env\nconsole.log(env)\n</code></pre> \n<h3 id=\"11-development\">1.1 development</h3> \n<p>首先执行 <em>yarn dev</em> 启动服务，在浏览器控制台输出 env 的值：</p> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/06/1e7dd2c1-439a-4c6d-b5ee-a57eb4bd6965.jpeg\" alt=\"image-20221006002025067\" style=\"zoom: 67%\"> \n<p>可以看出 <em>import.mata.env</em> 中默认包括五个内置环境变量：</p> \n<p>MODE：应用的运行模式。由于我们是通过 <em>yarn dev</em> 启动服务，而 <em>yarn dev</em> 本质是执行 <em>vite</em> 启动，未显式执行 <em>mode</em>，故 MODE 的值为 <em>development</em>；</p> \n<p>BASE_URL：部署应用时的基本 URL，在 vite 的配置文件 <em>vite.config.ts</em> 中的 <em>base</em> 属性指定；</p> \n<p>PROD：是否是生产环境（即是否通过 <em>vite build</em> 构建）</p> \n<p>DEV：是否是开发环境（即是否通过 <em>vite</em> 启动服务运行）</p> \n<p>SSR：是否是服务端渲染模式。</p> \n<h3 id=\"12-production\">1.2 production</h3> \n<p>首先执行 <em>yarn build</em> 打包（本质上是执行 <em>vite build</em>），打包完成后通过 <em>yarn preview</em> 对打包结果进行预览。访问预览地址，在浏览器控制塔输出如下：</p> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/06/ad3bf027-4e78-4cfd-8940-4b4affd18c12.jpeg\" alt=\"image-20221006002902362\" style=\"zoom: 67%\"> \n<p>可以看出模式为 <em>production</em>，非开发模式，是生产模式。</p> \n<h3 id=\"13-指定模式\">1.3 指定模式</h3> \n<p>修改 <em>package.json</em> 中的 <em>scripts</em> 命令，分别为开发和打包指定三种模式：dev、uat、prod。指定模式只需要在命令后通过参数 <em>--mode</em> 指定即可。</p> \n<pre><code class=\"language-json\">\"scripts\": {\n  \"dev\": \"yarn dev:dev\",\n  \"dev:dev\": \"vite --mode dev\",\n  \"dev:uat\": \"vite --mode uat\",\n  \"dev:prod\": \"vite --mode prod\",\n  \"build:dev\": \"vue-tsc --noEmit &amp;&amp; vite build --mode dev\",\n  \"build:uat\": \"vue-tsc --noEmit &amp;&amp; vite build --mode uat\",\n  \"build:prod\": \"vue-tsc --noEmit &amp;&amp; vite build --mode prod\",\n  \"preview\": \"vite preview\"\n},\n</code></pre> \n<p>执行 <em>yarn dev:dev</em>，浏览器输出 MODE： <em>dev</em>；</p> \n<p>执行 <em>yarn dev:uat</em>，浏览器输出 MODE： <em>uat</em>；</p> \n<p>执行 <em>yarn dev:prod</em>，浏览器输出 MODE： <em>prod</em>；</p> \n<p>接下来依次通过 <em>build:xxx</em> 先打包后再通过 <em>preview</em> 预览打包，结果与上面一致，浏览器输出的 MODE 与命令中 <em>--mode</em> 指定的值一致。</p> \n<h2 id=\"2-环境文件env\">2 环境文件（.env）</h2> \n<p>Vite 使用 <em>dotenv</em> 从 <em>环境文件目录</em> 中加载环境文件，默认情况下，环境文件目录为项目的根目录，即把环境文件放在项目根目录下。在 vite 中，可以通过配置 <em>envDir</em> 属性指定环境文件目录。</p> \n<h3 id=\"21-指定环境文件目录\">2.1 指定环境文件目录</h3> \n<p>在项目根目录下创建目录 <em>env</em>，用于存放所有的环境文件。</p> \n<p>在 <em>vite.config.ts</em> 中添加 <em>envDir</em> 属性指定环境文件目录为 <em>env</em>：</p> \n<pre><code class=\"language-typescript\">...\nexport default defineConfig({\n  ...\n  envDir: path.resolve(__dirname, \'./env\')\n})\n</code></pre> \n<h3 id=\"22-添加环境文件\">2.2 添加环境文件</h3> \n<p>环境文件命名如下：</p> \n<pre><code>.env                # 所有情况下都会加载\n.env.local          # 所有情况下都会加载，但会被 git 忽略\n.env.[mode]         # 只在指定模式下加载\n.env.[mode].local   # 只在指定模式下加载，但会被 git 忽略\n</code></pre> \n<p>不同环境的变量可以定义在 <em>.env.[mode]</em> 文件中，如 <em>.env.dev</em>、<em>.env.prod</em> 等，如果 <em>.env</em> 文件和 <em>.env.[mode]</em> 中有相同的 key，后者定义的值会覆盖前者。</p> \n<p>这里咱们以三个环境为例编写 demo，分别是：</p> \n<ul> \n <li>开发环境，mode 为 <em>dev</em>，文件名为 <em>.env.dev</em></li> \n <li>测试环境，mode 为 <em>uat</em>，文件名为 <em>.env.uat</em></li> \n <li>生产环境，mode 为 <em>prod</em>，文件名为 <em>.env.prod</em></li> \n</ul> \n<p>在上面指定的环境文件目录 <em>env</em> 下创建上面三个文件，以及所有情况下都会加载的 <em>.env</em> 文件。四个文件内容如下：</p> \n<p><em>.env</em> 文件</p> \n<pre><code>VITE_BASE_API=/api\nVITE_APP_NAME=\'demo app\'\nDEMO_STR=hello\n</code></pre> \n<p><em>.env.dev</em> 文件</p> \n<pre><code>VITE_BASE_API=/dev-api\n</code></pre> \n<p><em>.env.uat</em> 文件</p> \n<pre><code>VITE_BASE_API=/uat-api\n</code></pre> \n<p><em>.env.prod</em> 文件</p> \n<pre><code>VITE_BASE_API=/prod-api\n</code></pre> \n<p>四个文件都定义了变量 <em>VITE_BASE_API</em>，<em>.env</em> 中还额外定义了 <em>VITE_APP_NAME</em> 和 <em>DEMO_STR</em> 两个变量。</p> \n<p>使用 <em>yarn dev:dev</em> 启动服务，或者先使用 <em>yarn build:dev</em> 打包，再通过 <em>yarn preview</em> 预览打包结果，浏览器中都会输出 <em>VITE_BASE_API</em> 和 <em>VITE_APP_NAME</em> 的值。<em>VITE_BASE_API</em> 值为 <em>.env.dev</em> 中定义的 <em>/dev-api</em>，<em>VITE_APP_NAME</em> 值为 <em>.env</em> 中定义的 <em>demo app</em>，但是 <em>.env</em> 中定义的 <em>DEMO_STR</em> 不会输出。由此可以看出：</p> \n<ol> \n <li>无论是哪种模式，<em>.env</em> 文件都会被加载；</li> \n <li>如果 <em>.env.[mode]</em> 和 <em>.env</em> 中有相同的 key，对应模式的环境文件中的值会覆盖 <em>.env</em> 对应 key 的值；</li> \n <li>环境变量需要以 <em>VITE_</em> 开头才会暴露到 <em>import.meta.env</em> 中。</li> \n</ol> \n<p>有兴趣的朋友可以再添加 <em>.env.dev.local</em> 文件进行测试，<em>.env.[mode].local</em> 优先级最高。</p> \n<h2 id=\"3-typescript-提示\">3 TypeScript 提示</h2> \n<p>我使用的 IDE 是 WebStorm，之前在 <em>main.ts</em> 中将 <em>import.meta.env</em> 赋值给变量 <em>env</em>：</p> \n<pre><code class=\"language-typescript\">const env = import.meta.env\n</code></pre> \n<p>输入 <em>env.</em>，WebStorm会有下图中的提示：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/7f160b12-ae0c-4458-abb2-20c64d61fc71.jpeg\" alt=\"image-20221006110746181\" loading=\"lazy\"></p> \n<p>但是没有提示我们添加的环境变量。可以添加 <em>env.d.ts</em> 解决。在 <em>src</em> 目录下创建文件 <em>env.d.ts</em>，文件内容如下：</p> \n<pre><code class=\"language-typescript\">/// &lt;reference types=\"vite/client\" /&gt;\n\ninterface ImportMetaEnv {\n  readonly VITE_BASE_API: string;\n  readonly VITE_APP_NAME: string;\n}\n\n// eslint-disable-next-line no-unused-vars\ninterface ImportMeta {\n  readonly env: ImportMetaEnv\n}\n</code></pre> \n<p>在 ImportMetaEnv 中添加上环境文件中定义的变量即可。</p> \n<p>此时再次在 main.ts 中输入 <em>env.</em>，IDEA便可以有正确的代码提示，并且可以获取该变量的类型：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/09a85abe-c8dc-4856-a758-fa9c6d91ca43.jpeg\" alt=\"image-20221006111522409\" loading=\"lazy\"></p> \n<h2 id=\"4-补充说明\">4 补充说明</h2> \n<p>在基于 <em>vue-cli（webpack）</em> 的项目中获取环境变量是通过 <em>process.env.xxx</em> 的方式，如果不进行配置，在浏览器中会报错，提示 <em>process is undefine</em>。于是我按照网上的方式，在 vite.config.ts 中首先通过 vite 提供的 <em>loadEnv</em> 函数加载环境变量，然后在导出对象中添加 <em>define</em> 属性，在 <em>define</em> 中将 <em>loadEnv</em> 返回的结果赋值给 <em>process.env</em>，如下：</p> \n<pre><code class=\"language-typescript\">define: {\n  \'process.env\': loadEnv(env.mode, process.cwd(), \'\')\n}\n</code></pre> \n<p>通过这种方式，在开发模式下（vite 启动服务）,可以正常获取到环境变量，甚至环境变量不要求以 <em>VITE_</em> 开头。但是使用 <em>vite build</em> 打包一直失败，在使用了 <em>process.env</em> 提示 <em>parse error</em>，到现在也不知道怎么处理。如果知道怎么处理的伙伴欢迎留言。</p> \n<p>不过个人更推荐按照官方的方式，使用 <em>import.meta.env</em> 。</p> \n<p>文中 demo 在 github 上搜索 <em>vue3-vite-archetype</em> 获取，<em>main</em> 分支可以直接 <em>yarn dev</em> 启动运行； <em>template</em> 分支是 <em>yyg-cli</em> 执行 <em>yyg create</em> 创建项目时拉取的模板。你也可以先执行 <em>npm install -g yyg-cli</em> 安装 <em>yyg-cli</em> 脚手架工具，然后通过 <em>yyg create xxx</em> 创建项目，创建后的项目包含了 <em>vue3 vite</em> 的全部demo。</p>',100,NULL,0,'https://www.cnblogs.com/youyacoder/p/16758042.html','2022-10-06 23:57:17'),(12,'HBase1.4.6安装搭建及shell命令使用',NULL,NULL,0,0,'<h2 id=\"hbase146安装搭建\">HBase1.4.6安装搭建</h2> \n<p></p>\n<div class=\"toc\">\n <div class=\"toc-container-header\">\n  目录\n </div>\n <ul>\n  <li><a href=\"#hbase146安装搭建\" rel=\"noopener\">HBase1.4.6安装搭建</a>\n   <ul>\n    <li><a href=\"#一前期准备hadoopzookeeperjdk\" rel=\"noopener\">一、前期准备（Hadoop,zookeeper,jdk）</a></li>\n    <li><a href=\"#搭建hbase\" rel=\"noopener\">搭建Hbase</a>\n     <ul>\n      <li><a href=\"#1上传解压\" rel=\"noopener\">1、上传解压</a></li>\n      <li><a href=\"#2配置环境变量\" rel=\"noopener\">2、配置环境变量</a></li>\n      <li><a href=\"#3修改hbase-envsh文件\" rel=\"noopener\">3、修改hbase-env.sh文件</a></li>\n      <li><a href=\"#4修改hbase-sitexml文件\" rel=\"noopener\">4、修改hbase-site.xml文件</a></li>\n      <li><a href=\"#5修改regionservers文件\" rel=\"noopener\">5、修改regionservers文件</a></li>\n      <li><a href=\"#6同步到所有节点如果是伪分布式不需要同步\" rel=\"noopener\">6、同步到所有节点（如果是伪分布式不需要同步）</a></li>\n      <li><a href=\"#7启动hbase集群--在master上执行\" rel=\"noopener\">7、启动hbase集群 ， 在master上执行</a></li>\n      <li><a href=\"#8验证hbase\" rel=\"noopener\">8、验证hbase</a></li>\n      <li><a href=\"#9关闭集群的命令\" rel=\"noopener\">9、关闭集群的命令</a></li>\n     </ul></li>\n    <li><a href=\"#二启动顺序\" rel=\"noopener\">二、启动顺序</a></li>\n    <li><a href=\"#三重置hbase\" rel=\"noopener\">三、重置hbase</a>\n     <ul>\n      <li>\n       <ul>\n        <li><a href=\"#1关闭hbase集群\" rel=\"noopener\">1、关闭hbase集群</a></li>\n        <li><a href=\"#2删除数据---hdfs\" rel=\"noopener\">2、删除数据 hdfs</a></li>\n        <li><a href=\"#3删除元数据-zk\" rel=\"noopener\">3、删除元数据 zk</a></li>\n        <li><a href=\"#4重新启动hbase\" rel=\"noopener\">4、重新启动hbase</a></li>\n        <li><a href=\"#时间同步\" rel=\"noopener\">时间同步</a></li>\n       </ul></li>\n     </ul></li>\n   </ul></li>\n  <li><a href=\"#hbase-shell\" rel=\"noopener\">hbase shell</a>\n   <ul>\n    <li><a href=\"#1help命令\" rel=\"noopener\">1、help命令</a></li>\n    <li><a href=\"#2general-类\" rel=\"noopener\">2、general 类</a>\n     <ul>\n      <li><a href=\"#21显示集群状态status\" rel=\"noopener\">2.1显示集群状态status</a></li>\n      <li><a href=\"#22-查询数据库版本version\" rel=\"noopener\">2.2 查询数据库版本version</a></li>\n      <li><a href=\"#23显示当前用户与组-whoami\" rel=\"noopener\">2.3显示当前用户与组 whoami</a></li>\n      <li><a href=\"#24查看操作表的命令table_help\" rel=\"noopener\">2.4查看操作表的命令table_help</a></li>\n      <li><a href=\"#25退出hbase-shell-exit\" rel=\"noopener\">2.5退出HBase Shell exit</a></li>\n     </ul></li>\n    <li><a href=\"#3ddl相关\" rel=\"noopener\">3、DDL相关</a>\n     <ul>\n      <li><a href=\"#31创建表create\" rel=\"noopener\">3.1创建表create</a></li>\n      <li><a href=\"#32修改添加删除表结构schema-alter\" rel=\"noopener\">3.2修改(添加、删除)表结构Schema alter</a>\n       <ul>\n        <li><a href=\"#321添加一个列簇\" rel=\"noopener\">3.2.1 添加一个列簇</a></li>\n        <li><a href=\"#322删除一个列簇\" rel=\"noopener\">3.2.2 删除一个列簇</a></li>\n        <li><a href=\"#323修改列族的属性\" rel=\"noopener\">3.2.3 修改列族的属性</a></li>\n       </ul></li>\n      <li><a href=\"#33获取表的描述describe\" rel=\"noopener\">3.3 获取表的描述describe</a></li>\n      <li><a href=\"#34列举所有表list\" rel=\"noopener\">3.4 列举所有表list</a></li>\n      <li><a href=\"#35表是否存在exists\" rel=\"noopener\">3.5 表是否存在exists</a></li>\n      <li><a href=\"#36启用表enable和禁用表disable\" rel=\"noopener\">3.6 启用表enable和禁用表disable</a></li>\n      <li><a href=\"#37禁用满足正则表达式的所有表disable_all\" rel=\"noopener\">3.7 禁用满足正则表达式的所有表disable_all</a></li>\n      <li><a href=\"#38启用满足正则表达式的所有表enable_all\" rel=\"noopener\">3.8 启用满足正则表达式的所有表enable_all</a></li>\n      <li><a href=\"#39删除表drop\" rel=\"noopener\">3.9 删除表drop</a></li>\n      <li><a href=\"#310删除满足正则表达式的所有表drop_all\" rel=\"noopener\">3.10 删除满足正则表达式的所有表drop_all</a></li>\n      <li><a href=\"#311获取某个表赋值给一个变量-get_table\" rel=\"noopener\">3.11 获取某个表赋值给一个变量 get_table</a></li>\n      <li><a href=\"#312获取rowkey所在的区-locate_region\" rel=\"noopener\">3.12 获取rowKey所在的区 locate_region</a></li>\n      <li><a href=\"#313显示hbase所支持的所有过滤器show_filters\" rel=\"noopener\">3.13 显示hbase所支持的所有过滤器show_filters</a></li>\n     </ul></li>\n    <li><a href=\"#4namespace\" rel=\"noopener\">4、 namespace</a>\n     <ul>\n      <li><a href=\"#41列举命名空间-list_namespace\" rel=\"noopener\">4.1 列举命名空间 list_namespace</a></li>\n      <li><a href=\"#42获取命名空间描述-describe_namespace\" rel=\"noopener\">4.2 获取命名空间描述 describe_namespace</a></li>\n      <li><a href=\"#43查看命名空间下的所有表-list_namespace_tables\" rel=\"noopener\">4.3 查看命名空间下的所有表 list_namespace_tables</a></li>\n      <li><a href=\"#44创建命名空间create_namespace\" rel=\"noopener\">4.4 创建命名空间create_namespace</a></li>\n      <li><a href=\"#45删除命名空间drop_namespace\" rel=\"noopener\">4.5 删除命名空间drop_namespace</a></li>\n     </ul></li>\n    <li><a href=\"#5dml\" rel=\"noopener\">5、DML</a>\n     <ul>\n      <li><a href=\"#51插入或者修改数据put\" rel=\"noopener\">5.1 插入或者修改数据put</a></li>\n      <li><a href=\"#52全表扫描scan\" rel=\"noopener\">5.2 全表扫描scan</a></li>\n      <li><a href=\"#53-获取数据get\" rel=\"noopener\">5.3 获取数据get</a></li>\n      <li><a href=\"#54删除某个列族中的某个列delete\" rel=\"noopener\">5.4 删除某个列族中的某个列delete</a></li>\n      <li><a href=\"#55-删除某行数据deleteall\" rel=\"noopener\">5.5 删除某行数据deleteall</a></li>\n      <li><a href=\"#56清空整个表的数据truncate\" rel=\"noopener\">5.6 清空整个表的数据truncate</a></li>\n      <li><a href=\"#57自增incr\" rel=\"noopener\">5.7 自增incr</a></li>\n      <li><a href=\"#58计数器get_counter\" rel=\"noopener\">5.8 计数器get_counter</a></li>\n      <li><a href=\"#59修饰词\" rel=\"noopener\">5.9 修饰词</a>\n       <ul>\n        <li><a href=\"#1修饰词\" rel=\"noopener\">1、修饰词</a></li>\n        <li><a href=\"#2timestamp-指定时间戳\" rel=\"noopener\">2、TIMESTAMP 指定时间戳</a></li>\n        <li><a href=\"#3versions\" rel=\"noopener\">3、VERSIONS</a></li>\n        <li><a href=\"#4startrow\" rel=\"noopener\">4、STARTROW</a></li>\n        <li><a href=\"#5stoprow-截止到stoprow行stoprow行之前的数据不包括stoprow这行数据\" rel=\"noopener\">5、STOPROW ：截止到STOPROW行，STOPROW行之前的数据，不包括STOPROW这行数据</a></li>\n        <li><a href=\"#6limit-返回的行数\" rel=\"noopener\">6、LIMIT 返回的行数</a></li>\n       </ul></li>\n      <li><a href=\"#510filter条件过滤器\" rel=\"noopener\">5.10 FILTER条件过滤器</a>\n       <ul>\n        <li><a href=\"#1valuefilter-值过滤器\" rel=\"noopener\">1、ValueFilter 值过滤器</a></li>\n        <li><a href=\"#2columnprefixfilter-列名前缀过滤器\" rel=\"noopener\">2、ColumnPrefixFilter 列名前缀过滤器</a></li>\n        <li><a href=\"#3rowkey字典排序\" rel=\"noopener\">3、rowKey字典排序</a></li>\n       </ul></li>\n     </ul></li>\n   </ul></li>\n </ul>\n</div>\n<p></p> \n<h3 id=\"一前期准备hadoopzookeeperjdk\">一、前期准备（Hadoop,zookeeper,jdk）</h3> \n<blockquote> \n <p>启动hadoop</p> \n</blockquote> \n<pre><code class=\"language-shell\">start-all.sh\n</code></pre> \n<blockquote> \n <p>验证</p> \n</blockquote> \n<pre><code class=\"language-shell\">http://master:50070\n</code></pre> \n<blockquote> \n <p>启动zookeeper（三台分别启动）</p> \n</blockquote> \n<pre><code class=\"language-shell\">zkServer.sh start\n</code></pre> \n<blockquote> \n <p>检查状态</p> \n</blockquote> \n<pre><code>zkServer.sh status\n</code></pre> \n<h3 id=\"搭建hbase\">搭建Hbase</h3> \n<h4 id=\"1上传解压\">1、上传解压</h4> \n<pre><code class=\"language-shell\">tar -zxvf hbase-1.4.6-bin.tar.gz\n</code></pre> \n<h4 id=\"2配置环境变量\">2、配置环境变量</h4> \n<pre><code class=\"language-shell\">export HBASE_HOME=/usr/local/soft/hbase-1.4.6\n\n$HBASE_HOME/bin\n</code></pre> \n<blockquote> \n <p>source /etc/profile</p> \n</blockquote> \n<h4 id=\"3修改hbase-envsh文件\">3、修改hbase-env.sh文件</h4> \n<blockquote> \n <p>增加java配置</p> \n</blockquote> \n<pre><code class=\"language-shell\">export JAVA_HOME=/usr/local/soft/jdk1.8.0_171\n</code></pre> \n<blockquote> \n <p>关闭默认zk配置（原本是注释的，放开修改false）</p> \n</blockquote> \n<pre><code class=\"language-shell\">export HBASE_MANAGES_ZK=false\n</code></pre> \n<h4 id=\"4修改hbase-sitexml文件\">4、修改hbase-site.xml文件</h4> \n<pre><code class=\"language-xml\">   &lt;property&gt;&nbsp;\n      &lt;name&gt;hbase.rootdir&lt;/name&gt;&nbsp;\n      &lt;value&gt;hdfs://master:9000/hbase&lt;/value&gt;&nbsp;\n   &lt;/property&gt;&nbsp;\n   &lt;property&gt;&nbsp;\n      &lt;name&gt;hbase.cluster.distributed&lt;/name&gt;&nbsp;\n      &lt;value&gt;true&lt;/value&gt;&nbsp;\n   &lt;/property&gt;&nbsp;\n   &lt;property&gt;&nbsp;\n      &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt;&nbsp;\n      &lt;value&gt;node1,node2,master&lt;/value&gt;&nbsp;\n   &lt;/property&gt;&nbsp;\n</code></pre> \n<h4 id=\"5修改regionservers文件\">5、修改regionservers文件</h4> \n<blockquote> \n <p>如果是伪分布式版本，增加master即可</p> \n</blockquote> \n<pre><code class=\"language-xml\">node1\nnode2\n</code></pre> \n<h4 id=\"6同步到所有节点如果是伪分布式不需要同步\">6、同步到所有节点（如果是伪分布式不需要同步）</h4> \n<pre><code class=\"language-shell\">scp -r hbase-1.4.6 node1:`pwd`\nscp -r hbase-1.4.6 node2:`pwd`\n</code></pre> \n<h4 id=\"7启动hbase集群--在master上执行\">7、启动hbase集群 ， 在master上执行</h4> \n<pre><code class=\"language-shell\">start-hbase.sh\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/d6681090-8532-40e5-a357-9526b66b7c10.png\" alt=\"image-20220608224430921\" loading=\"lazy\"></p> \n<h4 id=\"8验证hbase\">8、验证hbase</h4> \n<pre><code>http://master:16010\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/f43c4d5b-f397-48de-82ee-015e2c0cce2a.png\" alt=\"image-20220608224544266\" loading=\"lazy\"></p> \n<blockquote> \n <p>hbase日志文件所在的目录: /usr/local/soft/hbase-1.7.1/logs</p> \n</blockquote> \n<h4 id=\"9关闭集群的命令\">9、关闭集群的命令</h4> \n<pre><code class=\"language-shell\">stop-hbase.sh\n</code></pre> \n<h3 id=\"二启动顺序\">二、启动顺序</h3> \n<pre><code class=\"language-shell\">启动顺序\nHadoop及hbase集群启动顺序 zookeepeer -&gt; hadoop -&gt; hbase\n\n停止顺序\nHadoop及hbase集群关闭顺序 hbase -&gt; hadoop -&gt; zookeepeer\n</code></pre> \n<h3 id=\"三重置hbase\">三、重置hbase</h3> \n<h5 id=\"1关闭hbase集群\">1、关闭hbase集群</h5> \n<pre><code class=\"language-shell\">   1)杀死进程\n   \n   2)stop-hbase.sh\n</code></pre> \n<h5 id=\"2删除数据---hdfs\">2、删除数据 hdfs</h5> \n<pre><code class=\"language-shell\">hdfs dfs -rmr /hbase\n</code></pre> \n<h5 id=\"3删除元数据-zk\">3、删除元数据 zk</h5> \n<pre><code class=\"language-shell\">   zkCli.sh\n   rmr /hbase\n</code></pre> \n<h5 id=\"4重新启动hbase\">4、重新启动hbase</h5> \n<pre><code class=\"language-shell\">   start-hbase.sh\n</code></pre> \n<h5 id=\"时间同步\">时间同步</h5> \n<pre><code class=\"language-shell\">yum install ntp -y\n\nntpdate -u time.windows.com\n</code></pre> \n<h2 id=\"hbase-shell\">hbase shell</h2> \n<table> \n <thead> \n  <tr> \n   <th>命名</th> \n   <th>描述</th> \n   <th>语法</th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td>help ‘命名名’</td> \n   <td>查看命令的使用描述</td> \n   <td>help ‘命令名’</td> \n  </tr> \n  <tr> \n   <td>whoami</td> \n   <td>我是谁</td> \n   <td>whoami</td> \n  </tr> \n  <tr> \n   <td>version</td> \n   <td>返回hbase版本信息</td> \n   <td>version</td> \n  </tr> \n  <tr> \n   <td>status</td> \n   <td>返回hbase集群的状态信息</td> \n   <td>status</td> \n  </tr> \n  <tr> \n   <td>table_help</td> \n   <td>查看如何操作表</td> \n   <td>table_help</td> \n  </tr> \n  <tr> \n   <td><strong>create</strong></td> \n   <td>创建表</td> \n   <td>create ‘表名’, ‘列族名1’, ‘列族名2’, ‘列族名N’</td> \n  </tr> \n  <tr> \n   <td><strong>alter</strong></td> \n   <td>修改列族</td> \n   <td>添加一个列族：alter ‘表名’, ‘列族名’ <br>删除列族：alter ‘表名’, {NAME=&gt; ‘列族名’, METHOD=&gt; ‘delete’}</td> \n  </tr> \n  <tr> \n   <td>describe</td> \n   <td>显示表相关的详细信息</td> \n   <td>describe ‘表名’</td> \n  </tr> \n  <tr> \n   <td><strong>list</strong></td> \n   <td>列出hbase中存在的所有表</td> \n   <td>list</td> \n  </tr> \n  <tr> \n   <td>exists</td> \n   <td>测试表是否存在</td> \n   <td>exists ‘表名’</td> \n  </tr> \n  <tr> \n   <td><strong>put</strong></td> \n   <td>添加或修改的表的值</td> \n   <td>put ‘表名’, ‘行键’, ‘列族名’, ‘列值’ <br>put ‘表名’, ‘行键’, ‘列族名:列名’, ‘列值’</td> \n  </tr> \n  <tr> \n   <td><strong>scan</strong></td> \n   <td>通过对表的扫描来获取对用的值</td> \n   <td>scan ‘表名’<br>扫描某个列族： scan ‘表名’, {COLUMN=&gt;‘列族名’}<br>扫描某个列族的某个列： scan ‘表名’, {COLUMN=&gt;‘列族名:列名’}<br>查询同一个列族的多个列： scan ‘表名’, {COLUMNS =&gt; [ ‘列族名1:列名1’, ‘列族名1:列名2’, …]}</td> \n  </tr> \n  <tr> \n   <td><strong>get</strong></td> \n   <td>获取行或单元（cell）的值</td> \n   <td>get ‘表名’, ‘行键’ <br>get ‘表名’, ‘行键’, ‘列族名’</td> \n  </tr> \n  <tr> \n   <td>count</td> \n   <td>统计表中行的数量</td> \n   <td>count ‘表名’</td> \n  </tr> \n  <tr> \n   <td>incr</td> \n   <td>增加指定表行或列的值</td> \n   <td>incr ‘表名’, ‘行键’, ‘列族:列名’, 步长值</td> \n  </tr> \n  <tr> \n   <td>get_counter</td> \n   <td>获取计数器</td> \n   <td>get_counter ‘表名’, ‘行键’, ‘列族:列名’</td> \n  </tr> \n  <tr> \n   <td><strong>delete</strong></td> \n   <td>删除指定对象的值（可以为表，行，列对应的值，另外也可以指定时间戳的值）</td> \n   <td>删除列族的某个列： delete ‘表名’, ‘行键’, ‘列族名:列名’</td> \n  </tr> \n  <tr> \n   <td>deleteall</td> \n   <td>删除指定行的所有元素值</td> \n   <td>deleteall ‘表名’, ‘行键’</td> \n  </tr> \n  <tr> \n   <td><strong>truncate</strong></td> \n   <td>重新创建指定表</td> \n   <td>truncate ‘表名’</td> \n  </tr> \n  <tr> \n   <td><strong>enable</strong></td> \n   <td>使表有效</td> \n   <td>enable ‘表名’</td> \n  </tr> \n  <tr> \n   <td>is_enabled</td> \n   <td>是否启用</td> \n   <td>is_enabled ‘表名’</td> \n  </tr> \n  <tr> \n   <td><strong>disable</strong></td> \n   <td>使表无效</td> \n   <td>disable ‘表名’</td> \n  </tr> \n  <tr> \n   <td><strong>is_disabled</strong></td> \n   <td>是否无效</td> \n   <td>is_disabled ‘表名’</td> \n  </tr> \n  <tr> \n   <td><strong>drop</strong></td> \n   <td>删除表</td> \n   <td>drop的表必须是disable的 <br>disable ‘表名’ <br>drop ‘表名’</td> \n  </tr> \n  <tr> \n   <td>shutdown</td> \n   <td>关闭hbase集群（与exit不同）</td> \n   <td></td> \n  </tr> \n  <tr> \n   <td>tools</td> \n   <td>列出hbase所支持的工具</td> \n   <td></td> \n  </tr> \n  <tr> \n   <td><strong>exit</strong></td> \n   <td>退出hbase shell</td> \n   <td></td> \n  </tr> \n </tbody> \n</table> \n<p>HBase Shell 是官方提供的一组命令，用于操作HBase。如果配置了HBase的<strong>环境变量</strong>了，就可以知己在命令行中输入hbase shell 命令进入命令行。</p> \n<pre><code class=\"language-shell\">hbase shell\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/bf93242b-02c7-483c-949b-228ba205d09f.png\" alt=\"image-20220608225844374\" loading=\"lazy\"></p> \n<blockquote> \n <p>在hbase中如果输入错误，按住ctrl+退格 才能删除</p> \n</blockquote> \n<h3 id=\"1help命令\">1、help命令</h3> \n<blockquote> \n <p>可以通过 <code>help \'命名名称\'</code>来查看<strong>命令行</strong>的具体使用，包括命令的作用和用法。<br> 通过help ‘hbase’ 命名来查看hbase shell 支持的所有命令，hbase将命令进行分组，其中ddl、dml使用较多。</p> \n</blockquote> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/609bf37c-4bfa-4bb7-89c1-02f05d67bdb9.png\" alt=\"image-20220608230009607\" loading=\"lazy\"></p> \n<pre><code class=\"language-shell\">help \'list\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/7a6cd786-5c2c-4a09-ab87-22fb2c329b2f.png\" alt=\"image-20220608230050274\" loading=\"lazy\"></p> \n<h3 id=\"2general-类\">2、general 类</h3> \n<h4 id=\"21显示集群状态status\">2.1显示集群状态status</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/f2337233-e119-409d-84c9-b77216627836.png\" alt=\"image-20220608230310182\" loading=\"lazy\"></p> \n<h4 id=\"22-查询数据库版本version\">2.2 查询数据库版本version</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/ab10d4e8-d5eb-4b16-8022-ef754b807825.png\" alt=\"image-20220608230440754\" loading=\"lazy\"></p> \n<h4 id=\"23显示当前用户与组-whoami\">2.3显示当前用户与组 whoami</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/fff916ae-f27d-4dae-af47-d19e2f8367ed.png\" alt=\"image-20220608230519490\" loading=\"lazy\"></p> \n<h4 id=\"24查看操作表的命令table_help\">2.4查看操作表的命令table_help</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/579bd259-8073-4797-af5d-b3a27d70bb8d.png\" alt=\"image-20220608230553346\" loading=\"lazy\"></p> \n<h4 id=\"25退出hbase-shell-exit\">2.5退出HBase Shell exit</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/89aa09ce-e018-49e7-ae05-93cb79239956.png\" alt=\"image-20220608230623889\" loading=\"lazy\"></p> \n<h3 id=\"3ddl相关\">3、DDL相关</h3> \n<h4 id=\"31创建表create\">3.1创建表create</h4> \n<blockquote> \n <p>注意：创建表时只需要指定列族名称，不需要指定列名。</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 语法\ncreate \'表名\', {NAME =&gt; \'列族名1\'}, {NAME =&gt; \'列族名2\'}, {NAME =&gt; \'列族名3\'}\n# 此种方式是上上面的简写方式，使用上面方式可以为列族指定更多的属性，如VERSIONS、TTL、BLOCKCACHE、CONFIGURATION等属性\ncreate \'表名\', \'列族名1\', \'列族名2\', \'列族名3\'\n\ncreate \'表名\', {NAME =&gt; \'列族名1\', VERSIONS =&gt; 版本号, TTL =&gt; 过期时间, BLOCKCACHE =&gt; true}\n\n\n# 示例\ncreate \'tbl_user\', \'info\', \'detail\'\ncreate \'t1\', {NAME =&gt; \'f1\', VERSIONS =&gt; 1, TTL =&gt; 2592000, BLOCKCACHE =&gt; true}\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/dd22803c-af47-4e22-80d2-9c4c920f57d7.png\" alt=\"image-20220608230826425\" loading=\"lazy\"></p> \n<h4 id=\"32修改添加删除表结构schema-alter\">3.2修改(添加、删除)表结构Schema alter</h4> \n<h5 id=\"321添加一个列簇\">3.2.1 添加一个列簇</h5> \n<pre><code class=\"language-sql\"># 语法 \nalter \'表名\', \'列族名\'\n\n# 示例\nalter \'tbl_user\', \'address\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/5ac699b7-befd-4db3-8c85-e88f4b28165b.png\" alt=\"image-20220608230938763\" loading=\"lazy\"></p> \n<h5 id=\"322删除一个列簇\">3.2.2 删除一个列簇</h5> \n<pre><code class=\"language-sql\"># 语法 \nalter \'表名\', {NAME=&gt; \'列族名\', METHOD=&gt; \'delete\'}\n\n# 示例\nalter \'tbl_user\', {NAME=&gt; \'address\', METHOD=&gt; \'delete\'}\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/d029528d-dbf6-457f-b35c-1c9e6f4ecfb5.png\" alt=\"image-20220608231027899\" loading=\"lazy\"></p> \n<h5 id=\"323修改列族的属性\">3.2.3 修改列族的属性</h5> \n<blockquote> \n <p>可以修改列族的VERSIONS、IN_MEMORY</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 修改f1列族的版本为5\nalter \'t1\', NAME =&gt; \'f1\', VERSIONS =&gt; 5\n\n# 修改多个列族，修改f2为内存，版本号为5\nalter \'t1\', \'f1\', {NAME =&gt; \'f2\', IN_MEMORY =&gt; true}, {NAME =&gt; \'f3\', VERSIONS =&gt; 5}\n\n# 也可以修改table-scope属性，例如MAX_FILESIZE, READONLY,MEMSTORE_FLUSHSIZE, DEFERRED_LOG_FLUSH等。\n# 例如，修改region的最大大小为128MB：\nalter \'t1\', MAX_FILESIZE =&gt; \'134217728\'\n</code></pre> \n<h4 id=\"33获取表的描述describe\">3.3 获取表的描述describe</h4> \n<pre><code class=\"language-sql\"># 语法 \ndescribe \'表名\'\n\n# 示例\ndescribe \'tbl_user\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/0b677cf8-bfae-453d-9955-e82bd941e119.png\" alt=\"image-20220608231308673\" loading=\"lazy\"></p> \n<h4 id=\"34列举所有表list\">3.4 列举所有表list</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/99568dff-90fe-4935-8148-896cea2167f9.png\" alt=\"image-20220608231334575\" loading=\"lazy\"></p> \n<h4 id=\"35表是否存在exists\">3.5 表是否存在exists</h4> \n<pre><code class=\"language-sql\"># 语法 \nexists \'表名\'\n\n# 示例\nexists \'tbl_user\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/05d8343c-6820-417e-bd51-62040ef82c05.png\" alt=\"image-20220608231431898\" loading=\"lazy\"></p> \n<h4 id=\"36启用表enable和禁用表disable\">3.6 启用表enable和禁用表disable</h4> \n<blockquote> \n <p>通过enable和disable来启用/禁用这个表,相应的可以通过is_enabled和is_disabled来检查表是否被禁用。</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 语法\nenable \'表名\'\nis_enabled \'表名\'\n\ndisable \'表名\'\nis_disabled \'表名\'\n\n# 示例\ndisable \'tbl_user\'\nis_disabled \'tbl_user\'\n\nenable \'tbl_user\'\nis_enabled \'tbl_user\'\n</code></pre> \n<h4 id=\"37禁用满足正则表达式的所有表disable_all\">3.7 禁用满足正则表达式的所有表disable_all</h4> \n<ul> \n <li><code>.</code>匹配除“\\n”和\"\\r\"之外的任何单个字符</li> \n <li><code>*</code>匹配前面的子表达式任意次</li> \n</ul> \n<pre><code class=\"language-sql\"># 匹配以t开头的表名\ndisable_all \'t.*\'\n# 匹配指定命名空间ns下的以t开头的所有表\ndisable_all \'ns:t.*\'\n# 匹配ns命名空间下的所有表\ndisable_all \'ns:.*\'\n</code></pre> \n<h4 id=\"38启用满足正则表达式的所有表enable_all\">3.8 启用满足正则表达式的所有表enable_all</h4> \n<pre><code class=\"language-shell\">enable_all \'t.*\'\nenable_all \'ns:t.*\'\nenable_all \'ns:.*\'\n</code></pre> \n<h4 id=\"39删除表drop\">3.9 删除表drop</h4> \n<blockquote> \n <p>需要先禁用表，然后再删除表，启用的表是不允许删除的</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 语法\ndisable \'表名\'\ndrop \'表名\'\n\n# 示例\ndisable \'tbl_user\'\ndrop \'tbl_user\'\n</code></pre> \n<blockquote> \n <p>直接删除报错：</p> \n</blockquote> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/a1d13bbc-fa7a-4a62-a5d7-7eb5e9bf3688.png\" alt=\"image-20220608231641417\" loading=\"lazy\"></p> \n<blockquote> \n <p>先禁用后删除</p> \n</blockquote> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/3f0e981c-dc7c-40f2-bf04-2c89262648ab.png\" alt=\"image-20220608231726087\" loading=\"lazy\"></p> \n<h4 id=\"310删除满足正则表达式的所有表drop_all\">3.10 删除满足正则表达式的所有表drop_all</h4> \n<pre><code class=\"language-shell\">drop_all \'t.*\'\ndrop_all \'ns:t.*\'\ndrop_all \'ns:.*\'\n</code></pre> \n<h4 id=\"311获取某个表赋值给一个变量-get_table\">3.11 获取某个表赋值给一个变量 get_table</h4> \n<blockquote> \n <p>通过 var = get_table ‘表名’ 赋值给一个变量对象，然后对象.来调用，就像面向对象编程一样，通过对象.方法来调用，这种方式在操作某个表时就不必每次列举表名了。</p> \n</blockquote> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/ea210685-dc22-45fd-93f7-b626dfbd67c3.png\" alt=\"image-20220608232059349\" loading=\"lazy\"></p> \n<h4 id=\"312获取rowkey所在的区-locate_region\">3.12 获取rowKey所在的区 locate_region</h4> \n<pre><code class=\"language-shell\">locate_region \'表名\', \'行键\'\n</code></pre> \n<h4 id=\"313显示hbase所支持的所有过滤器show_filters\">3.13 显示hbase所支持的所有过滤器show_filters</h4> \n<blockquote> \n <p>过滤器用于get和scan命令中作为筛选数据的条件，类型关系型数据库中的where的作用</p> \n</blockquote> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/fb83f78d-b478-435d-8684-01410596bd12.png\" alt=\"image-20220608232227422\" loading=\"lazy\"></p> \n<h3 id=\"4namespace\">4、 namespace</h3> \n<blockquote> \n <p><strong>hbase中没有数据库的概念 , 可以使用namespace来达到数据库分类别管理表的作用</strong></p> \n</blockquote> \n<h4 id=\"41列举命名空间-list_namespace\">4.1 列举命名空间 list_namespace</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/b5bbb013-c186-4849-ba24-470612928ebc.png\" alt=\"image-20220608232407636\" loading=\"lazy\"></p> \n<h4 id=\"42获取命名空间描述-describe_namespace\">4.2 获取命名空间描述 describe_namespace</h4> \n<pre><code class=\"language-sql\">describe_namespace \'default\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/b62a3dd1-e5bc-43be-8a81-cba61baa0fe8.png\" alt=\"image-20220608232448689\" loading=\"lazy\"></p> \n<h4 id=\"43查看命名空间下的所有表-list_namespace_tables\">4.3 查看命名空间下的所有表 list_namespace_tables</h4> \n<pre><code class=\"language-sql\">list_namespace_tables \'default\'\n\nlist_namespace_tables \'hbase\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/46f52c00-5e5e-4f83-83b0-3def39a3cb84.png\" alt=\"image-20220608232555107\" loading=\"lazy\"></p> \n<h4 id=\"44创建命名空间create_namespace\">4.4 创建命名空间create_namespace</h4> \n<pre><code class=\"language-sql\">create_namespace \'bigdata17\'\n</code></pre> \n<h4 id=\"45删除命名空间drop_namespace\">4.5 删除命名空间drop_namespace</h4> \n<pre><code class=\"language-sql\">drop_namespace \'命名空间名称\'\n</code></pre> \n<h3 id=\"5dml\">5、DML</h3> \n<h4 id=\"51插入或者修改数据put\">5.1 插入或者修改数据put</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/aff78f20-4cee-44f6-a599-e1e443f55fbc.png\" alt=\"image-20220608232846139\" loading=\"lazy\"></p> \n<pre><code class=\"language-sql\"># 语法\n# 当列族中只有一个列时\'列族名:列名\'使用\'列族名\'\nput \'表名\', \'行键\', \'列族名\', \'列值\'\nput \'表名\', \'行键\', \'列族名:列名\', \'列值\'\n\n# 示例\n\n# 创建表\ncreate \'users\', \'info\', \'detail\', \'address\'\n\n# 第一行数据\nput \'users\', \'rk1001\', \'info:id\', \'1\'\nput \'users\', \'rk1001\', \'info:name\', \'张三\'\nput \'users\', \'rk1001\', \'info:age\', \'28\'\nput \'users\', \'rk1001\', \'detail:birthday\', \'1990-06-26\'\nput \'users\', \'rk1001\', \'detail:email\', \'abc@163.com\'\nput \'users\', \'rk1001\', \'detail:create_time\', \'2019-03-04 14:26:10\'\nput \'users\', \'rk1001\', \'address\', \'上海市\'\n\n# 第二行数据\nput \'users\', \'rk1002\', \'info:id\', \'2\'\nput \'users\', \'rk1002\', \'info:name\', \'李四\'\nput \'users\', \'rk1002\', \'info:age\', \'27\'\nput \'users\', \'rk1002\', \'detail:birthday\', \'1990-06-27\'\nput \'users\', \'rk1002\', \'detail:email\', \'xxx@gmail.com\'\nput \'users\', \'rk1002\', \'detail:create_time\', \'2019-03-05 14:26:10\'\nput \'users\', \'rk1002\', \'address\', \'北京市\'\n\n\n# 第三行数据\nput \'users\', \'rk1003\', \'info:id\', \'3\'\nput \'users\', \'rk1003\', \'info:name\', \'王五\'\nput \'users\', \'rk1003\', \'info:age\', \'26\'\nput \'users\', \'rk1003\', \'detail:birthday\', \'1990-06-28\'\nput \'users\', \'rk1003\', \'detail:email\', \'xyz@qq.com\'\nput \'users\', \'rk1003\', \'detail:create_time\', \'2019-03-06 14:26:10\'\nput \'users\', \'rk1003\', \'address\', \'杭州市\'\n</code></pre> \n<h4 id=\"52全表扫描scan\">5.2 全表扫描scan</h4> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\'\n\n# 示例\nscan \'users\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/26181e55-937e-4869-9672-c097b8c5afc8.png\" alt=\"image-20220608233212478\" loading=\"lazy\"></p> \n<blockquote> \n <p>扫描整个列簇</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\', {COLUMN=&gt;\'列族名\'}\n\n# 示例\nscan \'users\', {COLUMN=&gt;\'info\'}\n</code></pre> \n<blockquote> \n <p>扫描整个列簇的某个列</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\', {COLUMN=&gt;\'列族名:列名\'}\n\n# 示例\nscan \'users\', {COLUMN=&gt;\'info:age\'}\n</code></pre> \n<h4 id=\"53-获取数据get\">5.3 获取数据get</h4> \n<pre><code class=\"language-sql\"># 语法\nget \'表名\', \'行键\'\n\n# 示例\nget \'users\', \'xiaoming\'\n</code></pre> \n<blockquote> \n <p>根据某一行某列族的数据</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 语法\nget \'表名\', \'行键\', \'列族名\'\n\n# 示例\nget \'users\', \'xiaoming\', \'info\'\n</code></pre> \n<pre><code class=\"language-sql\"># 创建表，c1版本为4， 元数据mykey=myvalue\nhbase(main):009:0&gt; create \'t1\', {NAME =&gt; \'c1\', VERSIONS =&gt; 4}, METADATA =&gt; { \'mykey\' =&gt; \'myvalue\' }\n0 row(s) in 2.2810 seconds\n\n=&gt; Hbase::Table - t1\n# 添加列族c2, c3\nhbase(main):010:0&gt; alter \'t1\', \'c2\', \'c3\'\nUpdating all regions with the new schema...\n1/1 regions updated.\nDone.\nUpdating all regions with the new schema...\n1/1 regions updated.\nDone.\n0 row(s) in 3.8320 seconds\n\n# 出入数据，c1 插入4个版本的值\nhbase(main):011:0&gt; put \'t1\', \'r1\', \'c1\', \'v1\'\n0 row(s) in 0.1000 seconds\n\nhbase(main):012:0&gt; put \'t1\', \'r1\', \'c1\', \'v11\'\n0 row(s) in 0.0180 seconds\n\nhbase(main):013:0&gt; put \'t1\', \'r1\', \'c1\', \'v111\'\n0 row(s) in 0.0140 seconds\n\nhbase(main):014:0&gt; put \'t1\', \'r1\', \'c1\', \'v1111\'\n0 row(s) in 0.0140 seconds\n\n# 插入c2、c3的值\nhbase(main):015:0&gt; put \'t1\', \'r1\', \'c2\', \'v2\'\n0 row(s) in 0.0140 seconds\n\nhbase(main):016:0&gt; put \'t1\', \'r1\', \'c3\', \'v3\'\n0 row(s) in 0.0210 seconds\n\n# 获取rowKey=r1的一行记录\nhbase(main):017:0&gt; get \'t1\', \'r1\'\nCOLUMN                                              CELL\n c1:                                                timestamp=1552819382575, value=v1111\n c2:                                                timestamp=1552819392398, value=v2\n c3:                                                timestamp=1552819398244, value=v3\n3 row(s) in 0.0550 seconds\n\n# 获取rowKey=r1并且 1552819392398 &lt;= 时间戳范围 &lt; 1552819398244\nhbase(main):018:0&gt; get \'t1\', \'r1\', {TIMERANGE =&gt; [1552819392398, 1552819398244]}\nCOLUMN                                              CELL\n c2:                                                timestamp=1552819392398, value=v2\n1 row(s) in 0.0090 seconds\n\n# 获取指定列的值\nhbase(main):019:0&gt; get \'t1\', \'r1\', {COLUMN =&gt; \'c1\'}\nCOLUMN                                              CELL\n c1:                                                timestamp=1552819382575, value=v1111\n1 row(s) in 0.0160 seconds\n\n# 获取指定列的值，多个值使用数组表示\nhbase(main):020:0&gt; get \'t1\', \'r1\', {COLUMN =&gt; [\'c1\', \'c2\', \'c3\']}\nCOLUMN                                              CELL\n c1:                                                timestamp=1552819382575, value=v1111\n c2:                                                timestamp=1552819392398, value=v2\n c3:                                                timestamp=1552819398244, value=v3\n3 row(s) in 0.0170 seconds\n\n# 获取c1的值，获取4个版本的值，默认是按照时间戳降续排序的\nhbase(main):021:0&gt; get \'t1\', \'r1\', {COLUMN =&gt; \'c1\', VERSIONS =&gt; 4}\nCOLUMN                                              CELL\n c1:                                                timestamp=1552819382575, value=v1111\n c1:                                                timestamp=1552819376343, value=v111\n c1:                                                timestamp=1552819368993, value=v11\n c1:                                                timestamp=1552819362975, value=v1\n4 row(s) in 0.0180 seconds\n\n# 获取c1的3个版本值\nhbase(main):027:0* get \'t1\', \'r1\', {COLUMN =&gt; \'c1\', VERSIONS =&gt; 3}\nCOLUMN                                               CELL\n c1:                                                 timestamp=1552819382575, value=v1111\n c1:                                                 timestamp=1552819376343, value=v111\n c1:                                                 timestamp=1552819368993, value=v11\n3 row(s) in 0.0090 seconds\n\n# 获取指定时间戳版本的列\nhbase(main):022:0&gt; get \'t1\', \'r1\', {COLUMN =&gt; \'c1\', TIMESTAMP =&gt; 1552819376343}\nCOLUMN                                              CELL\n c1:                                                timestamp=1552819376343, value=v111\n1 row(s) in 0.0170 seconds\n\nhbase(main):023:0&gt; get \'t1\', \'r1\', {COLUMN =&gt; \'c1\', TIMESTAMP =&gt; 1552819376343, VERSIONS =&gt; 4}\nCOLUMN                                              CELL\n c1:                                                timestamp=1552819376343, value=v111\n1 row(s) in 0.0130 seconds\n\n# 获取rowKey=r1中的值等于v2的所有列\nhbase(main):024:0&gt; get \'t1\', \'r1\', {FILTER =&gt; \"ValueFilter(=, \'binary:v2\')\"}\nCOLUMN                                              CELL\n c2:                                                timestamp=1552819392398, value=v2\n1 row(s) in 0.0510 seconds\n\n\nhbase(main):025:0&gt; get \'t1\', \'r1\', {COLUMN =&gt; \'c1\', ATTRIBUTES =&gt; {\'mykey\'=&gt;\'myvalue\'}}\nCOLUMN                                              CELL\n c1:                                                timestamp=1552819382575, value=v1111\n1 row(s) in 0.0100 seconds\n</code></pre> \n<h4 id=\"54删除某个列族中的某个列delete\">5.4 删除某个列族中的某个列delete</h4> \n<pre><code class=\"language-shell\"># 语法\ndelete \'表名\', \'行键\', \'列族名:列名\'\n\ndelete \'users\',\'xiaoming\',\'info:age\'\n\ncreate \'tbl_test\', \'columnFamily1\'\n\nput \'tbl_test\', \'rowKey1\', \'columnFamily1:column1\', \'value1\'\nput \'tbl_test\', \'rowKey1\', \'columnFamily1:column2\', \'value2\'\n\ndelete \'tbl_test\', \'rowKey1\', \'columnFamily1:column1\'\n</code></pre> \n<h4 id=\"55-删除某行数据deleteall\">5.5 删除某行数据deleteall</h4> \n<pre><code class=\"language-sql\"># 语法\ndeleteall \'表名\', \'行键\'\n\n# 示例\ndeleteall \'users\', \'xiaoming\'\n</code></pre> \n<h4 id=\"56清空整个表的数据truncate\">5.6 清空整个表的数据truncate</h4> \n<blockquote> \n <p>先disable表，然后再drop表，最后重新create表</p> \n</blockquote> \n<pre><code>truncate \'表名\'\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/8e35deec-16b4-436b-a8d5-9b7879c539fc.png\" alt=\"image-20220608233602414\" loading=\"lazy\"></p> \n<h4 id=\"57自增incr\">5.7 自增incr</h4> \n<pre><code class=\"language-sql\"># 语法\nincr \'表名\', \'行键\', \'列族:列名\', 步长值\n\n# 示例 \n# 注意：incr 可以对不存的行键操作，如果行键已经存在会报错，如果使用put修改了incr的值再使用incr也会报错\n# ERROR: org.apache.hadoop.hbase.DoNotRetryIOException: Field is not a long, it\'s 2 bytes wide\nincr \'tbl_user\', \'xiaohong\', \'info:age\', 1\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/72acd9cd-6467-4b61-a6e9-a5b09422b4da.png\" alt=\"image-20220608233701046\" loading=\"lazy\"></p> \n<h4 id=\"58计数器get_counter\">5.8 计数器get_counter</h4> \n<pre><code class=\"language-sql\"># 点击量：日、周、月\ncreate \'counters\', \'daily\', \'weekly\', \'monthly\'\nincr \'counters\', \'20110101\', \'daily:hits\', 1\nincr \'counters\', \'20110101\', \'daily:hits\', 1\nget_counter \'counters\', \'20110101\', \'daily:hits\'\n</code></pre> \n<h4 id=\"59修饰词\">5.9 修饰词</h4> \n<h5 id=\"1修饰词\">1、修饰词</h5> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\', {COLUMNS =&gt; [ \'列族名1:列名1\', \'列族名1:列名2\', ...]}\n\n# 示例\nscan \'tbl_user\', {COLUMNS =&gt; [ \'info:id\', \'info:age\']}\n</code></pre> \n<h5 id=\"2timestamp-指定时间戳\">2、TIMESTAMP 指定时间戳</h5> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\',{TIMERANGE=&gt;[timestamp1, timestamp2]}\n\n# 示例\nscan \'tbl_user\',{TIMERANGE=&gt;[1551938004321, 1551938036450]}\n</code></pre> \n<h5 id=\"3versions\">3、VERSIONS</h5> \n<blockquote> \n <p>默认情况下一个列只能存储一个数据，后面如果修改数据就会将原来的覆盖掉，可以通过指定VERSIONS时HBase一列能存储多个值。</p> \n</blockquote> \n<pre><code class=\"language-sql\">create \'tbl_test\', \'columnFamily1\'\ndescribe \'tbl_test\'\n\n# 修改列族版本号\nalter \'tbl_test\', { NAME=&gt;\'columnFamily1\', VERSIONS=&gt;3 }\n\nput \'tbl_test\', \'rowKey1\', \'columnFamily1:column1\', \'value1\'\nput \'tbl_test\', \'rowKey1\', \'columnFamily1:column1\', \'value2\'\nput \'tbl_test\', \'rowKey1\', \'columnFamily1:column1\', \'value3\'\n\n# 默认返回最新的一条数据\nget \'tbl_test\',\'rowKey1\',\'columnFamily1:column1\'\n\n# 返回3个\nget \'tbl_test\',\'rowKey1\',{COLUMN=&gt;\'columnFamily1:column1\', VERSIONS=&gt;3}\n# 返回2个\nget \'tbl_test\',\'rowKey1\',{COLUMN=&gt;\'columnFamily1:column1\', VERSIONS=&gt;2}\n</code></pre> \n<h5 id=\"4startrow\">4、STARTROW</h5> \n<blockquote> \n <p>ROWKEY起始行。会先根据这个key定位到region，再向后扫描</p> \n</blockquote> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\', { STARTROW =&gt; \'行键名\'}\n\n# 示例\nscan \'tbl_user\', { STARTROW =&gt; \'vbirdbest\'}\n</code></pre> \n<h5 id=\"5stoprow-截止到stoprow行stoprow行之前的数据不包括stoprow这行数据\">5、STOPROW ：截止到STOPROW行，STOPROW行之前的数据，不包括STOPROW这行数据</h5> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\', { STOPROW =&gt; \'行键名\'}\n\n# 示例\nscan \'tbl_user\', { STOPROW =&gt; \'xiaoming\'}\n</code></pre> \n<h5 id=\"6limit-返回的行数\">6、LIMIT 返回的行数</h5> \n<pre><code class=\"language-sql\"># 语法\nscan \'表名\', { LIMIT =&gt; 行数}\n\n# 示例\nscan \'tbl_user\', { LIMIT =&gt; 2 }\n</code></pre> \n<h4 id=\"510filter条件过滤器\">5.10 FILTER条件过滤器</h4> \n<blockquote> \n <p>过滤器之间可以使用AND、OR连接多个过滤器。</p> \n</blockquote> \n<h5 id=\"1valuefilter-值过滤器\">1、ValueFilter 值过滤器</h5> \n<pre><code class=\"language-sql\"># 语法：binary 等于某个值\nscan \'表名\', FILTER=&gt;\"ValueFilter(=,\'binary:列值\')\"\n# 语法 substring:包含某个值\nscan \'表名\', FILTER=&gt;\"ValueFilter(=,\'substring:列值\')\"\n\n# 示例\nscan \'tbl_user\', FILTER=&gt;\"ValueFilter(=, \'binary:26\')\"\nscan \'tbl_user\', FILTER=&gt;\"ValueFilter(=, \'substring:6\')\"\n</code></pre> \n<h5 id=\"2columnprefixfilter-列名前缀过滤器\">2、ColumnPrefixFilter 列名前缀过滤器</h5> \n<pre><code># 语法 substring:包含某个值\nscan \'表名\', FILTER=&gt;\"ColumnPrefixFilter(\'列名前缀\')\"\n\n# 示例\nscan \'tbl_user\', FILTER=&gt;\"ColumnPrefixFilter(\'birth\')\"\n# 通过括号、AND和OR的条件组合多个过滤器\nscan \'tbl_user\', FILTER=&gt;\"ColumnPrefixFilter(\'birth\') AND ValueFilter(=,\'substring:26\')\"\n</code></pre> \n<h5 id=\"3rowkey字典排序\">3、rowKey字典排序</h5> \n<blockquote> \n <p>Table中的所有行都是按照row key的字典排序的</p> \n</blockquote>',100,NULL,0,'https://www.cnblogs.com/bfy0221/p/16757819.html','2022-10-06 23:57:49'),(13,'WinDbg Preview安装以及符号表配置',NULL,NULL,0,0,'<h1 id=\"1安装windbgpreview\">1、安装WinDbgPreview</h1> \n<p>在Microsoft Store直接搜索windbg就可以下载。</p> \n<h1 id=\"2配置符号服务器\">2、配置符号服务器</h1> \n<h2 id=\"21-符号\">2.1 符号</h2> \n<p>符号是方便调试程序的文件，通常是pdb文件。一个模块（可执行程序，动态链接库）对应一个pdb文件。不同的windows版本中的文件不同（比如说kernel32），版本不同pdb符号文件也不同，因此要从微软提供的符号服务器获取本机对应的符号。</p> \n<p>但是要在本地建立一个文件夹作为缓存来存放符号文件，以便下次使用时直接从本地获取。</p> \n<h2 id=\"22-配置\">2.2 配置</h2> \n<p>1、可以在环境变量设置_NT_SYSBOL_PATH为 <em>srv*C:\\Symbols*<a href=\"http://msdl.microsoft.com/download/symbols\" target=\"_blank\" rel=\"noopener\">http://msdl.microsoft.com/download/symbols</a></em></p> \n<p>其中c:\\Symbols就是自己本机上符号的缓存目录，可以自己设置。后面网址就是微软符号服务器了</p> \n<p><em><strong>但是</strong></em>，我是用这种方法时，visual studio调试时会自动从这个网站加载符号，非常浪费时间，令人崩溃。而且好像强制没法关闭，所以根据自己情况自行选择。</p> \n<p>2、不设置环境变量了，直接进入windbg，file-&gt;setting-&gt;debugging settings把symbol path填入也可以。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/06/9aa0be1a-ac6a-4383-bc7f-cf085ae9318d.png\" alt=\"\" loading=\"lazy\"><br> 如图所示。</p> \n<p>3、加载一个可执行文件在<br> 在命令行输入.sympath命令也可以添加。这一个方法自行搜索。</p> \n<h1 id=\"3基本使用\">3、基本使用</h1> \n<h2 id=\"31-加载文件\">3.1 加载文件</h2> \n<p>直接把可执行文件拖进去就可以，或者file-&gt;lanch executable加载一个文件。会自动识别是32位程序还是64位程序。这里可以直接打开记事本文件notepad.exe做测试。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/06/f40ae7d1-fc8d-4ab9-bf8c-3743005f51b5.png\" alt=\"\" loading=\"lazy\"></p> \n<p>在命令窗口输入lm,显示notepad.exe用到的模块以及符号表对应情况。<br> 如图，deferred对应的模块没有加载，pdb带路径的就是加载了符号表。kernel32符号表已经加载，但是user32符号表没有加载。可以用ld kernel32加载符号文件。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/06/2f5cfd92-9674-46fd-90ee-f8a631cdc74d.png\" alt=\"\" loading=\"lazy\"></p> \n<h2 id=\"32-常用命令\">3.2 常用命令</h2> \n<p>r 查看寄存器<br> t 单步执行，遇到call跟进去<br> g 运行<br> bp (address | function)，在地址下断点，比如，bp 0x401000，或者 bp kernel32!CreateFileW</p>',100,NULL,0,'https://www.cnblogs.com/zz89/p/16757640.html','2022-10-06 23:57:55'),(14,'Python 3.12 目标：还可以更快！',NULL,NULL,0,0,'<p>按照发布计划，Python 3.11.0 将于 2022 年 10 月 24 日发布。</p> \n<p>据测试，3.11 相比于 3.10，将会有 10-60% 的性能提升，这个成果主要归功于“Faster CPython”项目，即“香农计划”。</p> \n<p>关于“香农计划”的详情，可查看 Python 之父的<a href=\"https://mp.weixin.qq.com/s/DWVVoh2oj1GQ20WlTYo3cg\" target=\"_blank\" rel=\"noopener\">主题分享</a>，以及他的一则<a href=\"https://mp.weixin.qq.com/s/YGgW1Pb79RWzs9X_etx1Rw\" target=\"_blank\" rel=\"noopener\">播客访谈</a>。</p> \n<p>3.11 版本为 Python 的提速开了一个激动人心的好头。接下来，3.12 还会有更多动作。</p> \n<p>以下文章翻译自“香农计划”的《Python 3.12 Goals》，大家先一睹为快吧！</p> \n<blockquote> \n <p>作者：Mark Shannon</p> \n <p>译者：豌豆花下猫@Python猫</p> \n <p>英文：<a href=\"https://github.com/faster-cpython/ideas/wiki/Python-3.12-Goals\" target=\"_blank\" rel=\"noopener\">https://github.com/faster-cpython/ideas/wiki/Python-3.12-Goals</a></p> \n</blockquote> \n<p><em>本文内容可能会改动，以实际版本为准！</em></p> \n<p>本文是 Faster CPython 计划在 3.12 中实现的主要内容的概要。</p> \n<h2 id=\"跟踪优化器\">跟踪优化器</h2> \n<p>Python 3.11 提升速度的主要方法是用更快的与上下文相关的操作码（自适应的专门化操作码）替换个别的操作码，下一个大的改进方法是优化多个操作码的运行。</p> \n<p>为此，现有的许多高级操作码将被替换成低级操作码，例如，用于检查版本号和引用计数的操作码。这些更简单的操作码更容易进行优化，例如，可以删除冗余的引用计数操作。</p> \n<p>这些更底层的操作码还能让我们得到一组适合用于生成机器代码的指令（在 CPython 和第三方 JIT 项目中都适用）。</p> \n<p>为了做到这点，解释器循环（interpreter loop）将基于声明性的描述而生成。</p> \n<p>这可减少一部分为了保持解释器循环与某些相关函数同步而产生的 bug（mark_stacks、stack_effect 等函数），同时也让我们可以对解释器循环作较大的更改试验。</p> \n<h2 id=\"多线程并行\">多线程并行</h2> \n<p>Python 当前每个进程有一个全局解释器锁（GIL），阻碍了多线程的并行。</p> \n<blockquote> \n <p>PEP-684：<a href=\"https://peps.python.org/pep-0684\" target=\"_blank\" rel=\"noopener\">https://peps.python.org/pep-0684</a></p> \n <p>PEP-554：<a href=\"https://peps.python.org/pep-0554\" target=\"_blank\" rel=\"noopener\">https://peps.python.org/pep-0554</a></p> \n</blockquote> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/153b0697-4942-4c10-8895-6e6dfe3527c6.jpeg\" alt=\"\" loading=\"lazy\"></p> \n<p><a href=\"https://peps.python.org/pep-0684/\" target=\"_blank\" rel=\"noopener\">PEP-684</a> 提出了一个方案，即保证所有的全局状态都是线程安全的，并移动到每个子解释器的全局解释器锁中使用。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/576aa499-8a90-44c8-8578-2e6fe410a0a0.jpeg\" alt=\"\" loading=\"lazy\"></p> \n<p><a href=\"https://peps.python.org/pep-0554/\" target=\"_blank\" rel=\"noopener\">PEP-554</a> 提出了让 Python 创建子解释器的方案（目前只是一个 C API 特性），从而实现真正的多线程并行。</p> \n<blockquote> \n <p>Python猫注：PEP-554 早在 2017 年就提出了，目标是落地在 Python 3.8-3.9 版本，然而事与愿违。早在 2019 年的时候，我还翻译了一篇《<a href=\"https://mp.weixin.qq.com/s/8KvQemz0SWq2hw-2aBPv2Q\" target=\"_blank\" rel=\"noopener\">Has the Python GIL been slain?</a>》。屠刀已挥出，让它再飞一会~~</p> \n</blockquote> \n<h2 id=\"更多专门化\">更多专门化</h2> \n<p>我们<a href=\"https://github.com/faster-cpython/ideas/issues/74\" target=\"_blank\" rel=\"noopener\">分析了哪些字节码将从专门化中获益最多</a>，计划在 3.12 完成其余的高收益的改进。</p> \n<blockquote> \n <p><a href=\"https://github.com/faster-cpython/ideas/issues/74\" target=\"_blank\" rel=\"noopener\">https://github.com/faster-cpython/ideas/issues/74</a></p> \n</blockquote> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/42ef14ac-5518-4684-b125-eff999d71c32.jpeg\" alt=\"\" loading=\"lazy\"></p> \n<h2 id=\"较小的对象结构\">较小的对象结构</h2> \n<p>有许多可以<a href=\"https://github.com/faster-cpython/ideas/discussions/125\" target=\"_blank\" rel=\"noopener\">减少 Python 对象结构大小的机会</a>。由于它们被频繁使用，这不仅有利于总体的内存使用，还有利于缓存的一致性。我们计划在 3.12 中实现最有希望的一些想法。</p> \n<p>这里有一些向后兼容性与性能之间的权衡问题，可能需要提出一个 PEP 来建立共识。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/08eea261-f12e-469c-ae24-e1edc6d36efd.jpeg\" alt=\"\" loading=\"lazy\"></p> \n<h2 id=\"减少内存管理的开销\">减少内存管理的开销</h2> \n<p>我们不仅会减小对象的大小，还会使它们的 layout 更加规则。</p> \n<p>这不仅能优化内存的分配及释放，还能在 GC 和重新分配期间加快遍历对象的速度。</p> \n<h2 id=\"api-稳定性\">API 稳定性</h2> \n<p>除了前述项目外，开发团队还将提升 CPython 代码库的整体质量：</p> \n<ul> \n <li>通过减少不同编译阶段的耦合，使编译器更易于维护与测试。</li> \n <li>积极地在 C 语言级别监控和改进 CPython 测试套的代码覆盖率。</li> \n <li>改进 Python 性能基准测试套，加入更具代表性的现实世界的负载测试。</li> \n <li>协助处理 CPython 问题和 PR，特别是与性能有关的问题。</li> \n <li>增加用于标准基准测试的机器，增加 macOS 和 Windows 的测试结果。</li> \n <li>继续跟主要的深度使用 Python 内核的项目合作，帮助它们适配 CPython 解释器的更改。</li> \n</ul> \n<p>注：文中图片为译者所加。</p> \n<p>首发于 <strong>Python猫</strong> ，如需转载，请联系作者</p> \n<p>知乎：<a href=\"https://www.zhihu.com/people/pythonmao\" target=\"_blank\" rel=\"noopener\">Python猫</a></p> \n<p>博客园：<a href=\"https://www.cnblogs.com/pythonista/\" target=\"_blank\" rel=\"noopener\">豌豆花下猫</a></p> \n<p>掘金：<a href=\"https://juejin.cn/user/3245414053840973\" target=\"_blank\" rel=\"noopener\">豌豆花下猫</a></p> \n<p>CSDN：<a href=\"https://blog.csdn.net/chinesehuazhou2\" target=\"_blank\" rel=\"noopener\">Python猫</a></p>',100,NULL,0,'https://www.cnblogs.com/pythonista/p/16757518.html','2022-10-06 23:58:01'),(15,'二叉树两个节点的最近公共祖先问题',NULL,NULL,0,0,'<h1 id=\"二叉树两个节点的最近公共祖先问题\">二叉树两个节点的最近公共祖先问题</h1> \n<p>作者：<a href=\"https://www.cnblogs.com/greyzeng/\" target=\"_blank\" rel=\"noopener\">Grey</a></p> \n<p>原文地址：</p> \n<p><a href=\"https://www.cnblogs.com/greyzeng/p/16757504.html\" target=\"_blank\" rel=\"noopener\">博客园：二叉树两个节点的最近公共祖先问题</a></p> \n<p><a href=\"https://blog.csdn.net/hotonyhui/article/details/127182548\" target=\"_blank\" rel=\"noopener\">CSDN：二叉树两个节点的最近公共祖先问题</a></p> \n<h2 id=\"题目描述\">题目描述</h2> \n<p>给定一棵二叉树的头节点 head，和另外两个节点 a 和 b , 返回 a 和 b 的最低公共祖先。</p> \n<p>题目链接见：<a href=\"https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree\" target=\"_blank\" rel=\"noopener\">LeetCode 236. Lowest Common Ancestor of a Binary Tree</a></p> \n<p>主要思路：</p> \n<p>本题也是利用<a href=\"https://www.cnblogs.com/greyzeng/p/16703346.html\" target=\"_blank\" rel=\"noopener\">二叉树的递归套路</a>来解。</p> \n<p>定义好 Info 信息</p> \n<pre><code class=\"language-java\">    public static class Info {\n        public Info(boolean findA, boolean findB, TreeNode ancestor) {\n            this.findA = findA;\n            this.findB = findB;\n            this.ancestor = ancestor;\n        }\n        private boolean findA;\n        private boolean findB;\n        private TreeNode ancestor;\n\n    }\n</code></pre> \n<p>其中</p> \n<p><code>findA</code>表示能否在当前(子)树下找到 a 节点；</p> \n<p><code>findB</code>表示能否在当前(子)树下找到 b 节点；</p> \n<p><code>ancestor</code>表示当前两个节点的最低公共祖先是什么。</p> \n<p>首先考虑一些边界条件，例如</p> \n<pre><code class=\"language-java\">if (a == null) {\n    // a 为 null，不管 b 是否为 null，公共祖先都是 b\n    return b;\n}\nif (b == null) {\n    // b 为 null， 不管 a 是否为 null，公共祖先都是 a\n    return a;\n}\n</code></pre> \n<p>定义递归函数</p> \n<pre><code class=\"language-java\">Info p(TreeNode head, TreeNode a, TreeNode b)\n</code></pre> \n<p>递归含义是：以 head 为头的树，a 和 b 的公共祖先是什么，封装成 Info 返回。</p> \n<p>接下来看递归函数的主要逻辑</p> \n<p>首先是 base case，如果 head 为 null，则 findA = false，findB = false，a 和 b 的公共祖先也是 null</p> \n<p>即</p> \n<pre><code class=\"language-java\">        if (head == null) {\n            return new Info(false, false, null);\n        }\n</code></pre> \n<p>分析了 base case，接下来是普遍情况，如果 head 不为 null，则去左树收集信息，去右树也收集信息，然后把左右两树的信息整合成 head 的信息返回</p> \n<p>即</p> \n<pre><code class=\"language-java\">// 左树收集信息\nInfo leftInfo = p(head.left, a, b);\n// 右树收集信息\nInfo rightInfo = p(head.right, a, b);\n\n// 整合\n......\n</code></pre> \n<p>最后，我们需要把左右两树返回的信息进行整合，首先，以 head 为头的树，<code>findA</code>的取值取决于如下三种情况：</p> \n<p>情况1，左树包含 a，即 leftInfo.findA</p> \n<p>情况2，右树包含 a，即 rightInfo.findA</p> \n<p>情况3，head 就是 a</p> \n<p>三个情况有一个满足，以 head 为头的树 findA = true，</p> \n<p><code>findB</code>类似，</p> \n<p>即下述代码所表达的含义</p> \n<pre><code class=\"language-java\">//  这\nboolean findA = leftInfo.findA || rightInfo.findA || head == a;\nboolean findB = leftInfo.findB || rightInfo.findB || head == b;\n</code></pre> \n<p>接下来看两个节点的最低公共祖先，首先，如果左树上找到 a 和 b，那么 leftInfo.ancestor 就是 a 和 b 的最低公共祖先；</p> \n<p>如果右树上找到 a 和 b，那么 rightInfo.ancestor 就是 a 和 b 的最低公共祖先；</p> \n<p>如果左右树一边找到一个，则 head 就是 a 和 b 的最低公共祖先；</p> \n<p>如果 a 和 b 在树上都找不到，即<code>findA = false, findB = false</code>，那么 a 和 b 的最低公共祖先就是 null。</p> \n<p>即下述代码逻辑</p> \n<pre><code class=\"language-java\">        \n        if (findA &amp;&amp; findB) {\n            if (leftInfo.findA &amp;&amp; leftInfo.findB) {\n                return new Info(true, true, leftInfo.ancestor);\n            } else if (rightInfo.findA &amp;&amp; rightInfo.findB) {\n                return new Info(true, true, rightInfo.ancestor);\n            }\n            return new Info(true, true, head);\n        }\n        return new Info(findA, findB, null);\n</code></pre> \n<p>完整代码见</p> \n<pre><code class=\"language-java\">class Solution {\n    public static TreeNode lowestCommonAncestor(TreeNode head, TreeNode a, TreeNode b) {\n        if (a == null) {\n            return b;\n        }\n        if (b == null) {\n            return a;\n        }\n        // o1和o2都不为null\n        return p(head, a, b).ancestor;\n    }\n\n    public static Info p(TreeNode head, TreeNode a, TreeNode b) {\n        if (head == null) {\n            return new Info(false, false, null);\n        }\n        Info leftInfo = p(head.left, a, b);\n        Info rightInfo = p(head.right, a, b);\n        boolean findA = leftInfo.findA || rightInfo.findA || head == a;\n        boolean findB = leftInfo.findB || rightInfo.findB || head == b;\n        if (findA &amp;&amp; findB) {\n            if (leftInfo.findA &amp;&amp; leftInfo.findB) {\n                return new Info(true, true, leftInfo.ancestor);\n            } else if (rightInfo.findA &amp;&amp; rightInfo.findB) {\n                return new Info(true, true, rightInfo.ancestor);\n            }\n            return new Info(true, true, head);\n        }\n        return new Info(findA, findB, null);\n    }\n\n    public static class Info {\n        public Info(boolean findA, boolean findB, TreeNode ancestor) {\n            this.findA = findA;\n            this.findB = findB;\n            this.ancestor = ancestor;\n        }\n\n        private boolean findA;\n        private boolean findB;\n        private TreeNode ancestor;\n\n    }\n}\n</code></pre> \n<p>时间复杂度为<code>O(N)</code>（即一次后序遍历的时间复杂度）</p> \n<h2 id=\"更多\">更多</h2> \n<p><a href=\"https://github.com/GreyZeng/algorithm\" target=\"_blank\" rel=\"noopener\">算法和数据结构笔记</a></p>',100,NULL,0,'https://www.cnblogs.com/greyzeng/p/16757504.html','2022-10-06 23:58:01'),(16,'Seal-Report: 开放式数据库报表工具',NULL,NULL,0,0,'<p>Seal Report是.Net的一个基于Apache 2.0 开源工具，完全用C# 语言编写，最新的6.6 版本采用.NET 6，github: <a title=\"https://github.com/ariacom/Seal-Report\" href=\"https://github.com/ariacom/Seal-Report\" rel=\"noopener\">https://github.com/ariacom/Seal-Report</a>。Seal Report提供了一个完整的框架，用于从任何数据库或任何非SQL源生成每日报告。该产品的重点是易于安装和报表设计：一旦安装，报表可以在一分钟内构建和发布。</p>\n<h4>主要特性</h4>\n<ul>\n <li>动态SQL源：使用您的SQL或让Seal引擎动态生成用于查询数据库的SQL。 </li>\n <li>LINQ查询：使用LINQ查询的强大功能连接和查询任何数据源（SQL、Excel、XML、OLAP多维数据集、HTTP JSon等）。 </li>\n <li>原生数据透视表：只需将元素直接拖放到数据透视表（交叉选项卡）中，并将其显示在报表中。 </li>\n <li>HTML 5图表：用鼠标点击两次即可定义和显示图表系列（支持ChartJS、NVD3和Plotly库）。 </li>\n <li>KPI和小部件视图：在单个报告中创建和显示关键性能指标。 </li>\n <li>使用Razor引擎进行完全响应和HTML呈现：在报告结果中使用HTML5的功能（布局、响应性、表排序和过滤）。使用Razor引擎解析在HTML中自定义报表演示。 </li>\n <li>Web报表服务器：在Web上发布和编辑报表（支持Windows和Linux操作系统以及.Net 6）。 </li>\n <li>报表调度程序：在文件夹、FTP、SFTP服务器中调度报表执行并生成结果，或通过电子邮件发送（与Windows任务调度程序集成或作为服务提供） </li>\n <li>向下钻取导航和子报告：在报告结果中导航以钻取到详细信息或执行另一个报告。 </li>\n <li>报告任务：定义执行批处理操作（数据加载、excel加载、备份、数据处理等）或从外部程序集触发过程的任务。 </li>\n <li>低TCO（总体拥有成本）：该产品旨在将日常维护降至最低。 </li>\n <li>NuGet软件包可以简化与现有项目的集成。 </li>\n <li>Mongo DB的本机支持。</li>\n</ul>\n<p>可以看看在线演示Web报表服务器：<a title=\"https://sealreport.org/demo\" href=\"https://sealreport.org/demo\" rel=\"noopener\">https://sealreport.org/demo</a>。</p>\n<p>有关生成报告的快速入门指南，请访问Seal Report网站：<a title=\"https://sealreport.org/\" href=\"https://sealreport.org/\" rel=\"noopener\">https://sealreport.org/</a>。</p>\n<p>可以通过Seal Report论坛：<a title=\"https://sealreport.org/forum\" href=\"https://sealreport.org/forum\" rel=\"noopener\">https://sealreport.org/forum</a> 获取产品的免费支持、信息和提示。</p>\n<p>除了开源版本外，Seal-Report的开发商 Ariacom 还提供产品和2个商业组件的支持：</p>\n<ul>\n <li>Web报表设计器可以从任何Web浏览器编辑报表。 </li>\n <li>PDF和Excel转换器，用于在PDF和Excel文件中生成报告。</li>\n</ul>\n<p>Seal in the Cloud ：提 供了一个完整的环境来使用Seal Report in the Cloud的强大功能和灵活性。访问<a title=\"https://sealreport.com/\" href=\"https://sealreport.com/\" rel=\"noopener\">https://sealreport.com/</a>，注册并获得免费试用实例，在共享服务器上上传并执行您的报表。</p>\n<h6><font size=\"3\">实体和组件</font></h6>\n<p><img alt=\"\" src=\"http://localhost:8080/static/blogImages/2022/10/06/cffb0ebd-00af-408b-95b6-5f2480e4ed6b.png\"></p>\n<h6><font size=\"3\">部署和发布</font></h6>\n<img alt=\"\" src=\"http://localhost:8080/static/blogImages/2022/10/06/7bab3242-62c3-4fdc-aad5-83adb95fcc98.png\">\n<h4>主要实体：存储库和报告</h4>\n<p><strong><strong>Seal </strong>存储库</strong>存储由 Seal 报告管理的所有实体：数据源、设备、报告。<br>此外，存储库还包含用于设置（用于翻译的配置和字典）、视图（用于呈现报表结果）、安全性（配置和提供程序）的额外文件夹。<br>默认情况下，存储库根文件夹位于<i>“C:\\ProgramData\\<i>Seal Report Repository</i>”中</i>。</p>\n<p>报表由数据源、模型、视图和可选的任务、输出和计划组成。该报告还可以引用存储库中的视图模板。</p>\n<ul>\n <li><strong>数据源</strong>包含数据库连接、表、联接和列的说明。</li>\n <li><strong>模型</strong>定义如何从单个 SQL 语句生成结果集（数据表）和序列。</li>\n <li><strong>视图</strong>用于使用 Razor 解析和呈现从<strong>模型</strong>生成 HTML 文档。 </li>\n <li>可以定义<strong>输出</strong>和<strong>计划</strong>以自动生成报告（例如，每天早上发送电子邮件）。</li>\n <li>可以定义<strong>任务</strong>来执行 SQL 或脚本任务。</li>\n</ul>\n<p><br></p>\n<p>HTML 报表</p>\n<p><a href=\"http://localhost:8080/static/blogImages/2022/10/06/dd11b235-cf53-48ab-972c-abb505e74793.png\" rel=\"noopener\"><img alt=\"HTML Report Result\" src=\"http://localhost:8080/static/blogImages/2022/10/06/dd11b235-cf53-48ab-972c-abb505e74793.png\"></a></p>\n<p><a href=\"http://localhost:8080/static/blogImages/2022/10/06/bbdb7b1b-e432-4c06-9b2c-9cfed9c63a2a.png\" rel=\"noopener\"><img alt=\"HTML Report Result\" src=\"http://localhost:8080/static/blogImages/2022/10/06/bbdb7b1b-e432-4c06-9b2c-9cfed9c63a2a.png\"></a></p>\n<h4>报表设计器</h4>\n<p><a href=\"http://localhost:8080/static/blogImages/2022/10/06/4a588310-c395-4573-a831-9f955e05c2da.png\" rel=\"noopener\"><img alt=\"Report Designer\" src=\"http://localhost:8080/static/blogImages/2022/10/06/4a588310-c395-4573-a831-9f955e05c2da.png\"></a></p>\n<h4>Web 报表服务器</h4>\n<p><a href=\"http://localhost:8080/static/blogImages/2022/10/06/18fdb4e2-be1c-4e01-a9ec-a2ca5d8f7969.png\" rel=\"noopener\"><img alt=\"Web Report Server\" src=\"http://localhost:8080/static/blogImages/2022/10/06/18fdb4e2-be1c-4e01-a9ec-a2ca5d8f7969.png\"></a></p>',100,NULL,0,'https://www.cnblogs.com/shanyou/p/16757439.html','2022-10-06 23:58:14'),(17,'用 VS Code 搞Qt6：使用 PySide 6',NULL,NULL,0,0,'<p>一般来说，用C++写 Qt 应用才是正宗的，不过，为了让小学生也能体验 Qt 的开发过程，或者官方为了增加开发者人数，推出了可用 Python 来编程的 Qt 版本。此版本命名比较奇葩，叫 PySide，与 Qt 6 配套的是 PySide 6。当前最新版本是 6.3.2。</p> \n<p>PySide 的优势在于它是官方维护的，完全是C++开发的。在原有库基础上增加了对应的 .pyd 文件，对 API 做了封装，并由 .pyi 文件进行类型规范。在性能上是不用担心的，但是，这种开发方式用来学习较适合，真要做个应用程序，还是用C++好，编译出来就能用了。Python 写的话打包要用其他工具，也麻烦，对于脚本语言，还得到处带上个解析器。</p> \n<p>PySide 6 可以通过 pip 直接安装就行了。</p> \n<p>在安装之前，老周建议先创建个虚拟环境。一来专用性强，二来方便打包。假设我要把虚拟环境存放在神奇的 E 盘下的 MyEnv 目录下，那么，可以执行：</p> \n<div class=\"cnblogs_code\"> \n <pre>python -m venv E:\\MyEnv</pre> \n</div> \n<p>或者</p> \n<div class=\"cnblogs_code\"> \n <pre>python3 -m venv E:\\MyEnv</pre> \n</div> \n<p>虚拟环境可以创建一个隔离的区域，有独立的 python 解析器、pip 程序等。每个虚拟环境互不干扰。在虚所环境的 Scripts 目录（Linux是 bin 目录）下，有两个文件很有用。要启用虚拟环境，就执行&nbsp;activate 文件；要退出虚拟环境，执行&nbsp;deactivate 文件。</p> \n<p>接下来在刚建立的虚拟环境中安装 PySide 6。先执行 activate 文件激活环境，然后执行命令：</p> \n<div class=\"cnblogs_code\"> \n <pre>pip install PySide6</pre> \n</div> \n<p>如果不能下载或下载特慢，请换国内的清华大学源。</p> \n<div class=\"cnblogs_code\"> \n <pre>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple <strong><span style=\"background-color: rgba(255, 255, 0, 1)\">PySide6</span></strong></pre> \n</div> \n<p>详细的使用方法请自行查看帮助说明，此话题对本文而言已超纲。</p> \n<p>------------------------------------------------------------------------------------------------------------------------------------</p> \n<p>接下来该到 VS Code 了。不需要什么特殊配置，安装微软官方的 Python 扩展即可。</p> \n<p>但是，不过，可是，然而，要注意：要先执行虚拟环境中的 activate 文件，然后在当前运行环境不变的前提下启动 VS Code。在VS Code中也需要使用虚拟环境所设置的环境变量。为了人性化，咱们可以在桌面上建一个批处理文件，然后输入以下内容：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">@echo</span> <span style=\"color: rgba(0, 0, 255, 1)\">off</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">call</span> E:\\MyEnv\\Scripts\\activate.<span style=\"color: rgba(0, 0, 0, 1)\">bat\n</span><span style=\"color: rgba(0, 0, 255, 1)\">start</span> C:\\&lt;你的VS Code 路径&gt;\\VSCode\\Code.<span style=\"color: rgba(0, 0, 0, 1)\">exe\n</span><span style=\"color: rgba(0, 0, 255, 1)\">exit</span></pre> \n</div> \n<p>第一行不解释了，可自行度娘。第二行是用 CALL 命令调用 activate 文件（在 Windows 上它是个批处理文件），这样虚拟环境就激活了。第三行使用 start 命令启动 VS Code，这样 VS Code 就具备了虚拟环境的上下文和环境变量了。第四行退出这个批处理文件，这是为了关掉命令行窗口。此处不必理会 deactivate 文件，毕竟 VS Code 退出后，虚拟环境相关的环境变量就没有了。</p> \n<p>当我们要用 PySide 6 时，直接运行批处理文件就完事了。</p> \n<p>&nbsp;</p> \n<p>===================================================================================</p> \n<p>PySide 6 的各种类型、模块与 C++ 版本是一样的，只要你会写 Python 代码，基本上可以直接迁移。当然，千万不要像官方文档那样迁移，因为文档的 Python 代码估计是通过机器翻译的，直接将 C++ 译成 Python。所以，你会看到官方文档有很多 Python 代码是错的，根本不能运行。有的连语法都保留了 C++ 特征，压根就不是 Python 代码。</p> \n<p>尽管不能直接把 C++ 代码转换成 Python 代码，但是按照 C++ Qt 程序的思路来写代码是没问题的。由于编程语言差异性，是不可能完全兼容的。比如，C++ 版中的许多宏，你不能在 Python 中使用。假如你要从 QObject 类派生，为了使其支持信号和槽，要加上 Q_OBJECT 宏。在 Python 中不需要加，也没有这个，官方封装的库会帮我们完成这个。再如，C++ 中重载的运算符 &lt;&lt;、&gt;&gt; 也不能用，PySide 中没有 QDebug。</p> \n<p>在 VS Code 中，解析器选择咱们上面创建的虚拟环境。然后新建一个代码文件，名字随便取。写个简单程序试试。</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 导入要用到的类型</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">from</span> PySide6.QtCore <span style=\"color: rgba(0, 0, 255, 1)\">import</span><span style=\"color: rgba(0, 0, 0, 1)\"> Qt\n</span><span style=\"color: rgba(0, 0, 255, 1)\">from</span> PySide6.QtWidgets <span style=\"color: rgba(0, 0, 255, 1)\">import</span><span style=\"color: rgba(0, 0, 0, 1)\"> QApplication, QWidget\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 自定义类，作为窗口</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">class</span><span style=\"color: rgba(0, 0, 0, 1)\"> MyWindow(QWidget):\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 构造函数</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">def</span> <span style=\"color: rgba(128, 0, 128, 1)\">__init__</span>(self, parent =<span style=\"color: rgba(0, 0, 0, 1)\"> None):\n        super().</span><span style=\"color: rgba(128, 0, 128, 1)\">__init__</span><span style=\"color: rgba(0, 0, 0, 1)\">(parent, Qt.Window)\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 设置窗口标题</span>\n        self.setWindowTitle(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">智能掏粪机</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">)\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 设置窗口大小</span>\n        self.resize(260, 185<span style=\"color: rgba(0, 0, 0, 1)\">)\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\">-------------------------------------------------</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">if</span> <span style=\"color: rgba(128, 0, 128, 1)\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1)\">\'</span><span style=\"color: rgba(128, 0, 0, 1)\">__main__</span><span style=\"color: rgba(128, 0, 0, 1)\">\'</span><span style=\"color: rgba(0, 0, 0, 1)\">:\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 先实例化 app 对象</span>\n    app =<span style=\"color: rgba(0, 0, 0, 1)\"> QApplication()\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 再实例化窗口类对象</span>\n    win =<span style=\"color: rgba(0, 0, 0, 1)\"> MyWindow()\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 显示窗口</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">    win.show()\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 启动消息循环</span>\n    app.<span style=\"color: rgba(0, 0, 255, 1)\">exec</span>()</pre> \n</div> \n<p>最后启动应用程序的代码也可以这样写：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">if</span> <span style=\"color: rgba(128, 0, 128, 1)\">__name__</span> == <span style=\"color: rgba(128, 0, 0, 1)\">\'</span><span style=\"color: rgba(128, 0, 0, 1)\">__main__</span><span style=\"color: rgba(128, 0, 0, 1)\">\'</span><span style=\"color: rgba(0, 0, 0, 1)\">:\n    </span><span style=\"background-color: rgba(255, 255, 0, 1)\"><span style=\"color: rgba(0, 0, 255, 1)\">import</span><span style=\"color: rgba(0, 0, 0, 1)\"> sys </span></span>    <span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 先实例化 app 对象</span>\n    app =<span style=\"color: rgba(0, 0, 0, 1); background-color: rgba(255, 255, 0, 1)\"> QApplication(sys.argv)\n</span>    <span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 再实例化窗口类对象</span>\n    win =<span style=\"color: rgba(0, 0, 0, 1)\"> MyWindow()\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 显示窗口</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">    win.show()\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">#</span><span style=\"color: rgba(0, 128, 0, 1)\"> 启动消息循环</span>\n    <span style=\"background-color: rgba(255, 255, 0, 1)\">sys.exit(app.<span style=\"color: rgba(0, 0, 255, 1)\">exec</span>())</span></pre> \n</div> \n<p>执行此代码文件，效果如下图：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/fb87bd67-99af-4a28-8ccc-3cd14f3629f0.png\" alt=\"\" loading=\"lazy\"></p> \n<p>&nbsp;</p> \n<p>看到上述窗口，说明 PySide 6 配置无误。&nbsp;</p> \n<p>&nbsp;</p>',100,NULL,0,'https://www.cnblogs.com/tcjiaan/p/16757396.html','2022-10-06 23:58:16'),(18,'如何使用 Yolov4 训练人脸口罩检测模型',NULL,NULL,0,0,'<h1 id=\"前言\">前言</h1> \n<p>疫情当下，出入医院等公共场所都被要求佩戴口罩。这篇博客将会介绍如何使用 Yolov4，训练一个人脸口罩检测模型（使用 Yolov4 的原因是目前只复现到了 v4 ），代码地址为 <a href=\"https://github.com/zhiyiYo/yolov4\" target=\"_blank\" rel=\"noopener\">https://github.com/zhiyiYo/yolov4</a>。</p> \n<h1 id=\"yolov4\">Yolov4</h1> \n<p>Yolov4 的神经网络结构相比 Yolov3 变化不是很大，主要更换了激活函数为 Mish，增加了 SPP 块和 PAN 结构（图源 <a href=\"https://blog.csdn.net/YOULANSHENGMENG/article/details/121909125\" target=\"_blank\" rel=\"noopener\">《yolo系列学习笔记----yolov4（SPP原理）》</a>）。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/d7c87ef4-2a17-4532-bf2e-9427608b66ee.jpeg\" alt=\"Yolov4 神经网络结构\" loading=\"lazy\"></p> \n<p>感觉 Yolov4 最大的特点就是使用了一大堆的 Trick，比如数据增强方面使用了马赛克数据增强、Mixup 数据增强，将定位损失函数更换为 CIOU 损失。论文中提到了很多的 Trick，我的代码中没有全部复现，不过在 VOC2012 数据集训练了 160 个 epoch 之后 mAP 也能达到 83%，效果还是不错的。</p> \n<p>可以在终端使用下述指令下载 Yolov4 的代码：</p> \n<pre><code class=\"language-shell\">git clone https://github.com/zhiyiYo/yolov4.git\n</code></pre> \n<h1 id=\"人脸口罩数据集\">人脸口罩数据集</h1> \n<p>网上可以找到很多人脸口罩数据集，这里使用的是 <a href=\"https://github.com/AIZOOTech/FaceMaskDetection\" target=\"_blank\" rel=\"noopener\">AIZOOTech</a> 提供的数据集。由于这个数据集的结构和 Pascal VOC 数据集不一样，所以重新组织一下数据集，并且修复和移除了数据集中的非法标签，可以在 <a href=\"https://www.kaggle.com/datasets/zhiyiyo/face-mask-dataset\" target=\"_blank\" rel=\"noopener\">Kaggle</a> 上下载此数据集。目前这个数据集包含 6130 张训练图像，1839 张测试图像，对于 Yolov4 的训练来说应该是绰绰有余的。下载完数据集将其解压到 <code>data</code> 文件夹下。</p> \n<p>在训练之前，我们需要使用 K-means 聚类算法对训练集中的边界框进行聚类，对于 416×416 的输入图像，聚类结果如下：</p> \n<pre><code class=\"language-python\">anchors = [\n    [[100, 146], [147, 203], [208, 260]],\n    [[26, 43], [44, 65], [65, 105]],\n    [[4, 8], [8, 15], [15, 27]]\n]\n</code></pre> \n<h1 id=\"训练神经网络\">训练神经网络</h1> \n<p>训练目标检测模型一般都需要加载预训练的主干网络的权重，可以从谷歌云盘下载预训练好的权重 <a href=\"https://drive.google.com/file/d/12oV8QL937S1JWFQhzLNPoqyYc_bi0lWT/view?usp=sharing\" target=\"_blank\" rel=\"noopener\">CSPDarknet53.pth</a> 并将其放在 <code>model</code> 文件夹下。这里给出训练所用的代码 <code>train.py</code>，使用 <code>python train.py</code> 就能开始训练。模型会先冻结训练上 50 个 epoch，接着解冻训练 110 个 epoch：</p> \n<pre><code class=\"language-python\"># coding:utf-8\nfrom net import TrainPipeline, VOCDataset\nfrom utils.augmentation_utils import YoloAugmentation, ColorAugmentation\n\n# 训练配置\nconfig = {\n    \"n_classes\": len(VOCDataset.classes),\n    \"image_size\": 416,\n    \"anchors\": [\n        [[100, 146], [147, 203], [208, 260]],\n        [[26, 43], [44, 65], [65, 105]],\n        [[4, 8], [8, 15], [15, 27]]\n    ],\n    \"darknet_path\": \"model/CSPdarknet53.pth\",\n    \"lr\": 1e-2,\n    \"batch_size\": 8,\n    \"freeze_batch_size\": 16,\n    \"freeze\": True,\n    \"freeze_epoch\": 50,\n    \"max_epoch\": 160,\n    \"start_epoch\": 0,\n    \"num_workers\": 4,\n    \"save_frequency\": 10,\n    \"no_aug_ratio\": 0\n}\n\n# 加载数据集\nroot = \'data/FaceMaskDataset/train\'\ndataset = VOCDataset(\n    root,\n    \'all\',\n    transformer=YoloAugmentation(config[\'image_size\']),\n    color_transformer=ColorAugmentation(config[\'image_size\']),\n    use_mosaic=True,\n    use_mixup=True,\n    image_size=config[\"image_size\"]\n)\n\nif __name__ == \'__main__\':\n    train_pipeline = TrainPipeline(dataset=dataset, **config)\n    train_pipeline.train()\n</code></pre> \n<h1 id=\"测试神经网络\">测试神经网络</h1> \n<p>训练完使用 <code>python evals.py</code> 可以测试所有保存的模型，<code>evals.py</code> 代码如下：</p> \n<pre><code class=\"language-python\"># coding:utf-8\nimport json\nfrom pathlib import Path\n\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\n\nfrom net import EvalPipeline, VOCDataset\n\nmpl.rc_file(\'resource/theme/matlab.mplstyle\')\n\n\n# 载入数据集\nroot = \'data/FaceMaskDataset/val\'\ndataset = VOCDataset(root, \'all\')\nanchors = [\n    [[100, 146], [147, 203], [208, 260]],\n    [[26, 43], [44, 65], [65, 105]],\n    [[4, 8], [8, 15], [15, 27]]\n]\n\n# 列出所有模型，记得修改 Yolo 模型文件夹的路径\nmodel_dir = Path(\'model/2022-10-05_22-59-44\')\nmodel_paths = [i for i in model_dir.glob(\'Yolo_*\')]\nmodel_paths.sort(key=lambda i: int(i.stem.split(\"_\")[1]))\n\n# 测试所有模型\nmAPs = []\niterations = []\nfor model_path in model_paths:\n    iterations.append(int(model_path.stem[5:]))\n    ep = EvalPipeline(model_path, dataset, anchors=anchors, conf_thresh=0.001)\n    mAPs.append(ep.eval()*100)\n\n# 保存数据\nwith open(\'eval/mAPs.json\', \'w\', encoding=\'utf-8\') as f:\n    json.dump(mAPs, f)\n    \n# 绘制 mAP 曲线\nfig, ax = plt.subplots(1, 1, num=\'mAP 曲线\')\nax.plot(iterations, mAPs)\nax.set(xlabel=\'iteration\', ylabel=\'mAP\', title=\'mAP curve\')\nplt.show()\n</code></pre> \n<p>得到的 mAP 曲线如下图所示，在第 120 个 epoch 达到最大值 94.14%：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/fc6be4f7-99ca-46e4-9fe8-7a7bb8eb3f7c.png\" alt=\"mAP 曲线\" loading=\"lazy\"></p> \n<p>下面使用一张真实图像看看训练效果如何，运行 <code>demo.py</code>：</p> \n<pre><code class=\"language-python\"># coding:utf-8\nfrom net import VOCDataset\nfrom utils.detection_utils import image_detect\n\n# 模型文件和图片路径\nmodel_path = \'model/Yolo_120.pth\'\nimage_path = \'resource/image/三上老师.jpg\'\n\n# 检测目标\nanchors = [\n    [[100, 146], [147, 203], [208, 260]],\n    [[26, 43], [44, 65], [65, 105]],\n    [[4, 8], [8, 15], [15, 27]]\n]\nimage = image_detect(model_path, image_path, VOCDataset.classes, anchors=anchors, conf_thresh=0.5)\nimage.show()\n</code></pre> \n<p>不错，效果非常好 ：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/0df9a929-975c-4fd2-b87f-75c4fdf5b632.jpeg\" alt=\"三上老师\" loading=\"lazy\"></p> \n<h1 id=\"后记\">后记</h1> \n<p>至此，介绍完了训练 Yolov4 人脸口罩检测模型的过程，代码放在了 <a href=\"https://github.com/zhiyiYo/yolov4\" target=\"_blank\" rel=\"noopener\">https://github.com/zhiyiYo/yolov4</a>，以上~~</p>',100,NULL,0,'https://www.cnblogs.com/zhiyiYo/p/16757345.html','2022-10-06 23:58:20'),(19,'第三章 知己知彼',NULL,NULL,0,0,'<p>知彼知己，百战不殆；不知彼而知己，一胜一负；不知彼，不知己，每战必殆。《谋攻篇》</p> \n<p><span style=\"font-family: 宋体\">前面两章其实重点是在掰扯数智化，</span>IT<span style=\"font-family: 宋体\">研发本身的数字化其实除了</span><span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">这一种手段之外还有很多，比如</span><span style=\"font-family: Calibri\">Low</span>&nbsp;Code<span style=\"font-family: 宋体\">、</span>RPA<span style=\"font-family: 宋体\">等等，</span><span style=\"font-family: Calibri\">AI</span><span style=\"font-family: 宋体\">都可以自动写代码了，还有啥是不可能的呢！不过本人能力有限，这点斤两也就敢玩玩</span><span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">，其他的碰都就不敢碰，接下来聚焦到</span><span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">的一些见解上。</span></p> \n<h2><strong>3</strong><strong>.1 <span style=\"font-family: 黑体\">剑锋所指</span></strong></h2> \n<p align=\"center\"><img src=\"http://localhost:8080/static/blogImages/2022/10/06/f9ab70de-9011-4871-81ff-2fa9a04612c3.png\" alt=\"\" loading=\"lazy\"></p> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<p align=\"center\">&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">作为云原生重要组成部分的</span>DevOps<span style=\"font-family: 宋体\">，跟云原生一样没有标准定义，不同的大厂都会结合自己的实际给出不同维度的注解。综合各家所言，我们可以重点提炼出</span><span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">的目标到底是什么呢？</span></p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"460\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"129\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p style=\"margin-left: 30px\">Atlassian</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"460\"> <p style=\"margin-left: 30px\">DevOps <span style=\"font-family: 宋体\">团队包含了开发和 </span><span style=\"font-family: Calibri\">IT </span><span style=\"font-family: 宋体\">运维，大家一起协作，共同参与产品的整个生命周期，一起为</span><strong>提升软件质量和加速软件开发过程</strong>而努力。</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"129\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p style=\"margin-left: 30px\">微软</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"460\"> <p style=\"margin-left: 30px\">DevOps <span style=\"font-family: 宋体\">是人、过程和产品的结合，使能持续地向终端用户</span><strong>交付价值</strong>。</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"129\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p style=\"margin-left: 30px\">AWS</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"460\"> <p style=\"margin-left: 30px\">DevOps <span style=\"font-family: 宋体\">是文化理念、实践和工具等的组合，能够</span><strong>提升</strong>一个组织快速<strong>交付应用和服务的能力</strong>。</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"129\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"460\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"129\"> <p>&nbsp;</p> </td> \n  </tr> \n </tbody> \n</table> \n<p style=\"margin-left: 30px\">DevOps<span style=\"font-family: 宋体\">剑锋所指何处？想必真正要玩</span><span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">的你心里肯定有自己的小九九了，就不再赘述总结了，每个人都可以有自己的见地。</span></p> \n<h2 style=\"margin-left: 30px\"><strong>3</strong><strong>.</strong><strong>2</strong><strong>&nbsp;<span style=\"font-family: 黑体\">最佳实践</span></strong></h2> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">多数情况下，开发的目标是快速发布更多的新特性，而运维的目标是保证更高的系统可用性。</span>DevOps <span style=\"font-family: 宋体\">通过切实可行的最佳实践体系来拉齐这两个目标，在提升系统稳定性的同时加速产品交付到市场的速度。</span></p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">这个最佳实践是什么呢？显而易见，就是形形色色的</span>“无穷环”。</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"437\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"177\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p style=\"margin-left: 30px\">Atlassian</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"437\"> <p>&nbsp;<img src=\"http://localhost:8080/static/blogImages/2022/10/06/cdf57d04-66a7-4d1c-896d-ced78c479848.png\" alt=\"\" loading=\"lazy\"></p> <p>&nbsp;</p> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"177\"> <p style=\"margin-left: 30px\">计划（<span style=\"font-family: Calibri\">Plan</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">构建（<span style=\"font-family: Calibri\">Build</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">持续集成和部署</p> <p style=\"margin-left: 30px\">监控和告警</p> <p style=\"margin-left: 30px\">运维（<span style=\"font-family: Calibri\">Operate</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">持续反馈</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p style=\"margin-left: 30px\">微软</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"437\"> <p>&nbsp;<img src=\"http://localhost:8080/static/blogImages/2022/10/06/50600a32-860d-411c-9968-2b643c86287d.png\" alt=\"\" loading=\"lazy\"></p> <p>&nbsp;</p> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"177\"> <p style=\"margin-left: 30px\">计划（<span style=\"font-family: Calibri\">Plan</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">构建（<span style=\"font-family: Calibri\">Build</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">持续集成</p> <p style=\"margin-left: 30px\">部署（<span style=\"font-family: Calibri\">Deploy</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">运维（<span style=\"font-family: Calibri\">Operate</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">持续反馈</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p style=\"margin-left: 30px\">AWS</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"437\"> <p>&nbsp;<img src=\"http://localhost:8080/static/blogImages/2022/10/06/60cf2355-c76f-4148-adb5-f8920688e56d.png\" alt=\"\" loading=\"lazy\"></p> <p>&nbsp;</p> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"177\"> <p style=\"margin-left: 30px\">构建（<span style=\"font-family: Calibri\">Build</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">测试（<span style=\"font-family: Calibri\">Test</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">发布（<span style=\"font-family: Calibri\">Release</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">监控（<span style=\"font-family: Calibri\">Monitor</span><span style=\"font-family: 宋体\">）</span></p> <p style=\"margin-left: 30px\">计划（<span style=\"font-family: Calibri\">Plan</span><span style=\"font-family: 宋体\">）</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"103\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"437\"> <p>&nbsp;</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"177\"> <p>&nbsp;</p> </td> \n  </tr> \n </tbody> \n</table> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">知彼部分是对《什么是</span> DevOps<span style=\"font-family: 宋体\">？看这一篇就够了！》（</span><span style=\"font-family: Calibri\">https://www.danielhu.cn/what-is-devops/</span><span style=\"font-family: 宋体\">）的解读，叫抄袭也行，还请原文作者多多海涵。</span>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">总结来讲，最佳实践都基本上指向了重要的三件套：</span>(<span style=\"font-family: 宋体\">技术</span><span style=\"font-family: Calibri\">)</span><span style=\"font-family: 宋体\">工具、流程和文化。</span></p> \n<h3 style=\"margin-left: 30px\"><strong>文化转变</strong></h3> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">结合</span>“开发”和“运营”，“<span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">”一词强调整合两个团队的活动以交付有效软件。 也就是说，范围不仅限于这些部门。所有参与软件开发和交付的人员都需要一致推进向用户交付有效软件的共同目标。</span></p> \n<p style=\"margin-left: 30px\">DevOps <span style=\"font-family: 宋体\">的核心是创造一种共担责任、相互信任和开放沟通的文化。 对于开发团队来说，在本地构建能够运行不足以表明工作已经完成。 为了交付可用于生产的代码，开发者需要代码和发布间步骤的可见性。 这意味着打破孤岛并与质量保证、安全和基础架构团队合作，以了解其在流程中的作用。</span></p> \n<h3 style=\"margin-left: 30px\"><strong>工具和自动化</strong></h3> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">虽然手动流程可以让团队间的合作更加紧密，但使用工具将尽可能多的工作自动化可以带来更高效率。</span> <span style=\"font-family: 宋体\">构建、测试和部署步骤自动化可使工作得以更快完成，这也意味着可以更快得出这些阶段的结果。</span> <span style=\"font-family: 宋体\">自动化是</span> DevOps <span style=\"font-family: 宋体\">方法的核心，能够实现紧密的反馈循环，这对于提高质量和消除浪费至关重要。</span></p> \n<h3 style=\"margin-left: 30px\"><strong>高效的流程</strong></h3> \n<p style=\"margin-left: 30px\">DevOps <span style=\"font-family: 宋体\">出现在精益制造原则开始应用于软件开发的时候。 精益的重点是通过优化流程中的每个阶段、提高质量并营造尊重的氛围来消除浪费。</span><span style=\"font-family: Calibri\">DevOps </span><span style=\"font-family: 宋体\">融合了大部分这种思想，并优化端到端流程，通过紧密反馈循环对正在构建的内容尽早提供反馈，提高软件开发效率。</span></p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">这涉及更早地进行下游开发活动，并在发现问题后立即解决。无论是失败的测试、安全漏洞还是构建问题。</span></p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">由于每个人都要分担向用户交付软件的责任，</span>“<span style=\"font-family: 宋体\">在我的机器上能用</span><span style=\"font-family: Calibri\">”</span><span style=\"font-family: 宋体\">的陈旧回应已经不再适用。 使用 </span><span style=\"font-family: Calibri\">DevOps </span><span style=\"font-family: 宋体\">方法，开发者可以更清楚地了解软件的使用方式和出现的挑战，从而更好地修正这些问题。</span></p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">采用</span> DevOps <span style=\"font-family: 宋体\">将敏捷的好处扩展到开发团队之外。 适应开发者的节奏并以较小的规模工作，可以更容易地发现和隔离问题，因为只有较少的变量在发挥作用。 同样，及时生成反馈可以避免在后续将弃置的测试和暂存构建上浪费精力。 反过来，这也将确保整个组织获得以较小增量工作的全部效益</span></p> \n<h2 style=\"margin-left: 30px\"><strong>3</strong><strong>.</strong><strong>3</strong><strong>&nbsp;</strong><strong>查缺补漏</strong></h2> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">当我们在说</span>DevOps<span style=\"font-family: 宋体\">建设时，到底要建设什么？说法千千万，选择自己偏信的信一信就行了，重点是结合自己所在境况，能够落地的，才是有价值的。</span></p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">梳理已有的能力，比起跟其他大厂或竞品所标榜的能力来个开发常挂在嘴边的</span>“拉齐”，来个知己知彼，至少各种半年、年度总结啥的有点存货可以拿出来讲讲。</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">以微软定义的</span> DevOps 8<span style=\"font-family: 宋体\">大能力为例，做了个简单的对照表，主要从工具、流程和文化三个角度进行。</span></p> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续计划</span> Continuous Planning</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">开宗明义</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">从简单云以及云效项目协作的功能来看，持续计划其实更侧重于于项目管理工具，基本上都是参考敏捷开发的主体思想，将<span style=\"font-family: Calibri\">IT</span><span style=\"font-family: 宋体\">研发迭代的工作流程、各工种协作、状态流转等整合进系统里。</span></p> <p style=\"margin-left: 30px\">类似功能的产品其实有很多，比如<span style=\"font-family: Calibri\">TAPD</span><span style=\"font-family: 宋体\">、</span><span style=\"font-family: Calibri\">Tower</span><span style=\"font-family: 宋体\">等。这些单纯只是研发工作流程的信息流转，不能链接作用到最终运行在</span><span style=\"font-family: Calibri\">Linux</span><span style=\"font-family: 宋体\">的“代码服务”跟着流转。比如，提测的时候把迭代分支代码，合并到测试分支，并且在测试环境发布本次变更。</span></p> <p style=\"margin-left: 30px\">持续计划是<span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">的源头，也是收尾处，这样才能成环。</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">Jira+Wiki,<span style=\"font-family: 宋体\">这应该是很多公司的标配了。</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">工具其实没啥好坏，真正有价值的是使用工具的人如何使用。工具够用就行，最多就是使用不方便、操作不友好这一大堆。要是问题在使用的人不懂做做计划、协调资源和控制进度，刀剑太锋利只会误伤人的手指。个人不是深度 持续计划使用者，所以感觉不出来欠缺啥。之前主要使用过<span style=\"font-family: Calibri\">TAPD</span><span style=\"font-family: 宋体\">、</span><span style=\"font-family: Calibri\">Tower</span><span style=\"font-family: 宋体\">。</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">没调研，总之要私有化部署。公司的核心秘密不能放到别人机房。</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">CP<span style=\"font-family: 宋体\">能力工具和文化的占比都不大，重要的是流程。制定执行流程的人，才是核心。</span></p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续集成</span> Continuous Integration</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">理解与说明</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">持续集成，简称<span style=\"font-family: Calibri\">CI</span><span style=\"font-family: 宋体\">，是软件开发周期的一种实践，把代码仓库（</span><span style=\"font-family: Calibri\">Gitlab</span><span style=\"font-family: 宋体\">或者</span><span style=\"font-family: Calibri\">Github</span><span style=\"font-family: 宋体\">）、构建工具（如</span><span style=\"font-family: Calibri\">Jenkins</span><span style=\"font-family: 宋体\">）和测试工具（</span><span style=\"font-family: Calibri\">SonarQube</span><span style=\"font-family: 宋体\">）集成在一起，频繁的将代码合并到主干然后自动进行构建和测试。简单来说持续集成就是向源代码</span><span style=\"font-family: Calibri\">/</span><span style=\"font-family: 宋体\">版本控制系统定期提交变更，以便每位成员都在同一基础上构建。 每次提交都会触发一个构建和一系列自动化测试，以验证行为并确保所做变更没有破坏任何已有内容。</span></p> <p style=\"margin-left: 30px\">最关键的是自动化测试，也是最难的。是后续“持续质量”重点解决的问题范畴。</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">但就<span style=\"font-family: Calibri\">CI</span><span style=\"font-family: 宋体\">的工具来地主家的余粮绰绰有余，在容器化建设之前</span><span style=\"font-family: Calibri\">Jenkins</span><span style=\"font-family: 宋体\">、</span><span style=\"font-family: Calibri\">Sonar</span><span style=\"font-family: 宋体\">等等工具早都有的。流程层面本来就不是问题，将这些工具通过各种</span><span style=\"font-family: Calibri\">Action</span><span style=\"font-family: 宋体\">串联起来。</span></p> <p style=\"margin-left: 30px\">自动化测试，也建设了专门的平台，而且还不止一个两个，外采的、自研的各式各样。</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">看上去似乎是不缺什么能力的，但是实际中也并不是那么乐观。这种“不科学”的时刻，得要往“文化”上想一想了。</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"115\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"597\"> <p style=\"margin-left: 30px\">CI<span style=\"font-family: 宋体\">能力，工具和流程都很容易信手拈来，极致体验的使用的。重点在于得有这么一个文化，让研发和测试信服或者强制遵循。</span></p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续交付</span> Continuous Delivery</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">开宗明义</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p style=\"margin-left: 30px\">鉴于<span style=\"font-family: Calibri\">CD</span><span style=\"font-family: 宋体\">既可以是</span><span style=\"font-family: Calibri\">Continuous &nbsp;Delivery</span><span style=\"font-family: 宋体\">又可以是</span><span style=\"font-family: Calibri\">Continuous &nbsp;Deployment</span><span style=\"font-family: 宋体\">，各种观点和分歧最后可能就分不清楚了。所以个人建议不加以区分了，笼统的来讲</span><span style=\"font-family: Calibri\">CD</span><span style=\"font-family: 宋体\">的能力，持续交付以由持续集成建立的构建和测试自动化为基础，将持续计划中的某个需求（泛指不仅仅是需求），从开发者到测试人员，再从测试人员到发布经理的交接，并最终把形成的“能力”发布到生产环境，交付给目标用户。</span></p> <p style=\"margin-left: 30px\">不论是手动还是自动，也不管有多少个环境，<span style=\"font-family: Calibri\">CD</span><span style=\"font-family: 宋体\">的最终目标就是向终端用户交付了价值。</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p style=\"margin-left: 30px\">从<span style=\"font-family: Calibri\">18</span><span style=\"font-family: 宋体\">年开始的容器化建设，一开始就主攻的</span><span style=\"font-family: Calibri\">CD</span><span style=\"font-family: 宋体\">能力。部署自动化</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p style=\"margin-left: 30px\">对于持续交付，资料太多、各家之言太杂乱反倒把最重要的部分给蒙蔽了。回归到码农的工作的本质，写好代码，最终要给用户“交付”一个东西（<span style=\"font-family: Calibri\">.exe/http://127.0.0.1:1024</span><span style=\"font-family: 宋体\">）。持续不断的，能够自动化的把写好的代码，变成终端用户可接受的那个“东西”，我觉得这就是</span><span style=\"font-family: Calibri\">CD</span><span style=\"font-family: 宋体\">了。</span></p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续运维</span> Continuous Operations</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">开宗明义</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p style=\"margin-left: 30px\">监控、告警、日志、链路追踪；监控自动化、配置自动化、作业自动化、日志分析自动化。</p> <p style=\"margin-left: 30px\">持续运维可减少或消除计划性故障时间或中断，例如计划性维护。 如果可能，应将基础结构、应用程序和服务的持续监视与自动化修正相关联。 用户应该永远不会知道何时发生更新或增量发布。</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p style=\"margin-left: 30px\">不论是人工手动，还是各种工具自动，公司再运维的投入比容器化是要大的。</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p>&nbsp;</p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续质量</span> Continuous Quality</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">开宗明义</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p style=\"margin-left: 30px\">构建可靠的自动化测试套件并在软件交付生命周期中执行各种扫描、测试，从而提高软件质量。</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p style=\"margin-left: 30px\">代码质量扫描、测试覆盖率、单元测试覆盖率、<span style=\"font-family: Calibri\">Java</span><span style=\"font-family: 宋体\">项目标准化、静态分析等等</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"113\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"599\"> <p style=\"margin-left: 30px\">交付质量，单纯的只有工具、流程建设肯定是不够的；单纯的只有测试人员也是不够的。</p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续安全</span> Continuous Security</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">开宗明义</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p style=\"margin-left: 30px\">DevSecOps <span style=\"font-family: 宋体\">强调了将安全性纳入软件开发生命周期 </span><span style=\"font-family: Calibri\">(SDLC) </span><span style=\"font-family: 宋体\">的重要性。 将安全性融入团队的文化、流程和工具，可以避免孤岛并确保快速交付不会以牺牲安全为代价。</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p style=\"margin-left: 30px\">主要是<span style=\"font-family: Calibri\">6</span><span style=\"font-family: 宋体\">种安全扫描工具</span></p> <p style=\"margin-left: 30px\">GitLeaks\\AWVS\\Nuclei\\IAST\\Twistlock\\<span style=\"font-family: 宋体\">奇安信安全扫描</span></p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续协作</span> Continuous Collaboration</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">开宗明义</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p style=\"margin-left: 30px\">持续协作是支持对任何 <span style=\"font-family: Calibri\">DevOps </span><span style=\"font-family: 宋体\">之旅至关重要的文化转变的做法。 持续协作使团队能够在计划的会议范围之外进行创新，并通过创建集成体验来促进团队内部的创新。可以使用技术和实践分解孤岛，即使没有理想的共同位置，团队也能一起工作。</span></p> <p style=\"margin-left: 30px\">从持续协作的角度回顾敏捷宣言，你将意识到，这实际上是关于进行协作和个人交互以实现真正的创新的价值。持续协作鼓励你重视：①个人与交互胜过进程与工具；②有效用的软件胜过全面的文档；③客户协作胜过合同协商；④响应变化胜过遵循计划</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"114\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"598\"> <p>&nbsp;</p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">持续改进</span> Continuous Improvement</p> \n<table style=\"margin-left: 30px\" border=\"1\" cellspacing=\"0\"> \n <tbody style=\"margin-left: 30px\"> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"112\"> <p style=\"margin-left: 30px\">开宗明义</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"600\"> <p style=\"margin-left: 30px\">连续且坦诚地观察你的 <span style=\"font-family: Calibri\">DevOps </span><span style=\"font-family: 宋体\">流程可使团队能够确定可能的改进点。所有的改进都需要改变，但并非所有的改变都是改进。 这就是为什么度量对于使用 </span><span style=\"font-family: Calibri\">DevOps </span><span style=\"font-family: 宋体\">的组织来说是成功的关键因素。 正如 </span><span style=\"font-family: Calibri\">Peter Drucker </span><span style=\"font-family: 宋体\">所说，“如果无法度量，就无法改善。”</span></p> <p style=\"margin-left: 30px\">缺乏有效的反馈机制使得难以提高应用对业务的影响。 这就是为什么有必要创建一个环境来促进以学习为中心的 <span style=\"font-family: Calibri\">DevOps </span><span style=\"font-family: 宋体\">改进方法，并着重于基于数据进行调整。</span></p> <p>&nbsp;<img src=\"http://localhost:8080/static/blogImages/2022/10/06/062a9f19-ed90-405c-95b6-1ccd95f8dd0b.png\" alt=\"\" loading=\"lazy\"></p> <p>&nbsp;</p> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"112\"> <p style=\"margin-left: 30px\">已有能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"600\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"112\"> <p style=\"margin-left: 30px\">欠缺能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"600\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"112\"> <p style=\"margin-left: 30px\">备选能力</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"600\"> <p>&nbsp;</p> </td> \n  </tr> \n  <tr style=\"margin-left: 30px\"> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"112\"> <p style=\"margin-left: 30px\">个人理解</p> </td> \n   <td style=\"margin-left: 30px\" valign=\"top\" width=\"600\"> <p>&nbsp;</p> </td> \n  </tr> \n </tbody> \n</table> \n<p>&nbsp;</p> \n<h2 style=\"margin-left: 30px\"><strong>3</strong><strong>.</strong><strong>4</strong><strong>&nbsp;</strong><strong>结语</strong></h2> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">工具和能力都是散落的点，真正能体现水平的是如何形成良性的</span>“无穷环”，如果觉得无穷太大了，那至少得是能够“闭环”。</p> \n<p style=\"margin-left: 30px\"><span style=\"font-family: 宋体\">经过</span>4<span style=\"font-family: 宋体\">年多的容器化建设，以及相关研发能力的完备，</span><span style=\"font-family: Calibri\">DevOps</span><span style=\"font-family: 宋体\">的</span><span style=\"font-family: Calibri\">8</span><span style=\"font-family: 宋体\">大能力基本上是具备的，现在重中之重是如何进行“包装上架”。利用已有的平台，成体系的整合完备。</span></p>',100,NULL,0,'https://www.cnblogs.com/KendoCross/p/16757312.html','2022-10-06 23:58:26'),(20,'一篇文章带你掌握主流服务层框架——SpringMVC',NULL,NULL,0,0,'<h1 id=\"一篇文章带你掌握主流服务层框架springmvc\">一篇文章带你掌握主流服务层框架——SpringMVC</h1> \n<p>在之前的文章中我们已经学习了Spring的基本内容，SpringMVC隶属于Spring的一部分内容</p> \n<p>但由于SpringMVC完全针对于服务层使用，所以我们在介绍时常常把SpringMVC单独当作一个大章节来学习</p> \n<blockquote> \n <p>温馨提醒：在学习SpringMVC前请确保已学习Spring内容</p> \n</blockquote> \n<h2 id=\"springmvc简介\">SpringMVC简介</h2> \n<p>首先我们先来简单了解一下SpringMVC：</p> \n<ul> \n <li>SpringMVC是一种基于Java实现MVC模型的轻量级Web框架</li> \n <li>SpringMVC致力于服务层，同Servlet一样应用于服务层，用于服务层开发</li> \n <li>SpringMVC隶属于Spring，同样具有简化代码，使用简单，开发便捷，灵活性强的优点</li> \n</ul> \n<h3 id=\"springmvc入门案例\">SpringMVC入门案例</h3> \n<p>在未学习SpringMVC之前，我们的服务端开发通常采用Servlet：</p> \n<pre><code class=\"language-java\">package com.itheima.web.servlet.old;\n\nimport com.alibaba.fastjson.JSON;\nimport com.itheima.pojo.Brand;\nimport com.itheima.service.BrandService;\nimport com.itheima.service.impl.BrandServiceImpl;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.List;\n\n//@WebServlet(\"/addServlet\")\npublic class AddServlet extends HttpServlet {\n\n    private BrandService brandService = new BrandServiceImpl();\n\n    @Override\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\n        //1. 接收品牌数据\n        BufferedReader br = request.getReader();\n        String params = br.readLine();//json字符串\n\n        //转为Brand对象\n        Brand brand = JSON.parseObject(params, Brand.class);\n\n        //2. 调用service添加\n        brandService.add(brand);\n\n        //3. 响应成功的标识\n        response.getWriter().write(\"success\");\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n        this.doGet(request, response);\n    }\n}\n</code></pre> \n<p>我们可以注意到其过程非常繁琐，因为我们需要获取参数并进行类型转换，包括添加至Service等过程</p> \n<p>但是SpringMVC秉承着简化代码的原则，将大部分内容转化为Java代码进行封装，大大减少了繁琐的过程</p> \n<p>接下来我们来介绍SpringMVC版：</p> \n<ol> \n <li>导入jar包</li> \n</ol> \n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;com.itheima&lt;/groupId&gt;\n  &lt;artifactId&gt;springmvc_01_quickstart&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;war&lt;/packaging&gt;\n\n  &lt;dependencies&gt;\n&lt;!--    servlet坐标--&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n      &lt;version&gt;3.1.0&lt;/version&gt;\n      &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;/dependency&gt;\n&lt;!--    SpringMVC坐标--&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n&lt;!--Tomcat配置--&gt;\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;2.1&lt;/version&gt;\n        &lt;configuration&gt;\n          &lt;port&gt;80&lt;/port&gt;\n          &lt;path&gt;/&lt;/path&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n\n\n&lt;/project&gt;\n</code></pre> \n<ol start=\"2\"> \n <li>创建SpringMVC控制类（等同于Servlet类）</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n//定义表现层控制器bean\n@Controller\npublic class UserController {\n\n    //设置映射路径为/save，即外部访问路径\n    @RequestMapping(\"/save\")\n    //设置当前操作返回结果为指定json数据（本质上是一个字符串信息）\n    @ResponseBody\n    public String save(){\n        System.out.println(\"user save ...\");\n        return \"{\'info\':\'springmvc\'}\";\n    }\n\n    //设置映射路径为/delete，即外部访问路径\n    @RequestMapping(\"/delete\")\n    @ResponseBody\n    public String delete(){\n        System.out.println(\"user save ...\");\n        return \"{\'info\':\'springmvc\'}\";\n    }\n}\n</code></pre> \n<ol start=\"3\"> \n <li>初始化SpringMVC环境（同Spring一样创建Config配置Java类）</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n//springmvc配置类，本质上还是一个spring配置类\n@Configuration\n@ComponentScan(\"com.itheima.controller\")\npublic class SpringMvcConfig {\n}\n</code></pre> \n<ol start=\"4\"> \n <li>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求</li> \n</ol> \n<pre><code class=\"language-java\">/*\n我们服务层的实际操作都是放置于Servlet容器中\n我们配置的SpringMVC和Spring环境都是用于服务层，所以我们需要把相关Config加载仅Servlet容器中\n*/\n\npackage com.itheima.config;\n\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;\nimport org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;\n\n// web容器配置类\n// AbstractDispatcherServletInitializer是SpringMVC为我们设置好的类，继承并实现相关方法即可\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {\n    //加载springmvc配置类，产生springmvc容器（本质还是spring容器）\n    protected WebApplicationContext createServletApplicationContext() {\n        //初始化WebApplicationContext对象\n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\n        //加载指定配置类\n        ctx.register(SpringMvcConfig.class);\n        return ctx;\n    }\n\n    //设置由springmvc控制器处理的请求映射路径\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n\n    //加载spring配置类\n    protected WebApplicationContext createRootApplicationContext() {\n        return null;\n    }\n}\n</code></pre> \n<p>我们对上述新的内容进行解析：</p> \n<ol> \n <li> <p>@Controller</p> \n  <ul> \n   <li> <p>名称：@Controller</p> </li> \n   <li> <p>类型：类注解</p> </li> \n   <li> <p>位置：SpringMVC控制类定义上方</p> </li> \n   <li> <p>作用：设定SpringMVC的核心控制器Bean</p> </li> \n  </ul> </li> \n <li> <p>@RequestMapping</p> \n  <ul> \n   <li> <p>名称：@RequestMapping</p> </li> \n   <li> <p>类型：方法注解</p> </li> \n   <li> <p>位置：SpringMVC控制器方法定义上方</p> </li> \n   <li> <p>作用：设置当前控制器方法请求访问路径</p> </li> \n   <li> <p>相关属性：value（请求访问路径）</p> </li> \n  </ul> </li> \n <li> <p>@ResponseBody</p> \n  <ul> \n   <li> <p>名称：@ResponseBody</p> </li> \n   <li> <p>类型：方法注释</p> </li> \n   <li> <p>位置：SpringMVC控制器方法定义上方</p> </li> \n   <li> <p>作用：设置当前控制器方法响应内容为当前返回值，无需解析</p> </li> \n  </ul> </li> \n <li> <p>AbstractDispatcherServletInitializer类</p> \n  <ul> \n   <li>AbstractDispatcherServletInitializer是SpringMVC提供的快速初始化Web3.0容器的抽象类</li> \n   <li>AbstractDispatcherServletInitializer提供三个接口方法供用户实现</li> \n   <li>createServletApplicationContext方法用于创建Servlet容器时，加载SpringMVC对应的Bean并放入</li> \n   <li>AnnotationConfigWebApplicationContext的作用范围对应整个Web容器范围，必须使用WebApplicationcontext类型</li> \n  </ul> </li> \n</ol> \n<p>最后我们总结一下上述操作的出现频率：</p> \n<ul> \n <li>一次性工作 \n  <ul> \n   <li>创建工程，设置服务器，加载工程</li> \n   <li>导入坐标</li> \n   <li>创建Web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径</li> \n   <li>SpringMVC核心配置类（设置配置类，扫描controller包，加载Controller控制器Bean）</li> \n  </ul> </li> \n <li>常态工作 \n  <ul> \n   <li>定义处理请求的控制类</li> \n   <li>定义处理请求的操作方法，并设置映射路径（@RequestMapper）与返回Json数据（@ResponseBody）</li> \n  </ul> </li> \n</ul> \n<h3 id=\"springmvc工作流程\">SpringMVC工作流程</h3> \n<p>在分析SpringMVC工作流程前，我们需要知道服务层是由下面的框架组成的：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/14388dac-74f8-4418-8043-5ae5ef6578d0.png\" alt=\"\" loading=\"lazy\"></p> \n<p>启动服务器初始化过程：</p> \n<ol> \n <li>服务器启动，执行ServletContainersInitConfig类，初始化Web容器</li> \n <li>执行createServletApplicationContext方法，创建了WebApplicationContext对象</li> \n <li>加载SpringMvcConfig</li> \n <li>执行@ComponentScan加载对应的bean</li> \n <li>加载UserController，每个@RequestMapping的名称对应一个具体的方法</li> \n <li>执行getServletMappings方法，定义所有的请求都通过SpringMVC</li> \n</ol> \n<p>单次请求过程：</p> \n<ol> \n <li>发送请求localhost/save</li> \n <li>Web容器发现所有请求都经过SpirngMVC，将请求交给SpringMVC处理</li> \n <li>解析请求路径/save</li> \n <li>由/save匹配执行对应的方法save()</li> \n <li>执行save()</li> \n <li>检测到有@ResponseBody直接将save()方法的返回值作为响应求体返回给请求方</li> \n</ol> \n<h3 id=\"springmvc加载控制\">SpringMVC加载控制</h3> \n<p>在学习SpringMVC之后，我们的Bean的范围逐渐变大：</p> \n<ul> \n <li>SpringMVC相关bean（表现层bean）</li> \n <li>Spring相关bean（业务层Service，功能DataSource等）</li> \n</ul> \n<p>但是我们在使用时，需要区分相关bean的导入路径：</p> \n<ul> \n <li>SpringMVC加载的bean对应的包均在com.itheima.controller包内</li> \n <li>Spring加载的bean却包含有多个文件夹</li> \n</ul> \n<p>因而我们给出两种方法来解决Spring的扫描问题：</p> \n<ol> \n <li>Spring加载的bean设定范围为com.itheima，并排除掉controller包内的bean</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\n\n@Configuration\n/*\n@ComponentScan注解设置扫描范围\n@ComponentScan中包含有value，excludeFilters属性\nvalue：用于控制扫描范围\nexcludeFilters：用于控制排除范围，需要采用@ComponentScan.Filter过滤器\ntype:设置排除规则，当前使用按照bean定义时的注解类型进行排除\nclasses属性：设置排除的具体注解类，当前设置排除@Controller定义的bean\n*/\n@ComponentScan(value=\"com.itheima\",\n    excludeFilters = @ComponentScan.Filter(\n        type = FilterType.ANNOTATION,\n        classes = Controller.class\n    )\n)\npublic class SpringConfig {\n}\n\n/*\n这里做一个小补充内容：\n@ComponentScan中除了excludeFilters，还包括有includeFilters\nincludeFilters：加载指定的bean，需要指定类型（type）和具体项（classes）\n*/\n</code></pre> \n<ol start=\"2\"> \n <li>Spring加载的bean设定范围为精准范围，例如service包，dao包等</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.FilterType;\nimport org.springframework.stereotype.Controller;\n\n@Configuration\n@ComponentScan({\"com.itheima.service\",\"com.itheima.dao\"})\npublic class SpringConfig {\n}\n</code></pre> \n<h3 id=\"servlet容器简化写法\">Servlet容器简化写法</h3> \n<p>我们的Servlet容器中可以定义Spring和SpringMVC的配置文件</p> \n<pre><code class=\"language-java\">package com.itheima.config;\n\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\nimport org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;\n\npublic class ServletContainersInitConfig extends AbstractDispatcherServletInitializer {\n    \n    // 配置SpringMVC配置文件\n    protected WebApplicationContext createServletApplicationContext() {\n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\n        ctx.register(SpringMvcConfig.class);\n        return ctx;\n    }\n    \n    // 配置Spring配置文件\n    protected WebApplicationContext createRootApplicationContext() {\n        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();\n        ctx.register(SpringConfig.class);\n        return ctx;\n    }\n    \n    // 配置拦截路径\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n\n}\n</code></pre> \n<blockquote> \n <p>我们可以注意到：</p> \n <p>Spring和SpringMVC导入方法中均采用AnnotationConfigWebApplicationContext来创建对象</p> \n <p>两者之间的区别仅仅是class包的不同</p> \n</blockquote> \n<p>Spring给了我们一种新的继承类用于简化开发：</p> \n<pre><code class=\"language-java\">package com.itheima.config;\n\nimport org.springframework.web.context.WebApplicationContext;\nimport org.springframework.web.context.support.AnnotationConfigWebApplicationContext;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\nimport org.springframework.web.servlet.support.AbstractDispatcherServletInitializer;\n//web配置类简化开发，仅设置配置类类名即可\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n\n    protected Class&lt;?&gt;[] getRootConfigClasses() {\n        return new Class[]{SpringConfig.class};\n    }\n\n    protected Class&lt;?&gt;[] getServletConfigClasses() {\n        return new Class[]{SpringMvcConfig.class};\n    }\n\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n}\n</code></pre> \n<blockquote> \n <p>注意：</p> \n <p>AbstractAnnotationConfigDispatcherServletInitializer是createServletApplicationContext的继承类</p> \n <p>我们同样继承它的三个方法，但这次我们只需要在里面标明相关类和路径即可</p> \n</blockquote> \n<h2 id=\"常用工具推荐postman\">常用工具推荐Postman</h2> \n<p>在我们的SpringMVC中岔开一个话题：</p> \n<ul> \n <li>关于我们的网页调试的复杂性</li> \n</ul> \n<p>我们在一个网页开发中，会不断的调试网页，通过各种路径反复查询或者采用不同的访问方式（GET/POST）</p> \n<p>如果我们采用正常的网页进行测试，无疑会出现非常麻烦的步骤</p> \n<p>所以我们推荐采用Postman软件，下面我们将会简单做一下介绍</p> \n<h3 id=\"postman链接\">Postman链接</h3> \n<p>首先为大家附上链接：</p> \n<ul> \n <li>下载链接：<a href=\"https://app.getpostman.com/app/download/win64?\" target=\"_blank\" rel=\"noopener\">Download Postman (getpostman.com)</a></li> \n <li>文档链接：<a href=\"https://postman.org.cn/\" target=\"_blank\" rel=\"noopener\">PostMan中文文档</a></li> \n <li>整合链接：<a href=\"https://www.apipost.cn/?utm_source=10040&amp;qhclickid=0951b08b69d340a4\" target=\"_blank\" rel=\"noopener\">Apipost-API 文档、设计、调试、自动化测试一体化协作平台</a></li> \n</ul> \n<h3 id=\"postman操作讲解\">Postman操作讲解</h3> \n<p>在了解操作前，我们需要明白Postman的作用：</p> \n<ul> \n <li>用于分类存储网页请求</li> \n <li>用于发送请求进行测试</li> \n</ul> \n<p>关于安装注册的过程我们不再赘述</p> \n<h3 id=\"postman页面展示\">Postman页面展示</h3> \n<p>我们先来查看Postman的主页：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/06/c46bf834-04f5-45eb-84c3-20103fcf53a2.png\" alt=\"\" loading=\"lazy\"></p> \n<p>首先我们可以看到左上角的Workspaces，这个是最大的分类空间</p> \n<p>我们可以看到左上角SpringMVC，这是我所创建的WorkSpaces，关于我在SpringMVC所做的网页测试部分将都在这里进行</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/69fe4024-5b50-4b21-844e-2b72680c9e68.png\" alt=\"\" loading=\"lazy\"></p> \n<p>除此之外，我们可以看到右侧的DEMO1，以及内部的测试用例文件夹，以及项目save</p> \n<p>以上就是我们的Postman的基本页面</p> \n<h3 id=\"postman具体使用\">Postman具体使用</h3> \n<p>我们的Postman的具体使用流程如下：</p> \n<ol> \n <li>创建新的Workspaces</li> \n</ol> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/64da6fa9-539f-4be2-95e8-53fede493e61.png\" alt=\"\" loading=\"lazy\"></p> \n<ol start=\"2\"> \n <li>选定主界面，创建对应文件夹</li> \n</ol> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/b91a8f3e-f151-4249-ab19-840a5334422a.png\" alt=\"\" loading=\"lazy\"></p> \n<ol start=\"3\"> \n <li>创建项目(点击中间区域的加号)</li> \n</ol> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/f5c271d9-3084-45eb-9e3f-292f7f5fb6af.png\" alt=\"\" loading=\"lazy\"></p> \n<ol start=\"4\"> \n <li>书写项目内容（GET可以更换其他类型，后面书写URL，下方key，value书写传递数据）</li> \n</ol> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/e5ebe97a-cd1f-462a-8a31-a37f7d69a122.png\" alt=\"\" loading=\"lazy\"></p> \n<ol start=\"5\"> \n <li>下方的数据传递可以更换类型，例如更换为body体的raw来书写JSON格式</li> \n</ol> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/7bafd3af-c9de-4b89-bd95-c26f48a7d877.png\" alt=\"\" loading=\"lazy\"></p> \n<ol start=\"6\"> \n <li>书写后保存到相应列表并标注名称</li> \n</ol> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/12bf02a1-ade0-470d-910d-83e0c5950e80.png\" alt=\"\" loading=\"lazy\"></p> \n<p>到这里，我们Postman的基本使用基本就结束了，到后面我们会对具体内容做具体补充~</p> \n<h2 id=\"springmvc设置请求与响应\">SpringMVC设置请求与响应</h2> \n<p>SpringMVC和Servlet同属于服务层的工具，那么必不可少的就是请求与响应的反馈问题</p> \n<p>接下来我们将一一介绍请求与响应的相关知识</p> \n<h3 id=\"请求映射路径设置\">请求映射路径设置</h3> \n<p>首先我们先来想一想我们之前的路径设置是否有那么一点点缺陷？</p> \n<pre><code class=\"language-java\">// Book的服务层\n\npackage com.itheima.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class BookController {\n    //请求路径映射\n    @RequestMapping(\"/save\")\n    @ResponseBody\n    public String save(){\n        System.out.println(\"book save ...\");\n        return \"{\'module\':\'book save\'}\";\n    }\n}\n</code></pre> \n<pre><code class=\"language-java\">// User的服务层\n\npackage com.itheima.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class UserController {\n    //请求路径映射\n    @RequestMapping(\"/save\")\n    @ResponseBody\n    public String save(){\n        System.out.println(\"user save ...\");\n        return \"{\'module\':\'user save\'}\";\n    }\n    //请求路径映射\n    @RequestMapping(\"/delete\")\n    @ResponseBody\n    public String delete(){\n        System.out.println(\"user delete ...\");\n        return \"{\'module\':\'user delete\'}\";\n    }\n\n}\n</code></pre> \n<p>我们可以注意到我们的单个项目中不可能只包括有一个服务层</p> \n<p>但我们的请求映射路径却只是简单设计为相同的名称，就会导致我们访问该页面时，系统无法匹配</p> \n<p>所以我们需要给他们采用不同的映射路径，我们常有的操作是直接在前面加上一层该类的路径名：</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\npublic class BookController {\n    //请求路径映射\n    @RequestMapping(\"/book/save\")\n    @ResponseBody\n    public String save(){\n        System.out.println(\"book save ...\");\n        return \"{\'module\':\'book save\'}\";\n    }\n}\n</code></pre> \n<p>但当项目逐渐增多，我们多次书写路径名就有可能导致错误，所以我们采用类注解@RequestMapping来解决：</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\n@Controller\n//类上方配置的请求映射与方法上面配置的请求映射连接在一起，形成完整的请求映射路径\n@RequestMapping(\"/user\")\npublic class UserController {\n    //请求路径映射\n    @RequestMapping(\"/save\")\n    @ResponseBody\n    public String save(){\n        System.out.println(\"user save ...\");\n        return \"{\'module\':\'user save\'}\";\n    }\n    //请求路径映射\n    @RequestMapping(\"/delete\")\n    @ResponseBody\n    public String delete(){\n        System.out.println(\"user delete ...\");\n        return \"{\'module\':\'user delete\'}\";\n    }\n\n}\n</code></pre> \n<blockquote> \n <p>注意：@RequestMapping不仅仅可以用于方法表示映射，也可以用于整个Bean类中表示映射前缀</p> \n</blockquote> \n<h3 id=\"参数传递问题\">参数传递问题</h3> \n<p>关于参数传递我们从三个方面来讲解：</p> \n<ul> \n <li>传递方式</li> \n <li>传递参数类型</li> \n <li>特殊参数类型</li> \n</ul> \n<h4 id=\"按传递方式\">按传递方式</h4> \n<p>我们的传递方式通常采用GET或者POST方式</p> \n<p>但在前面的学习中我们可以知道我们的传递方式是有不同的，我们在Postman的书写形式也是不同的</p> \n<p>例如我们先给出一个简单的参数传递函数</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //普通参数：请求参数与形参名称对应即可完成参数传递\n    @RequestMapping(\"/commonParam\")\n    @ResponseBody\n    public String commonParam(String name ,int age){\n        System.out.println(\"普通参数传递 name ==&gt; \"+name);\n        System.out.println(\"普通参数传递 age ==&gt; \"+age);\n        return \"{\'module\':\'common param\'}\";\n    }\n\n}\n</code></pre> \n<p>我们的GET方式直接在网页后用？和&amp;来书写传递参数：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/155ce7d8-af42-4d63-9150-7683a457b143.png\" alt=\"\" loading=\"lazy\"></p> \n<p>我们的POST方式只能在下方的body中书写参数：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/30fe3ea9-ed0e-42e8-a752-1ba868b5ec75.png\" alt=\"\" loading=\"lazy\"></p> \n<p>然后我们需要注意到的是这里的中文同样会出现乱码行为</p> \n<p>这次我们选择在ServletContainersInitConfig中处理数据：</p> \n<pre><code class=\"language-java\">// 下述代码基本属于我们创建项目的固定代码\n\npackage com.itheima.config;\n\nimport org.springframework.web.filter.CharacterEncodingFilter;\nimport org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;\n\nimport javax.servlet.Filter;\n\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer {\n    protected Class&lt;?&gt;[] getRootConfigClasses() {\n        return new Class[0]{SpringConfig.class};\n    }\n\n    protected Class&lt;?&gt;[] getServletConfigClasses() {\n        return new Class[]{SpringMvcConfig.class};\n    }\n\n    protected String[] getServletMappings() {\n        return new String[]{\"/\"};\n    }\n\n    //乱码处理\n    @Override\n    protected Filter[] getServletFilters() {\n        // CharacterEncodingFilter 属于处理中文编码的过滤器，我们直接创建即可（一次性操作）\n        CharacterEncodingFilter filter = new CharacterEncodingFilter();\n        filter.setEncoding(\"UTF-8\");\n        return new Filter[]{filter};\n    }\n}\n</code></pre> \n<h4 id=\"按参数方式\">按参数方式</h4> \n<p>我们按参数来分类主要分为五种：</p> \n<ul> \n <li>普通参数</li> \n <li>POJO类</li> \n <li>嵌套式POJO类</li> \n <li>数组参数</li> \n <li>集合参数</li> \n</ul> \n<p>我们下面来一一介绍</p> \n<h5 id=\"普通参数\">普通参数</h5> \n<p>普通参数：请求参数和形参变量名相同时，自动匹配</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //普通参数：请求参数与形参名称对应即可完成参数传递\n    @RequestMapping(\"/commonParam\")\n    @ResponseBody\n    public String commonParam(String name ,int age){\n        System.out.println(\"普通参数传递 name ==&gt; \"+name);\n        System.out.println(\"普通参数传递 age ==&gt; \"+age);\n        return \"{\'module\':\'common param\'}\";\n    }\n\n}\n</code></pre> \n<p>Postman操作：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/06/f99136a1-f2c5-4c42-a653-0d181e78fa38.png\" alt=\"\" loading=\"lazy\"></p> \n<p>这里需要注意：当请求参数名与形参名不同时，使用@RequestParam注解关联请求参数名称与形参名称之间的关系</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //普通参数：请求参数名与形参名不同时，使用@RequestParam注解关联请求参数名称与形参名称之间的关系\n    @RequestMapping(\"/commonParamDifferentName\")\n    @ResponseBody\n    public String commonParamDifferentName(@RequestParam(\"name\") String userName , int age){\n        System.out.println(\"普通参数传递 userName ==&gt; \"+userName);\n        System.out.println(\"普通参数传递 age ==&gt; \"+age);\n        return \"{\'module\':\'common param different name\'}\";\n    }\n\n}\n</code></pre> \n<p>Postman操作：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/72a83508-0b79-4b9f-a6cb-02b26dda8706.png\" alt=\"\" loading=\"lazy\"></p> \n<blockquote> \n <p>@RequestParam：绑定请求参数与处理器方法形参间的关系</p> \n <p>包含有两个参数</p> \n <p>required：是否为必传参数</p> \n <p>defaultValue：参数默认值</p> \n</blockquote> \n<h5 id=\"pojo参数\">POJO参数</h5> \n<p>POJO参数：请求参数名与形参对象属性名相同，定义POJO类型形参即可接收参数</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //POJO参数：请求参数与形参对象中的属性对应即可完成参数传递\n    @RequestMapping(\"/pojoParam\")\n    @ResponseBody\n    public String pojoParam(User user){\n        System.out.println(\"pojo参数传递 user ==&gt; \"+user);\n        return \"{\'module\':\'pojo param\'}\";\n    }\n\n}\n</code></pre> \n<p>Postman操作：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/5e9ddbe3-f0bf-485f-80d0-ba136fdae6e9.png\" alt=\"\" loading=\"lazy\"></p> \n<h5 id=\"嵌套pojo参数\">嵌套POJO参数</h5> \n<p>嵌套POJO参数：请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJO属性参数</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //嵌套POJO参数：嵌套属性按照层次结构设定名称即可完成参数传递\n    @RequestMapping(\"/pojoContainPojoParam\")\n    @ResponseBody\n    public String pojoContainPojoParam(User user){\n        System.out.println(\"pojo嵌套pojo参数传递 user ==&gt; \"+user);\n        return \"{\'module\':\'pojo contain pojo param\'}\";\n    }\n\n}\n</code></pre> \n<p>Postman操作：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/188e5a6e-0818-4792-8017-c5f8d03cb40c.png\" alt=\"\" loading=\"lazy\"></p> \n<h5 id=\"数组参数\">数组参数</h5> \n<p>数组参数：请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //数组参数：同名请求参数可以直接映射到对应名称的形参数组对象中\n    @RequestMapping(\"/arrayParam\")\n    @ResponseBody\n    public String arrayParam(String[] likes){\n        System.out.println(\"数组参数传递 likes ==&gt; \"+ Arrays.toString(likes));\n        return \"{\'module\':\'array param\'}\";\n    }\n\n}\n</code></pre> \n<p>Postman操作：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/06/d02ce86a-52c9-4726-8dd2-ba4263ace678.png\" alt=\"\" loading=\"lazy\"></p> \n<h5 id=\"集合保存普通参数\">集合保存普通参数</h5> \n<p>集合保存普通参数：请求参数与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据\n    @RequestMapping(\"/listParam\")\n    @ResponseBody\n    public String listParam(@RequestParam List&lt;String&gt; likes){\n        System.out.println(\"集合参数传递 likes ==&gt; \"+ likes);\n        return \"{\'module\':\'list param\'}\";\n    }\n\n}\n</code></pre> \n<p>Postman参数：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/8491228b-d4f3-45f2-8ded-4b95d15e5983.png\" alt=\"\" loading=\"lazy\"></p> \n<h4 id=\"按特殊参数方式\">按特殊参数方式</h4> \n<p>我们的特殊参数主要介绍两种：</p> \n<ul> \n <li>JSON类型</li> \n <li>日期类型</li> \n</ul> \n<p>我们下面一一介绍</p> \n<h5 id=\"json类型\">JSON类型</h5> \n<p>JSON类型是我们Web开发中最常用的类型，所以这一部分算是一个小重点</p> \n<p>我们将一一讲解JSON类型传递的步骤：</p> \n<ol> \n <li>导入JSON坐标</li> \n</ol> \n<pre><code class=\"language-xml\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n  &lt;groupId&gt;com.itheima&lt;/groupId&gt;\n  &lt;artifactId&gt;springmvc_04_request_param&lt;/artifactId&gt;\n  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n  &lt;packaging&gt;war&lt;/packaging&gt;\n\n  &lt;dependencies&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;\n      &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;\n      &lt;version&gt;3.1.0&lt;/version&gt;\n      &lt;scope&gt;provided&lt;/scope&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;org.springframework&lt;/groupId&gt;\n      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;\n      &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;\n    &lt;/dependency&gt;\n      &lt;!--JSON坐标---&gt;\n    &lt;dependency&gt;\n      &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n      &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n      &lt;version&gt;2.9.0&lt;/version&gt;\n    &lt;/dependency&gt;\n  &lt;/dependencies&gt;\n\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;\n        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;\n        &lt;version&gt;2.1&lt;/version&gt;\n        &lt;configuration&gt;\n          &lt;port&gt;80&lt;/port&gt;\n          &lt;path&gt;/&lt;/path&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n&lt;/project&gt;\n\n</code></pre> \n<ol start=\"2\"> \n <li>在SpringMVC配置类中添加JSON类型转换注解</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.config;\n\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.filter.CharacterEncodingFilter;\nimport org.springframework.web.servlet.config.annotation.EnableWebMvc;\n\nimport javax.servlet.Filter;\nimport javax.servlet.annotation.WebFilter;\n\n@Configuration\n@ComponentScan(\"com.itheima.controller\")\n//开启json数据类型自动转换\n@EnableWebMvc\npublic class SpringMvcConfig {\n}\n</code></pre> \n<ol start=\"3\"> \n <li>在Controller中书写相关Web代码(注意：需要使用@RequestBody表示将请求体数据传递给请求参数)</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //集合参数：json格式\n    //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc\n    //2.使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据\n    @RequestMapping(\"/listParamForJson\")\n    @ResponseBody\n    public String listParamForJson(@RequestBody List&lt;String&gt; likes){\n        System.out.println(\"list common(json)参数传递 list ==&gt; \"+likes);\n        return \"{\'module\':\'list common for json param\'}\";\n    }\n\n    //POJO参数：json格式\n    //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc\n    //2.使用@RequestBody注解将外部传递的json数据映射到形参的实体类对象中，要求属性名称一一对应\n    @RequestMapping(\"/pojoParamForJson\")\n    @ResponseBody\n    public String pojoParamForJson(@RequestBody User user){\n        System.out.println(\"pojo(json)参数传递 user ==&gt; \"+user);\n        return \"{\'module\':\'pojo for json param\'}\";\n    }\n\n    //集合参数：json格式\n    //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc\n    //2.使用@RequestBody注解将外部传递的json数组数据映射到形参的保存实体类对象的集合对象中，要求属性名称一一对应\n    @RequestMapping(\"/listPojoParamForJson\")\n    @ResponseBody\n    public String listPojoParamForJson(@RequestBody List&lt;User&gt; list){\n        System.out.println(\"list pojo(json)参数传递 list ==&gt; \"+list);\n        return \"{\'module\':\'list pojo for json param\'}\";\n    }\n    \n}\n</code></pre> \n<p>Postman操作：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/da2ad071-ff15-4031-844c-28402c1907f5.png\" alt=\"\" loading=\"lazy\"></p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/157d96d3-bf64-48c9-a9ce-2c0dc72abf25.png\" alt=\"\" loading=\"lazy\"></p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/06/7c7d0af3-c708-4f6b-8cf2-cb372c0f84e7.png\" alt=\"\" loading=\"lazy\"></p> \n<p>在上面我们有两个注解需要特别注意一下：</p> \n<ol> \n <li>@EnableWebMvc</li> \n</ol> \n<ul> \n <li>名称：@EnableWebMvc</li> \n <li>类型：配置类注解</li> \n <li>位置：SpringMVC配置类定义上方</li> \n <li>作用：开启SpringMVC多项辅助功能</li> \n</ul> \n<ol start=\"2\"> \n <li>@RequestBody</li> \n</ol> \n<ul> \n <li>名称：@RequestBody</li> \n <li>类型：形参注解</li> \n <li>位置：SpringMVC控制器方法形参定义前面</li> \n <li>作用：将请求中请求体所包含的数据传递给请求参数，此注解一个处理器方法只能使用一次</li> \n</ul> \n<blockquote> \n <p>@RequestBody和@RequestParam区别</p> \n <ul> \n  <li>区别 \n   <ul> \n    <li>@RequestParam用于接收url地址传参，表单传参[application/x-www-form-urlencoded]</li> \n    <li>@RequestBody用于接收JSON数据[application/json]</li> \n   </ul> </li> \n  <li>应用 \n   <ul> \n    <li>后期开发中，发送json数据为主，@RequestBody应用较广</li> \n    <li>如果发送非json格式数据，选用@RequestParam接收请求参数</li> \n   </ul> </li> \n </ul> \n</blockquote> \n<h5 id=\"日期型参数类型\">日期型参数类型</h5> \n<p>我们的日期类型数据基于系统不同格式也不相同，大致有以下几种：</p> \n<ul> \n <li>2022-10-05</li> \n <li>2022/10/05</li> \n <li>10/05/2022</li> \n</ul> \n<p>接收形参时，我们根据不同的日期格式设置不同的接收方式</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.Arrays;\nimport java.util.Date;\nimport java.util.List;\n//请求参数\n@Controller\npublic class UserController {\n\n    //日期参数\n    //使用@DateTimeFormat注解设置日期类型数据格式，默认格式yyyy/MM/dd\n    @RequestMapping(\"/dataParam\")\n    @ResponseBody\n    public String dataParam(Date date,\n                            @DateTimeFormat(pattern=\"yyyy-MM-dd\") Date date1,\n                            @DateTimeFormat(pattern=\"yyyy/MM/dd HH:mm:ss\") Date date2){\n        System.out.println(\"参数传递 date ==&gt; \"+date);\n        System.out.println(\"参数传递 date1(yyyy-MM-dd) ==&gt; \"+date1);\n        System.out.println(\"参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; \"+date2);\n        return \"{\'module\':\'data param\'}\";\n    }\n\n}\n\n/*\n名称：@DateTimeFormat\n类型：形参注解\n位置：SpringMVC控制器方法前\n作用：设定日期时间型数据格式\n属性：pattern：日期时间格式字符串\n*/\n</code></pre> \n<p>Postman操作：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/06/adddd50e-636d-4f3d-a0d5-5072a6a5ca9d.png\" alt=\"\" loading=\"lazy\"></p> \n<p>这里我们简单介绍一下@DateTimeFormat的转换原理Converter接口：</p> \n<pre><code class=\"language-java\">public interface Converter&lt;S,T&gt;{\n	@Nullable\n    T convert(S var1)\n}\n</code></pre> \n<p>Converter接口属于顶层接口，由它为起源创建了许多相关的接口与类用于各种转化：</p> \n<ul> \n <li>请求参数年龄数据（String-&gt;Integer）</li> \n <li>日期格式转发（String-&gt;Date）</li> \n</ul> \n<blockquote> \n <p>@EnableWebMvc功能之一：根据类型匹配对应的类型转换器</p> \n</blockquote> \n<h3 id=\"设置响应\">设置响应</h3> \n<p>在了解请求的相关知识之后，我们回到Controller代码中学习一下响应</p> \n<h4 id=\"跳转响应\">跳转响应</h4> \n<p>在正常情况下，我们的响应给出的是当前项目的文档,相当于页面的跳转效应：</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n@Controller\npublic class UserController {\n\n    //响应页面/跳转页面\n    //返回值为String类型，设置返回值为页面名称，即可实现页面跳转\n    @RequestMapping(\"/toJumpPage\")\n    public String toJumpPage(){\n        System.out.println(\"跳转页面\");\n        return \"page.jsp\";\n    }\n\n}\n</code></pre> \n<h4 id=\"信息响应\">信息响应</h4> \n<p>如果我们希望得到一些信息响应，就需要采用注解解释：</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.format.annotation.DateTimeFormat;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n@Controller\npublic class UserController {\n    \n    //响应文本数据\n    //返回值为String类型，设置返回值为任意字符串信息，即可实现返回指定字符串信息，需要依赖@ResponseBody注解\n    @RequestMapping(\"/toText\")\n    @ResponseBody\n    public String toText(){\n        System.out.println(\"返回纯文本数据\");\n        return \"response text\";\n    }\n\n    //响应POJO对象\n    //返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖@ResponseBody注解和@EnableWebMvc注解\n    @RequestMapping(\"/toJsonPOJO\")\n    @ResponseBody\n    public User toJsonPOJO(){\n        System.out.println(\"返回json对象数据\");\n        User user = new User();\n        user.setName(\"itcast\");\n        user.setAge(15);\n        return user;\n    }\n\n    //响应POJO集合对象\n    //返回值为集合对象，设置返回值为集合类型，即可实现返回对应集合的json数组数据，需要依赖@ResponseBody注解和@EnableWebMvc注解\n    @RequestMapping(\"/toJsonList\")\n    @ResponseBody\n    public List&lt;User&gt; toJsonList(){\n        System.out.println(\"返回json集合数据\");\n        User user1 = new User();\n        user1.setName(\"传智播客\");\n        user1.setAge(15);\n\n        User user2 = new User();\n        user2.setName(\"黑马程序员\");\n        user2.setAge(12);\n\n        List&lt;User&gt; userList = new ArrayList&lt;User&gt;();\n        userList.add(user1);\n        userList.add(user2);\n\n        return userList;\n    }\n}\n\n/*\n名称：@ResponseBody\n类型：方法注解\n位置：SpringMVC控制器方法定义上方\n作用：设置当前控制器返回值作为响应体\n*/\n</code></pre> \n<p>当我们使用Postman访问该链接时就会给出对应反馈，这里就不做演示了</p> \n<h2 id=\"rest风格\">REST风格</h2> \n<p>首先我们来简单介绍一下REST：</p> \n<ul> \n <li>REST（Representational State Transfer），表现形式状态转换</li> \n</ul> \n<p>我们给出正常风格和REST风格两种书写形式，我们可以明显看到REST的内容做出大规模的省略：</p> \n<ul> \n <li>正常风格：<a href=\"http://localhost/user/getById?id=1\" target=\"_blank\" rel=\"noopener\">http://localhost/user/getById?id=1</a></li> \n <li>REST风格：<a href=\"http://localhost/users/1\" target=\"_blank\" rel=\"noopener\">http://localhost/users/1</a></li> \n</ul> \n<p>REST风格优点：</p> \n<ul> \n <li>书写简化</li> \n <li>隐藏资源的访问行为，无法通过地址得知对资源的操作</li> \n</ul> \n<h3 id=\"rest风格简介\">REST风格简介</h3> \n<p>我们来对REST风格做出简单解释：</p> \n<ul> \n <li>REST风格是采用访问资源的行为动作来区别对资源进行了何种操作</li> \n</ul> \n<p>我们给出五种常见行为动作：</p> \n<ul> \n <li><a href=\"http://localhost/users%EF%BC%9A%E6%9F%A5%E7%9C%8B%E5%85%A8%E9%83%A8%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\" target=\"_blank\" rel=\"noopener\">http://localhost/users：查看全部用户信息</a> GET（查询）</li> \n <li><a href=\"http://localhost/users/1:\" target=\"_blank\" rel=\"noopener\">http://localhost/users/1:</a> 查看指定用户信息 GET（查询）</li> \n <li><a href=\"http://localhost/users%EF%BC%9A%E6%B7%BB%E5%8A%A0%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\" target=\"_blank\" rel=\"noopener\">http://localhost/users：添加用户信息</a> POST（新增/保存）</li> \n <li><a href=\"http://localhost/users%EF%BC%9A%E4%BF%AE%E6%94%B9%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF\" target=\"_blank\" rel=\"noopener\">http://localhost/users：修改用户信息</a> PUT（修改/更新）</li> \n <li><a href=\"http://localhost/users/1%EF%BC%9A\" target=\"_blank\" rel=\"noopener\">http://localhost/users/1：</a> 删除用户信息 DELETE（删除）</li> \n</ul> \n<p>我们通常将根据REST风格进行的访问称为RESTful</p> \n<blockquote> \n <p>上述行为是约定方式，约定不是规范，是可以打破的，所以称为REST风格，而不是REST规范</p> \n <p>描述模块的名称通常使用负数，也就是加s的格式描述，表示此类，而非单个资源</p> \n</blockquote> \n<h3 id=\"restful入门案例\">RESTful入门案例</h3> \n<p>从本质上而言，REST只是一种规范形式，我们对于REST的风格修改仅针对于Controller</p> \n<p>我们下面将逐步进行RESTful的修改：</p> \n<ol> \n <li>设置http请求动作</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.Book;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\n@Controller\npublic class BookController {\n\n    // RequestMapping中包含value和method两种属性\n    // value:访问路径\n    // method：访问方法\n    @RequestMapping(value = \"/users\",method = Request.POST)\n    @RequestBody\n	public String save(@RequestBody User user){\n		System.out.println(\"user save\" + user);\n        return \"{\'module\':\'user save\'}\"\n    }\n}\n\n/*\n名称：@RequestMapping\n类型：方法注解\n位置：SpringMVC控制器方法定义上方\n作用：设置当前控制器方法请求访问路径\n属性：value访问路径，method请求动作\n*/\n</code></pre> \n<ol start=\"2\"> \n <li>设置请求参数（路径变量）</li> \n</ol> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.Book;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\n@Controller\npublic class BookController {\n\n    // 首先针对我们所需参数给出@PathVariable注解，并在访问路径中采用{}占位表示所传数据\n    // 简单来说就是，系统根据请求路径，得到所需数据，再带入到方法中\n    @RequestMapping(value = \"/users/{id}\" ,method = RequestMethod.DELETE)\n    @RequestBody\n    public String delete(@PathVariable Integer id){\n        System.out.println(\"book delete...\" + id);\n        return \"{\'module\':\'book delete\'}\";\n    }\n}\n\n/*\n名称：@PathVariable\n类型：形参注解\n位置：SpringMVC控制器方法形参定义前面\n作用：绑定路径参数与处理器方法形参间的关系，要求路径参数名与形参名一一对应\n*/\n</code></pre> \n<p>下面我们给出所有情况案例：</p> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\n@Controller\npublic class UserController {\n\n    //设置当前请求方法为POST，表示REST风格中的添加操作\n    @RequestMapping(value = \"/users\",method = RequestMethod.POST)\n    @ResponseBody\n    public String save(){\n        System.out.println(\"user save...\");\n        return \"{\'module\':\'user save\'}\";\n    }\n\n    //设置当前请求方法为DELETE，表示REST风格中的删除操作\n    //@PathVariable注解用于设置路径变量（路径参数），要求路径上设置对应的占位符，并且占位符名称与方法形参名称相同\n    @RequestMapping(value = \"/users/{id}\",method = RequestMethod.DELETE)\n    @ResponseBody\n    public String delete(@PathVariable Integer id){\n        System.out.println(\"user delete...\" + id);\n        return \"{\'module\':\'user delete\'}\";\n    }\n\n    //设置当前请求方法为PUT，表示REST风格中的修改操作\n    @RequestMapping(value = \"/users\",method = RequestMethod.PUT)\n    @ResponseBody\n    public String update(@RequestBody User user){\n        System.out.println(\"user update...\"+user);\n        return \"{\'module\':\'user update\'}\";\n    }\n\n    //设置当前请求方法为GET，表示REST风格中的查询操作\n    //@PathVariable注解用于设置路径变量（路径参数），要求路径上设置对应的占位符，并且占位符名称与方法形参名称相同\n    @RequestMapping(value = \"/users/{id}\" ,method = RequestMethod.GET)\n    @ResponseBody\n    public String getById(@PathVariable Integer id){\n        System.out.println(\"user getById...\"+id);\n        return \"{\'module\':\'user getById\'}\";\n    }\n\n    //设置当前请求方法为GET，表示REST风格中的查询操作\n    @RequestMapping(value = \"/users\",method = RequestMethod.GET)\n    @ResponseBody\n    public String getAll(){\n        System.out.println(\"user getAll...\");\n        return \"{\'module\':\'user getAll\'}\";\n    }\n\n}\n\n\n/*\n	下述为原有代码：\n\n    @RequestMapping\n    @ResponseBody\n    public String delete(){\n        System.out.println(\"user delete...\");\n        return \"{\'module\':\'user delete\'}\";\n    }\n\n    @RequestMapping\n    @ResponseBody\n    public String update(){\n        System.out.println(\"user update...\");\n        return \"{\'module\':\'user update\'}\";\n    }\n\n    @RequestMapping\n    @ResponseBody\n    public String getById(){\n        System.out.println(\"user getById...\");\n        return \"{\'module\':\'user getById\'}\";\n    }\n\n    @RequestMapping\n    @ResponseBody\n    public String getAll(){\n        System.out.println(\"user getAll...\");\n        return \"{\'module\':\'user getAll\'}\";\n    }\n*/\n</code></pre> \n<blockquote> \n <p>我们在这里给出@RequestBody，@RequestParam，@PathVariable区别</p> \n <p>区别：</p> \n <ul> \n  <li>@RequestParam用于接收url地址传参或表单传参</li> \n  <li>@RequestBody用于接收json数据</li> \n  <li>@PathVariable用于接收路径参数，使用{参数名称}描述路径参数</li> \n </ul> \n <p>应用：</p> \n <ul> \n  <li>后期开发中，发送请求参数超过1个时，以json格式为主，@RequestBody应用较广</li> \n  <li>如果发送非json格式数据，选用@RequestParam接受请求参数</li> \n  <li>采用RESTful进行开发，当参数数量较少时，如1个，可以采用@PathVariable接收请求路径变量，常用来传递id值</li> \n </ul> \n</blockquote> \n<h3 id=\"rest快速开发\">REST快速开发</h3> \n<p>我们在上一小节中会发现有许多重复性的代码：</p> \n<pre><code class=\"language-java\">// 每次都填写value，method导致代码繁冗\n// 包括每次填写ResponseBody使代码繁冗\n\n@RequestMapping(value = \"/users\",method = RequestMethod.GET)\n@ResponseBody\n</code></pre> \n<p>所以我们可以采用一些小技巧来简化代码：</p> \n<ul> \n <li>将前缀地址和相关注解放于类中：</li> \n</ul> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.Book;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\n//@Controller\n//@ResponseBody\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController {\n\n}\n/*\n正常情况下，我们的类本身具有@Controller，并且为了省略类中的@ResponseBody而直接标注在类头\n但Spring提供了一种新的注解@RestController，相当于@Controller和@ResponseBody的结合，我们只需要书写这一个注解即可 \n\n名称：@RestController\n类型：类注解\n位置：基于SpringMVC的RESTful开发控制器类定义上方\n作用：设置当前控制器为RESTful风格，等同于@Controller与@ResponseBody两个注解组合功能\n*/\n</code></pre> \n<ul> \n <li>采用新的地址注解代替老注解：</li> \n</ul> \n<pre><code class=\"language-java\">package com.itheima.controller;\n\nimport com.itheima.domain.Book;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@RequestMapping(\"/books\")\npublic class BookController {\n\n	//@RequestMapping( method = RequestMethod.POST)\n    //使用@PostMapping简化Post请求方法对应的映射配置\n    @PostMapping        \n    public String save(@RequestBody Book book){\n        System.out.println(\"book save...\" + book);\n        return \"{\'module\':\'book save\'}\";\n    }\n\n	//@RequestMapping(value = \"/{id}\" ,method = RequestMethod.DELETE)\n    //使用@DeleteMapping简化DELETE请求方法对应的映射配置\n    @DeleteMapping(\"/{id}\")     \n    public String delete(@PathVariable Integer id){\n        System.out.println(\"book delete...\" + id);\n        return \"{\'module\':\'book delete\'}\";\n    }\n\n	//@RequestMapping(method = RequestMethod.PUT)\n    //使用@PutMapping简化Put请求方法对应的映射配置\n    @PutMapping         \n    public String update(@RequestBody Book book){\n        System.out.println(\"book update...\"+book);\n        return \"{\'module\':\'book update\'}\";\n    }\n\n	//@RequestMapping(value = \"/{id}\" ,method = RequestMethod.GET)\n    //使用@GetMapping简化GET请求方法对应的映射配置\n    @GetMapping(\"/{id}\")    \n    public String getById(@PathVariable Integer id){\n        System.out.println(\"book getById...\"+id);\n        return \"{\'module\':\'book getById\'}\";\n    }\n\n	//@RequestMapping(method = RequestMethod.GET)\n    //使用@GetMapping简化GET请求方法对应的映射配置\n    @GetMapping             \n    public String getAll(){\n        System.out.println(\"book getAll...\");\n        return \"{\'module\':\'book getAll\'}\";\n    }\n}\n\n/*\n名称：@GetMapping @PostMapping @PutMapping @DeleteMapping\n类型：方法注解\n位置：基于SpringMVC的RESTful开发控制器方法定义上方\n作用：设置当前控制器方法请求访问路径与请求动作，每种对应一个请求动作，例如@GetMapping对应GET请求\n参数：value请求访问路径\n*/\n</code></pre> \n<h1 id=\"结束语\">结束语</h1> \n<p>好的,关于SpringMVC的内容就介绍到这里,希望能为你带来帮助!</p> \n<h6 id=\"附录\">附录</h6> \n<p>该文章属于学习内容，具体参考B站黑马程序员李老师的SSM框架课程</p> \n<p>这里附上链接：<a href=\"https://www.bilibili.com/video/BV1Fi4y1S7ix?p=43&amp;vd_source=338ccc664622651493b6fe1ded5bc801\" target=\"_blank\" rel=\"noopener\">SpringMVC-01-SpringMVC简介_哔哩哔哩_bilibili</a></p>',100,NULL,0,'https://www.cnblogs.com/qiuluoyuweiliang/p/16757184.html','2022-10-06 23:59:05'),(21,'基于.NetCore开发博客项目 StarBlog - (18) 实现本地Typora文章打包上传',NULL,NULL,0,0,'<h2 id=\"前言\">前言</h2> \n<p>九月太忙，只更新了三篇文章，本来这个功能是从九月初就开始做的，结果一直拖到现在国庆假期才有时间完善并且写文章~</p> \n<p>之前我更新了几篇关于 Python 的文章，有朋友留言问是不是不更新 .Net 了，那肯定不能啊，我只能说<strong>「我 全 都 要」</strong>，所以我反手就更新了一篇<a href=\"https://www.cnblogs.com/deali/p/16754636.html\" target=\"_blank\" rel=\"noopener\">Asp-Net-Core开发笔记</a>。</p> \n<p>然后顺便立个Flag：今年底前完成StarBlog系列文章的主体部分（即API开发+后台前端开发，目前只完成博客前后端部分），加油吧~</p> \n<p>OK，说回本文，程序员都喜欢用Markdown来写文章，但由于markdown是纯文本格式，在其中插入的图片要如何保存，就成了一大烦恼，有人选择图床，但不一定永久有效；有人选择本地存储，图片永久有效，但如何分享文章又成了一个难题…</p> \n<p>我选的就是第二种，本地存储。使用Typora写文章，图片保存在和Markdown文件同名的目录（markdown.assets）下，这样可以获得很好的写作体验，然后分享的问题就交给StarBlog吧，这个项目开发的初衷就是为了把本地的文章发表成博客。</p> \n<p>不过之前只有批量导入文章的功能，现在我要做的就是单独实现一个单篇文章打包导入的功能。</p> \n<blockquote> \n <p>随着文章越来越多，系列文章的目录放前面有点影响阅读了，所以从这篇开始我把它放到最后面~</p> \n</blockquote> \n<h2 id=\"实现思路\">实现思路</h2> \n<p>假设我用Typora写了一篇Markdown文章，文件名为：<code>StarBlog.md</code>，并且在里面插入了若干图片，根据配置，Typora会自动生成一个目录（<code>StarBlog.assets</code>）来存放这些图片。</p> \n<p>为了实现导入，我要把这个markdown文件和这个存图片的目录一起打包成zip压缩文件上传，后端将zip压缩包解压到临时目录，读取Markdown文件，解析其中的内容，进行导入操作。</p> \n<h2 id=\"代码实现\">代码实现</h2> \n<p>OK，开始写代码吧</p> \n<p>同时所有项目代码已经上传GitHub，欢迎各位大佬Star/Fork！</p> \n<ul> \n <li>博客后端+前台项目地址：<a href=\"https://github.com/Deali-Axy/StarBlog\" target=\"_blank\" rel=\"noopener\">https://github.com/Deali-Axy/StarBlog</a></li> \n <li>管理后台前端项目地址：<a href=\"https://github.com/Deali-Axy/StarBlog-Admin\" target=\"_blank\" rel=\"noopener\">https://github.com/Deali-Axy/StarBlog-Admin</a></li> \n</ul> \n<h3 id=\"解压缩\">解压缩</h3> \n<p>首先是解压缩功能，.Net标准库自带 <code>ZipFile</code> 这个库用于操作zip压缩包，在 <code>System.IO.Compression</code> 里，直接用就完事了。</p> \n<p>解压前得先把文件复制到临时目录，并创建一个新的临时目录来放解压后的文件。</p> \n<p>在 <code>Services/BlogServices.cs</code> 里新增代码</p> \n<pre><code class=\"language-c#\">public async Task&lt;Post&gt; Upload(PostCreationDto dto, IFormFile file) {\n    // 先复制到临时文件\n    var tempFile = Path.GetTempFileName();\n    await using (var fs = new FileStream(tempFile, FileMode.Create)) {\n        await file.CopyToAsync(fs);\n    }\n\n    // 设定解压用的临时目录\n    var extractPath = Path.Combine(Path.GetTempPath(), \"StarBlog\", Guid.NewGuid().ToString());\n  \n    // 使用 GBK 编码解压，防止中文文件名乱码\n    Encoding.RegisterProvider(CodePagesEncodingProvider.Instance);\n    ZipFile.ExtractToDirectory(tempFile, extractPath, Encoding.GetEncoding(\"GBK\"));\n}\n</code></pre> \n<p>本来直接 <code>ZipFile.ExtractToDirectory()</code> 就能解压了，但如果压缩包里的文件用了中文名，就得先设置编码。</p> \n<h3 id=\"解析markdown\">解析Markdown</h3> \n<p>关于 C# 解析 Markdown ，在本系列一开始就写过，所以这里就不再当复读机了，可以直接看这两篇文章：</p> \n<ul> \n <li><a href=\"https://www.cnblogs.com/deali/p/16211720.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (4) markdown博客批量导入</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16027455.html\" target=\"_blank\" rel=\"noopener\">C#解析Markdown文档，实现替换图片链接操作</a></li> \n</ul> \n<p>直接上代码了</p> \n<p>因为是做单篇文章导入，所以我这里获取临时目录写的所有 <code>*.md</code> 文件之后只取第一个文件来处理（理论上也不应该有多个~）</p> \n<pre><code class=\"language-c#\">var dir = new DirectoryInfo(extractPath);\nvar files = dir.GetFiles(\"*.md\");\nvar mdFile = files.First();\nusing var reader = mdFile.OpenText();\nvar content = await reader.ReadToEndAsync();\nvar post = new Post {\n  Id = GuidUtils.GuidTo16String(),\n  Status = \"已发布\",\n  Title = dto.Title ?? $\"{DateTime.Now.ToLongDateString()} 文章\",\n  IsPublish = true,\n  Content = content,\n  Path = \"\",\n  CreationTime = DateTime.Now,\n  LastUpdateTime = DateTime.Now,\n  CategoryId = dto.CategoryId,\n};\n\nvar assetsPath = Path.Combine(_environment.WebRootPath, \"media\", \"blog\");\nvar processor = new PostProcessor(extractPath, assetsPath, post);\n\n// 处理文章标题和状态\nprocessor.InflateStatusTitle();\n\n// 处理文章正文内容\n// 导入文章的时候一并导入文章里的图片，并对图片相对路径做替换操作\npost.Content = processor.MarkdownParse();\npost.Summary = processor.GetSummary(200);\n</code></pre> \n<p>Markdown相关的处理，我封装了 <code>PostProcessor</code> 这个对象，在 <code>StarBlog.Share</code> 里。</p> \n<h3 id=\"处理多级分类\">处理多级分类</h3> \n<p>如果文章的分类不是一级分类，那么把它上面的所有分类找出来，一个个排好队，方便后面处理。</p> \n<pre><code class=\"language-c#\">// 处理多级分类\nvar category = await _categoryRepo.Where(a =&gt; a.Id == dto.CategoryId).FirstAsync();\nif (category == null) {\n  post.Categories = \"0\";\n}\nelse {\n  var categories = new List&lt;Category&gt; {category};\n  var parent = category.Parent;\n  while (parent != null) {\n    categories.Add(parent);\n    parent = parent.Parent;\n  }\n\n  categories.Reverse();\n  post.Categories = string.Join(\",\", categories.Select(a =&gt; a.Id));\n}\n</code></pre> \n<h3 id=\"最后保存\">最后保存</h3> \n<p>搞定~</p> \n<pre><code class=\"language-c#\">// 存入数据库\npost = await _postRepo.InsertAsync(post);\n</code></pre> \n<h2 id=\"系列文章\">系列文章</h2> \n<ul> \n <li><a href=\"https://www.cnblogs.com/deali/p/16104454.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (1) 为什么需要自己写一个博客？</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16172342.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (2) 环境准备和创建项目</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16180920.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (3) 模型设计</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16211720.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (4) markdown博客批量导入</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16276448.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (5) 开始搭建Web项目</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16286780.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (6) 页面开发之博客文章列表</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16293309.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (7) 页面开发之文章详情页面</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16307604.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (8) 分类层级结构展示</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16328825.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (9) 图片批量导入</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16335162.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (10) 图片瀑布流</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16349155.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (11) 实现访问统计</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16391656.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (12) Razor页面动态编译</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16421699.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (13) 加入友情链接功能</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16441294.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (14) 实现主题切换功能</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16457314.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (15) 生成随机尺寸图片</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16523157.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (16) 一些新功能 (监控/统计/配置/初始化)</a></li> \n <li><a href=\"https://www.cnblogs.com/deali/p/16586437.html\" target=\"_blank\" rel=\"noopener\">基于.NetCore开发博客项目 StarBlog - (17) 自动下载文章里的外部图片</a></li> \n <li>基于.NetCore开发博客项目 StarBlog - (18) 实现本地Typora文章打包上传</li> \n</ul> \n<h2 id=\"参考资料\">参考资料</h2> \n<ul> \n <li><a href=\"https://www.cnblogs.com/liguix/p/11883248.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/liguix/p/11883248.html</a></li> \n</ul>',100,NULL,0,'https://www.cnblogs.com/deali/p/16758878.html','2022-10-07 00:00:02'),(22,'虚拟线程 - VirtualThread源码透视',NULL,NULL,0,0,'<h2 id=\"前提\">前提</h2> \n<p><code>JDK19</code>于<code>2022-09-20</code>发布<code>GA</code>版本，该版本提供了虚拟线程的预览功能。下载<code>JDK19</code>之后翻看了一下有关虚拟线程的一些源码，跟早些时候的<code>Loom</code>项目构建版本基本并没有很大出入，也跟第三方<code>JDK</code>如鹅厂的<code>Kona</code>虚拟线程实现方式基本一致，这里分析一下虚拟线程设计与源码实现。</p> \n<h2 id=\"platform-thread与virtual-thread\">Platform Thread与Virtual Thread</h2> \n<p>因为引入了虚拟线程，原来<code>JDK</code>存在<code>java.lang.Thread</code>类，俗称线程，为了更好地区分虚拟线程和原有的线程类，引入了一个全新类<code>java.lang.VirtualThread</code>（<code>Thread</code>类的一个子类型），直译过来就是\"虚拟线程\"。</p> \n<ul> \n <li>题外话：在<code>Loom</code>项目早期规划里面，核心<code>API</code>其实命名为<code>Fiber</code>，直译过来就是\"纤程\"或者\"协程\"，后来成为了废案，在一些历史提交的<code>Test</code>类或者文档中还能看到类似于下面的代码：</li> \n</ul> \n<pre><code class=\"language-java\">// java.lang.Fiber\nFiber f = Fiber.execute({\n    out.println(\"Good morning\");\n    readLock.lock();\n    try{\n        out.println(\"Good night\");\n    } finally{\n        readLock.unlock();\n    }\n    out.println(\"Good night\");\n});\n</code></pre> \n<p><code>Thread</code>在此基础上做了不少兼容性工作。此外，还应用了建造者模式引入了线程建造器，提供了静态工厂方法<code>Thread#ofPlatform()</code>和<code>Thread#ofVirtual()</code>分别用于实例化<code>Thread</code>（工厂）建造器和<code>VirtualThread</code>（工厂）建造器，顾名思义，两种建造器分别用于创建<code>Thread</code>或者<code>VirtualThread</code>，例如：</p> \n<pre><code class=\"language-java\">// demo-1 build platform thread\nThread platformThread = Thread.ofPlatform().daemon().name(\"worker\").unstarted(runnable);\n\n// demo-2 create platform thread factory\nThreadFactory platformThreadFactory = Thread.ofPlatform().daemon().name(\"worker-\", 0).factory();\n\n// demo-3 build virtual thread\nThread virtualThread = Thread.ofVirtual().name(\"virtual-worker\").unstarted(runnable);\n\n// demo-4 create virtual thread factory\nThreadFactory virtualThreadFactory = Thread.ofVirtual().name(\"virtual-worker-\", 0).factory();\n</code></pre> \n<p>更新的<code>JDK</code>文档中也把原来的<code>Thread</code>称为<code>Platform Thread</code>，可以更明晰地与<code>Virtual Thread</code>区分开来。这里<code>Platform Thread</code>直译为\"平台线程\"，其实就是\"虚拟线程\"出现之前的老生常谈的\"线程\"。</p> \n<blockquote> \n <p>后文会把Platform Thread称为平台线程，Virtual Thread称为虚拟线程，或者直接用其英文名称</p> \n</blockquote> \n<p>那么平台线程与虚拟线程的联系和区别是什么？<code>JDK</code>中的每个<code>java.lang.Thread</code>实例也就是每个平台线程实例都在底层操作系统线程上运行<code>Java</code>代码，并且<strong>平台线程在运行代码的整个生命周期内捕获系统线程</strong>。可以得出一个结论，平台线程与底层系统线程是一一对应的，平台线程实例本质是由系统内核的线程调度程序进行调度，并且平台线程的总数量受限于系统线程的总数量。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/f78c5f17-d5f6-4619-be80-e1d22a66030b.jpg; charset=utf-8\" alt=\"vt-source-code-1\" loading=\"lazy\"></p> \n<p>总的来说，平台线程有下面的一些特点或者说限制：</p> \n<ul> \n <li>资源有限导致系统线程总量有限，进而导致与系统线程一一对应的平台线程有限</li> \n <li>平台线程的调度依赖于系统的线程调度程序，当平台线程创建过多，会消耗大量资源用于处理线程上下文切换</li> \n <li>每个平台线程都会开辟一块私有的栈空间，大量平台线程会占据大量内存</li> \n</ul> \n<p>这些限制导致开发者不能极大量地创建平台线程，为了满足性能需要，需要引入池化技术、添加任务队列构建消费者-生产者模式等方案去让平台线程适配多变的现实场景。显然，开发者们迫切需要一种轻量级线程实现，刚好可以弥补上面提到的平台线程的限制，这种轻量级线程可以满足：</p> \n<ul> \n <li>可以大量创建，例如十万级别、百万级别，而不会占据大量内存</li> \n <li>由<code>JVM</code>进行调度和状态切换，并且与系统线程\"松绑\"</li> \n <li>用法与原来平台线程差不多，或者说尽量兼容平台线程现存的<code>API</code></li> \n</ul> \n<p><code>Loom</code>项目中开发的虚拟线程就是为了解决这个问题，看起来它的运行示意图如下：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/600068f8-1e8b-4798-935c-f2bfcea8adec.jpg; charset=utf-8\" alt=\"vt-source-code-2\" loading=\"lazy\"></p> \n<p>当然，平台线程不是简单地与虚拟线程进行<code>1:N</code>的绑定，后面的章节会深入分析虚拟线程的运行原理。</p> \n<h2 id=\"虚拟线程实现原理\">虚拟线程实现原理</h2> \n<p>虚拟线程是一种轻量级（用户模式）线程，这种线程是由<code>Java</code>虚拟机调度，而不是操作系统。虚拟线程占用空间小，任务切换开销几乎可以忽略不计，因此可以极大量地创建和使用。总体来看，虚拟线程实现如下：</p> \n<pre><code class=\"language-shell\">virtual thread = continuation + scheduler\n</code></pre> \n<p>虚拟线程会把任务（一般是<code>java.lang.Runnable</code>）包装到一个<code>Continuation</code>实例中：</p> \n<ul> \n <li>当任务需要阻塞挂起的时候，会调用<code>Continuation</code>的<code>yield</code>操作进行阻塞</li> \n <li>当任务需要解除阻塞继续执行的时候，<code>Continuation</code>会被继续执行</li> \n</ul> \n<p><code>Scheduler</code>也就是执行器，会把任务提交到一个载体线程池中执行：</p> \n<ul> \n <li>执行器是<code>java.util.concurrent.Executor</code>的子类</li> \n <li>虚拟线程框架提供了一个默认的<code>ForkJoinPool</code>用于执行虚拟线程任务</li> \n</ul> \n<blockquote> \n <p>下文会把carrier thread称为\"载体线程\"，指的是负责执行虚拟线程中任务的平台线程，或者说运行虚拟线程的平台线程称为它的载体线程</p> \n</blockquote> \n<p>操作系统调度系统线程，而<code>Java</code>平台线程与系统线程一一映射，所以平台线程被操作系统调度，但是虚拟线程是由<code>JVM</code>调度。<code>JVM</code>把虚拟线程分配给平台线程的操作称为<code>mount</code>（挂载），反过来取消分配平台线程的操作称为<code>unmount</code>（卸载）：</p> \n<ul> \n <li><code>mount</code>操作：虚拟线程挂载到平台线程，虚拟线程中包装的<code>Continuation</code>栈数据帧或者引用栈数据会被拷贝到平台线程的线程栈，这是一个从堆复制到栈的过程</li> \n <li><code>unmount</code>操作：虚拟线程从平台线程卸载，大多数虚拟线程中包装的<code>Continuation</code>栈数据帧会留在堆内存中</li> \n</ul> \n<p>这个<code>mount -&gt; run -&gt; unmount</code>过程用伪代码表示如下：</p> \n<pre><code class=\"language-java\">mount();\ntry {\n    Continuation.run();\n} finally {\n    unmount();\n}\n</code></pre> \n<p>从<code>Java</code>代码的角度来看，虚拟线程和它的载体线程暂时共享一个<code>OS</code>线程实例这个事实是不可见，因为虚拟线程的堆栈跟踪和线程本地变量与平台线程是完全隔离的。<code>JDK</code>中专门是用了一个<code>FIFO</code>模式的<code>ForkJoinPool</code>作为虚拟线程的调度程序，从这个调度程序看虚拟线程任务的执行流程大致如下：</p> \n<ul> \n <li>调度器（线程池）中的平台线程等待处理任务</li> \n</ul> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/9faf9ef0-a69e-4ff1-b554-f097bfc268e8.jpg; charset=utf-8\" alt=\"vt-source-code-5\" loading=\"lazy\"></p> \n<ul> \n <li>一个虚拟线程被分配平台线程，该平台线程作为运载线程执行虚拟线程中的任务</li> \n</ul> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/7e3444d8-a1cd-4bf9-bf1f-f66b7f232814.jpg; charset=utf-8\" alt=\"vt-source-code-6\" loading=\"lazy\"></p> \n<ul> \n <li>虚拟线程运行其<code>Continuation</code>，从而执行基于<code>Runnable</code>包装的用户任务</li> \n</ul> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/7a980f11-bc63-4a67-a7b2-4f2d4c0b8d5d.jpg; charset=utf-8\" alt=\"vt-source-code-7\" loading=\"lazy\"></p> \n<ul> \n <li>虚拟线程任务执行完成，标记<code>Continuation</code>终结，标记虚拟线程为终结状态，清空一些上下文变量，运载线程\"返还\"到调度器（线程池）中作为平台线程等待处理下一个任务</li> \n</ul> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/9faf9ef0-a69e-4ff1-b554-f097bfc268e8.jpg; charset=utf-8\" alt=\"vt-source-code-5\" loading=\"lazy\"></p> \n<p>上面是描述一般的虚拟线程任务执行情况，在执行任务时候首次调用<code>Continuation#run()</code>获取锁（<code>ReentrantLock</code>）的时候会触发<code>Continuation</code>的<code>yield</code>操作让出控制权，等待虚拟线程重新分配运载线程并且执行，见下面的代码：</p> \n<pre><code class=\"language-java\">public class VirtualThreadLock {\n\n    public static void main(String[] args) throws Exception {\n        ReentrantLock lock = new ReentrantLock();\n        Thread.startVirtualThread(() -&gt; {\n            lock.lock();     // &lt;------ 这里确保锁已经被另一个虚拟线程持有\n        });\n        Thread.sleep(1000);\n        Thread.startVirtualThread(() -&gt; {\n            System.out.println(\"first\");\n            lock.lock();\n            try {\n                System.out.println(\"second\");\n            } finally {\n                lock.unlock();\n            }\n            System.out.println(\"third\");\n        });\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n</code></pre> \n<ul> \n <li>虚拟线程中任务执行时候首次调用<code>Continuation#run()</code>执行了部分任务代码，然后尝试获取锁，会导致<code>Continuation</code>的<code>yield</code>操作让出控制权（任务切换），也就是<code>unmount</code>，运载线程栈数据会移动到<code>Continuation</code>栈的数据帧中，保存在堆内存，虚拟线程任务完成（但是虚拟线程没有终结，同时其<code>Continuation</code>也没有终结和释放），运载线程被释放到执行器中等待新的任务；如果<code>Continuation</code>的<code>yield</code>操作失败，则会对运载线程进行<code>park</code>调用，阻塞在运载线程上</li> \n</ul> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/3234adad-6cbc-428c-a634-845b73ceec27.jpg; charset=utf-8\" alt=\"vt-source-code-8\" loading=\"lazy\"></p> \n<ul> \n <li>当锁持有者释放锁之后，会唤醒虚拟线程获取锁（成功后），虚拟线程会重新进行<code>mount</code>，让虚拟线程任务再次执行，有可能是分配到另一个运载线程中执行，<code>Continuation</code>栈会的数据帧会被恢复到运载线程栈中，然后再次调用<code>Continuation#run()</code>恢复任务执行：</li> \n</ul> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/e5c5dbcb-0d6e-4d74-8093-ece4e1a223be.jpg; charset=utf-8\" alt=\"vt-source-code-9\" loading=\"lazy\"></p> \n<ul> \n <li>最终虚拟线程任务执行完成，标记<code>Continuation</code>终结，标记虚拟线程为终结状态，清空一些上下文变量，运载线程\"返还\"到调度器（线程池）中作为平台线程等待处理下一个任务</li> \n</ul> \n<p><code>Continuation</code>组件十分重要，它既是用户真实任务的包装器，也是任务切换虚拟线程与平台线程之间数据转移的一个句柄，它提供的<code>yield</code>操作可以实现任务上下文的中断和恢复。由于<code>Continuation</code>被封闭在<code>java.base/jdk.internal.vm</code>下，可以通过增加编译参数<code>--add-exports java.base/jdk.internal.vm=ALL-UNNAMED</code>暴露对应的功能，从而编写实验性案例，<code>IDEA</code>中可以按下图进行编译参数添加：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/ad57cfe9-ecc7-4496-a97a-639a674c768a.jpg; charset=utf-8\" alt=\"vt-source-code-10\" loading=\"lazy\"></p> \n<p>然后编写和运行下面的例子：</p> \n<pre><code class=\"language-java\">import jdk.internal.vm.Continuation;\nimport jdk.internal.vm.ContinuationScope;\n\npublic class ContinuationDemo {\n\n    public static void main(String[] args) {\n        ContinuationScope scope = new ContinuationScope(\"scope\");\n        Continuation continuation = new Continuation(scope, () -&gt; {\n            System.out.println(\"Running before yield\");\n            Continuation.yield(scope);\n            System.out.println(\"Running after yield\");\n        });\n        System.out.println(\"First run\");\n        // 第一次执行Continuation.run\n        continuation.run();\n        System.out.println(\"Second run\");\n        // 第二次执行Continuation.run\n        continuation.run();\n        System.out.println(\"Done\");\n    }\n}\n\n// 运行代码，神奇的结果出现了\nFirst run\nRunning before yield\nSecond run\nRunning after yield\nDone\n</code></pre> \n<p>这里可以看出<code>Continuation</code>的奇妙之处，<code>Continuation</code>实例进行<code>yield</code>调用后，再次调用其<code>run</code>方法就可以从<code>yield</code>的调用之处往下执行，从而实现了程序的中断和恢复。</p> \n<h2 id=\"源码分析\">源码分析</h2> \n<p>主要包括：</p> \n<ul> \n <li><code>Continuation</code></li> \n <li><code>VirtualThread</code></li> \n <li>线程建造器</li> \n</ul> \n<h3 id=\"continuation\">Continuation</h3> \n<p><code>Continuation</code>直译为\"连续\"，一般来说表示一种语言构造，<strong>使语言可以在任意点保存执行状态并且在之后的某个点返回</strong>。在<code>JDK</code>中对应类<code>jdk.internal.vm.Continuation</code>，这个类只有一句类注释<code>A one-shot delimited continuation</code>，直译为<strong>一个只能执行一次的回调函数</strong>。由于<code>Continuation</code>的成员和方法缺少详细的注释，并且大部分功能由<code>JVM</code>实现，这里只能阅读其一些骨干源码和上一小节编写的<code>Continuation</code>相关例子去了解其实现（笔者<code>C</code>语言比较薄弱，有兴趣的可以翻阅<code>JVM</code>的源码）。先看成员变量和构造函数：</p> \n<pre><code class=\"language-java\">// 判断是否需要保留当前线程的本地缓存，由系统参数jdk.preserveExtentLocalCache决定\nprivate static final boolean PRESERVE_EXTENT_LOCAL_CACHE;\n\n// 真正要被执行的任务实例\nprivate final Runnable target;\n\n// 标识Continuation的范围，\nprivate final ContinuationScope scope;\n\n// Continuation的父节点，如果为空的时候则为本地线程栈\nprivate Continuation parent;\n\n// Continuation的子节点，非空时候说明在子Continuation中进行了yield操作\nprivate Continuation child;\n\n// 猜测为Continuation栈结构，由JVM管理，无法得知其真实作用\nprivate StackChunk tail;\n\n// 标记Continuation是否已经完成\nprivate boolean done;\n\n// 标记是否进行了mount操作\nprivate volatile boolean mounted = false;\n\n// yield操作时候设置的信息\nprivate Object yieldInfo;\n\n// 标记一个未挂载的Continuation是否通过强制抢占式卸载\nprivate boolean preempted;\n\n// 保留当前线程的本地缓存的副本\nprivate Object[] extentLocalCache;\n\n// 构造函数，要求传入范围和任务包装实例\npublic Continuation(ContinuationScope scope, Runnable target) {\n    this.scope = scope;\n    this.target = target;\n}\n</code></pre> \n<p><code>Continuation</code>是一个双向链表设计，它的唯一一组构造参数是<code>ContinuationScope</code>和<code>Runnable</code>：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a3c3df31-2d51-4c05-b93a-0e322a8544e5.jpg; charset=utf-8\" alt=\"vt-source-code-11\" loading=\"lazy\"></p> \n<p>这里不深入研究内部<code>StackChunk</code>、<code>Pinned</code>等实现，直接看<code>run</code>、<code>enter</code>系列方法和<code>yield</code>方法：</p> \n<pre><code class=\"language-java\">// Continuation.run()\npublic final void run() {\n    // 设置死循环\n    while (true) {\n        // 进行mount操作\n        mount();\n        JLA.setExtentLocalCache(extentLocalCache);\n        // 如果Continuation已完成则抛出异常\n        if (done)\n            throw new IllegalStateException(\"Continuation terminated\");\n        // 获取当前虚拟线程分配的运载线程\n        Thread t = currentCarrierThread();\n        if (parent != null) {\n            if (parent != JLA.getContinuation(t))\n                throw new IllegalStateException();\n        } else\n            this.parent = JLA.getContinuation(t);\n        // 运载线程设置当前Continuation实例\n        JLA.setContinuation(t, this);\n\n        try {\n            // 判断ContinuationScope是否虚拟线程范围\n            boolean isVirtualThread = (scope == JLA.virtualThreadContinuationScope());\n            if (!isStarted()) { // is this the first run? (at this point we know !done)\n                // 激活enter系列方法，标记isContinue为false，标记是否虚拟线程范围\n                enterSpecial(this, false, isVirtualThread);\n            } else {\n                assert !isEmpty();\n                // 激活enter系列方法，标记isContinue为true，标记是否虚拟线程范围\n                enterSpecial(this, true, isVirtualThread);\n            }\n        } finally {\n            // 设置内存屏障\n            fence();\n            try {\n                assert isEmpty() == done : \"empty: \" + isEmpty() + \" done: \" + done + \" cont: \" + Integer.toHexString(System.identityHashCode(this));\n                // 当前Continuation执行完成后，把运载线程的Continuation指向父Continuation\n                JLA.setContinuation(currentCarrierThread(), this.parent);\n                if (parent != null)\n                    parent.child = null;\n                // 进行后置的yield清理工作\n                postYieldCleanup();\n                // 进行unmount操作\n                unmount();\n                // 判断是否需要保留当前线程的本地缓存并处理\n                if (PRESERVE_EXTENT_LOCAL_CACHE) {\n                    extentLocalCache = JLA.extentLocalCache();\n                } else {\n                    extentLocalCache = null;\n                }\n                JLA.setExtentLocalCache(null);\n            } catch (Throwable e) { e.printStackTrace(); System.exit(1); }\n        }\n        // we\'re now in the parent continuation\n\n        assert yieldInfo == null || yieldInfo instanceof ContinuationScope;\n        // 父Continuation的yieldInfo缓存当前的scope实例，清空当前Continuation的父节点和yieldInfo\n        if (yieldInfo == null || yieldInfo == scope) {\n            this.parent = null;\n            this.yieldInfo = null;\n            // 这个位置是死循环的唯一跳出点\n            return;\n        } else {\n            // 执行到这个位置说明在当前是子Continuation并且进行了yield操作，需要跳转到父Continuation进行yield操作\n            parent.child = this;\n            parent.yield0((ContinuationScope)yieldInfo, this);\n            parent.child = null;\n        }\n    }\n}\n\n// Continuation.enter()系列方法\n\n// 这是一个native方法，它最终会根据判断回调到enter()方法\nprivate native static void enterSpecial(Continuation c, boolean isContinue, boolean isVirtualThread);\n\n// Continuation的入口方法，用户任务回调的入口\n@DontInline\n@IntrinsicCandidate\nprivate static void enter(Continuation c, boolean isContinue) {\n    // This method runs in the \"entry frame\".\n    // A yield jumps to this method\'s caller as if returning from this method.\n    try {\n        c.enter0();\n    } finally {\n        c.finish();\n    }\n}\n\n// 真正任务包装器执行的回调方法\nprivate void enter0() {\n    target.run();\n}\n\n// Continuation完成，标记done为true\nprivate void finish() {\n    done = true;\n    assert isEmpty();\n}\n\n\n// Continuation.yield()方法，静态方法\npublic static boolean yield(ContinuationScope scope) {\n    // 获取当前运载线程的Continuation实例\n    Continuation cont = JLA.getContinuation(currentCarrierThread());\n    Continuation c;\n    // 基于Continuation实例当前向父节点遍历，直到匹配虚拟线程类型的ContinuationScope的Continuation，如果没有匹配的Continuation会抛出异常中断流程\n    for (c = cont; c != null &amp;&amp; c.scope != scope; c = c.parent)\n        ;\n    if (c == null)\n        throw new IllegalStateException(\"Not in scope \" + scope);\n    // 把当前的Continuation挂起到给定的ContinuationScope\n    return cont.yield0(scope, null);\n}\n\n// 透过上下文猜测是当前的Continuation实例挂起到给定的ContinuationScope\nprivate boolean yield0(ContinuationScope scope, Continuation child) {\n    // 强制抢占式卸载标记为false\n    preempted = false;\n    // 如果当前Continuation实例的yieldInfo不等于传入的ContinuationScope实例，则进行更新，相等的情况下yieldInfo会保持是一个空值\n    if (scope != this.scope)\n        this.yieldInfo = scope;\n    // 最终的yield调用，最终当前Continuation就是阻塞在此方法，从下文源码猜测，当该方法唤醒后，res值为0的时候，当前Continuation实例会继续执行，返回其他值的时候则会打印pined线程栈\n    int res = doYield();\n    // 放置内存屏障防止指令重排，后面注释提到是防止编译器进行某些转换\n    U.storeFence(); // needed to prevent certain transformations by the compiler\n\n    assert scope != this.scope || yieldInfo == null : \"scope: \" + scope + \" this.scope: \" + this.scope + \" yieldInfo: \" + yieldInfo + \" res: \" + res;\n    assert yieldInfo == null || scope == this.scope || yieldInfo instanceof Integer : \"scope: \" + scope + \" this.scope: \" + this.scope + \" yieldInfo: \" + yieldInfo + \" res: \" + res;\n\n    if (child != null) { // TODO: ugly &lt;----- 这个位置还有一句吐槽的代码注释：丑陋的代码\n        if (res != 0) {\n            child.yieldInfo = res;\n        } else if (yieldInfo != null) {\n            assert yieldInfo instanceof Integer;\n            child.yieldInfo = yieldInfo;\n        } else {\n            child.yieldInfo = res;\n        }\n        this.yieldInfo = null;\n    } else {\n        if (res == 0 &amp;&amp; yieldInfo != null) {\n            res = (Integer)yieldInfo;\n        }\n        this.yieldInfo = null;\n\n        if (res == 0)\n            // Continuation实例继续执行前回调\n            onContinue();\n        else\n            // Continuation固定在运载线程前回调，res是pined的级别\n            onPinned0(res);\n    }\n    assert yieldInfo == null;\n    // 返回布尔值结果表示当前Continuation实例是否会继续执行\n    return res == 0;\n}\n\n// 最终的yield调用，看实现是抛出异常，猜测是由JVM实现\n@IntrinsicCandidate\nprivate static int doYield() { throw new Error(\"Intrinsic not installed\"); }\n</code></pre> \n<p>说实话，<code>Continuation</code>源码的可读性比想象中低，连代码注释也留下了\"丑陋的\"这句吐槽。通过上面源码分析和上一节<code>Continuation</code>的一个例子，可以得知<code>Continuation#yield()</code>可以让程序代码中断，然后再次调用<code>Continuation#run()</code>可以从上一个中断位置继续执行，<code>JVM</code>在这个过程中为使用者屏蔽了<code>Continuation</code>和运行此<code>Continuation</code>的平台线程之间的交互细节，让使用者可以专注实际的任务开发即可。</p> \n<h3 id=\"virtualthread\">VirtualThread</h3> \n<p>前面花了不少篇幅介绍<code>Continuation</code>，它是一个全新的<code>API</code>。已有的<code>JUC</code>类库已经十分完善，如果可以把<code>Continuation</code>融入到已有的<code>JUC</code>体系，那么就可以通过线程池技术去管理运载线程，原有的大多数并发相关<code>API</code>也能直接在协程体系中使用。从这个背景来看，创造一个<code>Thread</code>类的全新子类用于融合<code>JUC</code>和<code>Continuation</code>是十分合适的，这样通过很小的改造成本就能通过<code>Java</code>继承特性把这个全新子类适配<code>JUC</code>体系，也能扩展一些<code>API</code>让它适配协程新引入的特性，这个全新的子类就是<code>java.lang.VirtualThread</code>：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/365d1ab6-19af-4109-a648-452508698f56.jpg; charset=utf-8\" alt=\"vt-source-code-12\" loading=\"lazy\"></p> \n<p><code>VirtualThread</code>类的继承体系如下：</p> \n<pre><code class=\"language-java\">package java.lang;\n\nfinal class VirtualThread extends BaseVirtualThread {\n  // ...\n}\n\npackage java.lang;\n\nsealed abstract class BaseVirtualThread extends Thread\n        permits VirtualThread, ThreadBuilders.BoundVirtualThread {\n  // ... \n}\n</code></pre> \n<p><code>VirtualThread</code>是<code>BaseVirtualThread</code>的子类，而<code>BaseVirtualThread</code>是一个\"密封类\"，它是<code>Thread</code>的子类，只对<code>VirtualThread</code>和<code>ThreadBuilders.BoundVirtualThread</code>开放，并且<code>VirtualThread</code>是<strong>包私有访问权限的</strong>同时用<code>final</code>关键字修饰，无法被继承。接着看<code>VirtualThread</code>的成员变量和构造函数：</p> \n<pre><code class=\"language-java\">// java.lang.VirtualThread\n\n// Unsafe实例\nprivate static final Unsafe U = Unsafe.getUnsafe();\n\n// 虚拟线程的ContinuationScope静态常量\nprivate static final ContinuationScope VTHREAD_SCOPE = new ContinuationScope(\"VirtualThreads\");\n\n// 调度器，或者说执行器，默认就是用此调度器运行虚拟线程\nprivate static final ForkJoinPool DEFAULT_SCHEDULER = createDefaultScheduler();\n\n// 调度线程池实例，用于唤醒带超时阻塞的虚拟线程实例，主要用于sleep的唤醒\nprivate static final ScheduledExecutorService UNPARKER = createDelayedTaskScheduler();\n\n// pin模式，也就是pined thread的跟踪模式，决定打印堆栈的详细程度，来自于系统参数jdk.tracePinnedThreads，full表示详细，short表示简略\nprivate static final int TRACE_PINNING_MODE = tracePinningMode();\n\n// 下面几个都是成员地址，用于Unsafe直接操作成员\nprivate static final long STATE = U.objectFieldOffset(VirtualThread.class, \"state\");\nprivate static final long PARK_PERMIT = U.objectFieldOffset(VirtualThread.class, \"parkPermit\");\nprivate static final long CARRIER_THREAD = U.objectFieldOffset(VirtualThread.class, \"carrierThread\");\nprivate static final long TERMINATION = U.objectFieldOffset(VirtualThread.class, \"termination\");\n\n// 调度器实例\nprivate final Executor scheduler;\n\n// Continuation实例\nprivate final Continuation cont;\n\n// Continuation实例的Runnable包装实例\nprivate final Runnable runContinuation;\n\n// 虚拟线程状态，这个值由JVM访问和修改\nprivate volatile int state;\n\n// 下面的状态集合\nprivate static final int NEW      = 0;\nprivate static final int STARTED  = 1;\nprivate static final int RUNNABLE = 2;     // runnable-unmounted\nprivate static final int RUNNING  = 3;     // runnable-mounted\nprivate static final int PARKING  = 4;\nprivate static final int PARKED   = 5;     // unmounted\nprivate static final int PINNED   = 6;     // mounted\nprivate static final int YIELDING = 7;     // Thread.yield\nprivate static final int TERMINATED = 99;  // final state\n\n// 虚拟线程unmount后可以从调度过程中挂起的状态\nprivate static final int SUSPENDED = 1 &lt;&lt; 8;\nprivate static final int RUNNABLE_SUSPENDED = (RUNNABLE | SUSPENDED);\nprivate static final int PARKED_SUSPENDED   = (PARKED | SUSPENDED);\n\n// park操作许可\nprivate volatile boolean parkPermit;\n\n// 运载线程实例\nprivate volatile Thread carrierThread;\n\n// 终结倒数栅栏实例，主要用于join操作\nprivate volatile CountDownLatch termination;\n\n// 唯一构造函数\nVirtualThread(Executor scheduler, String name, int characteristics, Runnable task) {\n    // 默认标记bound为false，当bound为true的时候标记为绑定到系统线程\n    super(name, characteristics, /*bound*/ false);\n    Objects.requireNonNull(task);\n    // 如果传入的调度器实例非空则直接使用\n    // 否则，如果父线程是虚拟线程，则使用父虚拟线程的调度器实例\n    // 如果传入的调度器实例为空，父线程为平台线程，那么使用默认的调度器\n    // choose scheduler if not specified\n    if (scheduler == null) {\n        Thread parent = Thread.currentThread();\n        if (parent instanceof VirtualThread vparent) {\n            scheduler = vparent.scheduler;\n        } else {\n            scheduler = DEFAULT_SCHEDULER;\n        }\n    }\n    // 赋值调度器\n    this.scheduler = scheduler;\n    // 封装和初始化Continuation\n    this.cont = new VThreadContinuation(this, task);\n    // 初始化Continuation的Runnable包装器，最终提交到调度器中执行\n    this.runContinuation = this::runContinuation;\n}\n\n// 虚拟线程Continuation的专有子类，默认为ContinuationScope(\"VirtualThreads\")，从而实现Continuation.enter()执行时候实际上执行的是VirtualThread.run()方法\n// 也就是 Runnable.run()[runContinuation by carrier thread from executor] --&gt; Continuation.run() --&gt; Continuation.enter() --&gt; VirtualThread.run() --&gt; Runnable.run()[user task]\nprivate static class VThreadContinuation extends Continuation {\n\n    VThreadContinuation(VirtualThread vthread, Runnable task) {\n        super(VTHREAD_SCOPE, () -&gt; vthread.run(task));\n    }\n\n    // pin之前回调的方法，基于TRACE_PINNING_MODE的返回值决定pinned线程栈的打印详略\n    @Override\n    protected void onPinned(Continuation.Pinned reason) {\n        if (TRACE_PINNING_MODE &gt; 0) {\n            boolean printAll = (TRACE_PINNING_MODE == 1);\n            PinnedThreadPrinter.printStackTrace(System.out, printAll);\n        }\n    }\n}\n\n// 在当前线程上运行或继续Continuation的执行，必须由平台线程运行此方法，最终会封装为Runnble包装器提交到执行器中运行\nprivate void runContinuation() {\n    // the carrier must be a platform thread\n    if (Thread.currentThread().isVirtual()) {\n        throw new WrongThreadException();\n    }\n\n    // set state to RUNNING\n    boolean firstRun;\n    int initialState = state();\n    // 当前为STARTED状态并且CAS更新为RUNNING状态则标记首次运行为true\n    if (initialState == STARTED &amp;&amp; compareAndSetState(STARTED, RUNNING)) {\n        // first run\n        firstRun = true;\n    } else if (initialState == RUNNABLE &amp;&amp; compareAndSetState(RUNNABLE, RUNNING)) {\n        // 当前为RUNNABLE状态并且CAS更新为RUNNING状态则标记首次运行为false，并且设置park许可为false\n        // consume parking permit\n        setParkPermit(false);\n        firstRun = false;\n    } else {\n        // not runnable\n        return;\n    }\n\n    // notify JVMTI before mount\n    if (notifyJvmtiEvents) notifyJvmtiMountBegin(firstRun);\n\n    try {\n        // 执行Continuation.run()\n        cont.run();\n    } finally {\n        // Continuation执行完成，回调钩子方法afterTerminate\n        if (cont.isDone()) {\n            afterTerminate(/*executed*/ true);\n        } else {\n            // Continuation没有执行完成，说明调用了Continuation.yield或者pin到运载线程中进行了park操作\n            afterYield();\n        }\n    }\n}\n\n// Continuation执行完成回调的钩子方法\nprivate void afterTerminate(boolean executed) {\n    assert (state() == TERMINATED) &amp;&amp; (carrierThread == null);\n\n    if (executed) {\n        if (notifyJvmtiEvents) notifyJvmtiUnmountEnd(true);\n    }\n\n    // 如果有其他线程阻塞等待虚拟线程的返回，例如调用了join方法，那么在这里解除阻塞\n    CountDownLatch termination = this.termination;\n    if (termination != null) {\n        assert termination.getCount() == 1;\n        termination.countDown();\n    }\n    \n    // 如果执行成功则通知线程容器当前线程实例退出，清空线程本地变量引用\n    if (executed) {\n        // notify container if thread executed\n        threadContainer().onExit(this);\n\n        // clear references to thread locals\n        clearReferences();\n    }\n}\n\n// 由于Continuation的yield操作或者调用了Thread.yield()导致Continuation挂起，需要重新把Continuation的包装器\"懒提交\"到调度器中\nprivate void afterYield() {\n    int s = state();\n    assert (s == PARKING || s == YIELDING) &amp;&amp; (carrierThread == null);\n    // 如果是PARKING状态，这种对应于Continuation的yield操作调用\n    if (s == PARKING) {\n        // 更变为PARKED状态\n        setState(PARKED);\n\n        // notify JVMTI that unmount has completed, thread is parked\n        if (notifyJvmtiEvents) notifyJvmtiUnmountEnd(false);\n\n        // 得到park许可，并且CAS为RUNNABLE状态\n        if (parkPermit &amp;&amp; compareAndSetState(PARKED, RUNNABLE)) {\n            // 进行懒提交，如果可能的话，用当前线程作为运载线程继续执行任务\n            lazySubmitRunContinuation();\n        }\n    } else if (s == YIELDING) {   // 如果是YIELDING状态，这种对应于调用了Thread.yield\n        // 更变为RUNNABLE状态\n        setState(RUNNABLE);\n\n        // notify JVMTI that unmount has completed, thread is runnable\n        if (notifyJvmtiEvents) notifyJvmtiUnmountEnd(false);\n\n        // 进行懒提交，如果可能的话，用当前线程作为运载线程继续执行任\n        lazySubmitRunContinuation();\n    }\n}\n</code></pre> \n<p>这里唯一的构造函数是比较复杂的，抛开一些钩子接口，最终想达到的效果就是：</p> \n<pre><code class=\"language-shell\">Runnable.run()[runContinuation by carrier thread from executor] --&gt; Continuation.run() --&gt; Continuation.enter() --&gt; VirtualThread.run() --&gt; Runnable.run()[user task]\n</code></pre> \n<p>用户任务实际被包裹了很多层，在最里面一层才会回调。<code>VirtualThread</code>中提供了两个静态全局的线程池实例，一个用于调度，一个用于唤醒，这里看看两个线程池是如何构造的：</p> \n<pre><code class=\"language-java\">// java.lang.VirtualThread\n\nprivate static final ForkJoinPool DEFAULT_SCHEDULER = createDefaultScheduler();\nprivate static final ScheduledExecutorService UNPARKER = createDelayedTaskScheduler();\n\n// 创建默认的调度器\nprivate static ForkJoinPool createDefaultScheduler() {\n    // 线程工厂，默认创建CarrierThread实例，CarrierThread是ForkJoinWorkerThread的一个子类\n    ForkJoinWorkerThreadFactory factory = pool -&gt; {\n        PrivilegedAction&lt;ForkJoinWorkerThread&gt; pa = () -&gt; new CarrierThread(pool);\n        return AccessController.doPrivileged(pa);\n    };\n    PrivilegedAction&lt;ForkJoinPool&gt; pa = () -&gt; {\n        int parallelism, maxPoolSize, minRunnable;\n        String parallelismValue = System.getProperty(\"jdk.virtualThreadScheduler.parallelism\");\n        String maxPoolSizeValue = System.getProperty(\"jdk.virtualThreadScheduler.maxPoolSize\");\n        String minRunnableValue = System.getProperty(\"jdk.virtualThreadScheduler.minRunnable\");\n        if (parallelismValue != null) {\n            parallelism = Integer.parseInt(parallelismValue);\n        } else {\n            parallelism = Runtime.getRuntime().availableProcessors();\n        }\n        if (maxPoolSizeValue != null) {\n            maxPoolSize = Integer.parseInt(maxPoolSizeValue);\n            parallelism = Integer.min(parallelism, maxPoolSize);\n        } else {\n            maxPoolSize = Integer.max(parallelism, 256);\n        }\n        if (minRunnableValue != null) {\n            minRunnable = Integer.parseInt(minRunnableValue);\n        } else {\n            minRunnable = Integer.max(parallelism / 2, 1);\n        }\n        Thread.UncaughtExceptionHandler handler = (t, e) -&gt; { };\n        boolean asyncMode = true; // FIFO\n        return new ForkJoinPool(parallelism, factory, handler, asyncMode,\n                        0, maxPoolSize, minRunnable, pool -&gt; true, 30, SECONDS);\n    };\n    return AccessController.doPrivileged(pa);\n}\n\n// 创建调度线程池，用于虚拟线程带超时时间的unpark操作\nprivate static ScheduledExecutorService createDelayedTaskScheduler() {\n    String propValue = GetPropertyAction.privilegedGetProperty(\"jdk.unparker.maxPoolSize\");\n    int poolSize;\n    if (propValue != null) {\n        poolSize = Integer.parseInt(propValue);\n    } else {\n        // 确保至少有一个工作线程\n        poolSize = 1;\n    }\n    ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n        Executors.newScheduledThreadPool(poolSize, task -&gt; {\n            return InnocuousThread.newThread(\"VirtualThread-unparker\", task);\n        });\n    // 任务取消后马上从工作队列移除\n    stpe.setRemoveOnCancelPolicy(true);\n    return stpe;\n}\n</code></pre> \n<p>对于默认调度器（<code>DEFAULT_SCHEDULER</code>）的创建，它是一个<code>ForkJoinPool</code>实例，构造参数的选取如下：</p> \n<ul> \n <li><code>parallelism</code>参数由系统变量<code>jdk.virtualThreadScheduler.parallelism</code>决定，默认值为<code>Runtime.getRuntime().availableProcessors()</code>，如果配置了系统参数<code>jdk.virtualThreadScheduler.maxPoolSize</code>则取<code>min(parallelism,maxPoolSize)</code></li> \n <li><code>maxPoolSize</code>参数由系统变量<code>jdk.virtualThreadScheduler.maxPoolSize</code>决定，默认值为<code>min(parallelism, maxPoolSize)</code></li> \n <li><code>minRunnable</code>参数由系统变量<code>jdk.virtualThreadScheduler.minRunnable</code>决定，默认值为<code>max(parallelism / 2, 1)</code></li> \n <li><code>asyncMode</code>参数固定值<code>true</code>，也就是选用<code>FIFO</code>模式</li> \n <li><code>keepAliveTime</code>参数为固定值<code>30</code>秒</li> \n <li><code>saturate</code>参数在<code>JDK17</code>引入，是一个<code>Predicate</code>函数，在此固定返回<code>true</code>，用于忽略<code>minRunnable</code>值允许线程池饱和</li> \n <li>线程工厂用于创建<code>CarrierThread</code>实例，<code>CarrierThread</code>是<code>ForkJoinWorkerThread</code>的子类</li> \n</ul> \n<p>在<code>Intel 4C8T</code>开发机器环境中，该<code>ForkJoinPool</code>实例创建时候的几个参数分别为：<code>parallelism = 8, maxPoolSize = 256, minRunnable = 4</code>。</p> \n<p>对于调度线程池（<code>UNPARKER</code>）的创建，它是一个<code>ScheduledThreadPoolExecutor</code>实例，构造参数的选取如下：</p> \n<ul> \n <li><code>corePoolSize</code>参数由系统变量<code>jdk.unparker.maxPoolSize</code>决定，并且确保最小值为<code>1</code></li> \n <li>线程工厂用于创建<code>InnocuousThread</code>实例，线程名称为<code>VirtualThread-unparker</code></li> \n</ul> \n<p>接着看虚拟线程的启动方法<code>start()</code>：</p> \n<pre><code class=\"language-java\">// java.lang.VirtualThread\n\n@Override\npublic void start() {\n    start(ThreadContainers.root());\n}\n\n// 调度虚拟线程让之运行\n@Override\nvoid start(ThreadContainer container) {\n    // CAS由NEW转换为STARTED状态\n    if (!compareAndSetState(NEW, STARTED)) {\n        throw new IllegalThreadStateException(\"Already started\");\n    }\n \n    // 绑定当前虚拟线程到线程容器\n    setThreadContainer(container);\n\n    // 标记为未启动\n    boolean started = false;\n    // 回调start钩子方法\n    container.onStart(this); // may throw\n    try {\n        // 从给定容器继承extent-local绑定参数\n        inheritExtentLocalBindings(container);\n        // 提交\'runContinuation\'任务到调度器\n        submitRunContinuation();\n        // 标记为启动完成\n        started = true;\n    } finally {\n        // 如果启动失败，则标记最终状态和回调终结钩子方法\n        if (!started) {\n            setState(TERMINATED);\n            container.onExit(this);\n            afterTerminate(/*executed*/ false);\n        }\n    }\n}\n\n// 提交\'runContinuation\'任务到调度器\nprivate void submitRunContinuation() {\n    submitRunContinuation(false);\n}\n\n// 提交\'runContinuation\'任务到调度器，lazySubmit参数决定是否\"懒提交\"\nprivate void submitRunContinuation(boolean lazySubmit) {\n    try {\n        if (lazySubmit &amp;&amp; scheduler instanceof ForkJoinPool pool) {\n            // ForkJoinPool类型调度器并且lazySubmit为true，对runContinuation这个Runnable实例适配为ForkJoinTask类型，进行\"懒提交\"到ForkJoinPool\n            pool.lazySubmit(ForkJoinTask.adapt(runContinuation));\n        } else {\n            // 非ForkJoinPool类型调度器或者lazySubmit为false，直接使用Executor.execute()提交任务\n            scheduler.execute(runContinuation);\n        }\n    } catch (RejectedExecutionException ree) {\n        // 线程池拒绝接收任务，发布提交失败事件到JVM\n        var event = new VirtualThreadSubmitFailedEvent();\n        if (event.isEnabled()) {\n            event.javaThreadId = threadId();\n            event.exceptionMessage = ree.getMessage();\n            event.commit();\n        }\n        throw ree;\n    }\n}\n</code></pre> \n<p><code>ForkJoinPool#lazySubmit()</code>是<code>JDK19</code>新增的一个<code>API</code>，它的方法注释如下：</p> \n<blockquote> \n <p>提交给定的任务，但不保证它最终会在没有可用活动线程的情况下执行。在某些上下文中，这种方法可以通过依赖于特定于上下文的知识来减少竞争和开销，即现有线程(如果在此池中操作，则可能包括调用线程)最终将可用来执行任务</p> \n</blockquote> \n<p>使用此方法提交的目的就是希望可以用当前调用线程去执行任务，对于首次提交<code>Continuation</code>任务可能作用不明显，但是对于<code>Continuation.yield()</code>调用后的再次提交意义比较重大，因为这样就可以<strong>把运行的<code>Continuation.run()</code>方法链分配到同一个运载线程实例</strong>，在开发者的角度就是虚拟线程任务执行中断后恢复执行，执行任务的运载线程没有改变。</p> \n<p>源码中还可以发现，<code>run()</code>方法覆盖了<code>Thread#run()</code>替换为空实现，因为<code>VirtualThread</code>最终是触发<code>Continuation#run()</code>，这一点已经在<code>start()</code>方法进行提交和调度。最后分析虚拟线程的阻塞（不带超时，也就是<code>timeout = 0</code>）、限时阻塞（<code>timeout &gt; 0</code>）、<code>join</code>的实现。先看相对简单的<code>joinNanos()</code>：</p> \n<pre><code class=\"language-java\">// java.lang.VirtualThread\n// Thread.join() --&gt; VirtualThread.joinNanos()\n\n// 虚拟线程join调用\nboolean joinNanos(long nanos) throws InterruptedException {\n    // 如果状态为TERMINATED直接返回true\n    if (state() == TERMINATED)\n        return true;\n    // 获取数栅栏实例\n    CountDownLatch termination = getTermination();\n    // 再次验证如果状态为TERMINATED直接返回true\n    if (state() == TERMINATED)\n        return true;\n\n    // 如果nanos为0则调用CountDownLatch.await()阻塞\n    if (nanos == 0) {\n        termination.await();\n    } else {\n        // 如果nanos大于0则调用CountDownLatch.await(nanos,TimeUnit)限时阻塞\n        boolean terminated = termination.await(nanos, NANOSECONDS);\n        if (!terminated) {\n            // 阻塞到超时时限过了返回，非解除阻塞下的正常返回\n            return false;\n        }\n    }\n    assert state() == TERMINATED;\n    // 解除阻塞下的正常返回\n    return true;\n}\n\n// 懒创建终结倒数栅栏实例，设置资源值为1，这里用到CAS是考虑之前已经创建和保存到成员变量，如果已创建则直接选用成员变量的那个实例\nprivate CountDownLatch getTermination() {\n    CountDownLatch termination = this.termination;\n    if (termination == null) {\n        termination = new CountDownLatch(1);\n        if (!U.compareAndSetReference(this, TERMINATION, null, termination)) {\n            termination = this.termination;\n        }\n    }\n    return termination;\n}\n</code></pre> \n<p>接着看虚拟线程阻塞和限时阻塞的现实：</p> \n<pre><code class=\"language-java\">// java.lang.VirtualThread\n// Thread.sleep() --&gt; VirtualThread.sleepNanos()\n\n// 给定休眠时间让当前虚拟线程休眠\nvoid sleepNanos(long nanos) throws InterruptedException {\n    assert Thread.currentThread() == this;\n    // nanos必须大于等于0\n    if (nanos &gt;= 0) {\n        // 如果支持线程休眠事件发布则在休眠处理前后处理休眠事件，最终的休眠操作调用doSleepNanos()完成\n        if (ThreadSleepEvent.isTurnedOn()) {\n            ThreadSleepEvent event = new ThreadSleepEvent();\n            try {\n                event.time = nanos;\n                event.begin();\n                doSleepNanos(nanos);\n            } finally {\n                event.commit();\n            }\n        } else {\n            doSleepNanos(nanos);\n        }\n    }\n}\n\n// 让当前线程休眠给定的睡眠时间(单位为纳秒)。如果nanos为0时，线程将尝试yield\nprivate void doSleepNanos(long nanos) throws InterruptedException {\n    assert nanos &gt;= 0;\n    // 响应中断清理中断状态，抛出中断异常\n    if (getAndClearInterrupt())\n        throw new InterruptedException();\n    if (nanos == 0) {\n        // nanos为0的时候直接进行yield操作，具体是Continuation.yield()\n        tryYield();\n    } else {\n        // park for the sleep time\n        try {\n            long remainingNanos = nanos;\n            // 临时变量记录开始休眠时间\n            long startNanos = System.nanoTime();\n            while (remainingNanos &gt; 0) {\n                // 剩余休眠时间大于0纳秒，进行park操作\n                parkNanos(remainingNanos);\n                // 响应中断清理中断状态，抛出中断异常\n                if (getAndClearInterrupt()) {\n                    throw new InterruptedException();\n                }\n                // 重新计算剩余休眠事件\n                remainingNanos = nanos - (System.nanoTime() - startNanos);\n            }\n        } finally {\n            // park会消耗park许可，走到这里说明unpark了，可以重新设置许可\n            setParkPermit(true);\n        }\n    }\n}\n\n// 当前虚拟线程park（阻塞）直至指定等候时间，进行unpark操作或者中断也能解除park状态\n@Override\nvoid parkNanos(long nanos) {\n    assert Thread.currentThread() == this;\n\n    // 已经消耗了park许可或者处于中断状态，直接返回\n    if (getAndSetParkPermit(false) || interrupted)\n        return;\n\n    // 当前虚拟线程park（阻塞）直至指定等候时间\n    if (nanos &gt; 0) {\n        // 记录开始park的时间\n        long startTime = System.nanoTime();\n        // 记录是否yield成功\n        boolean yielded;\n        // 通过调度线程池提交一个延时执行的unpark任务，用于进行unpark操作解除当前虚拟线程阻塞等待\n        Future&lt;?&gt; unparker = scheduleUnpark(nanos);\n        // 设置为PARKING状态\n        setState(PARKING);\n        try {\n            // 执行Continuation.yield()\n            yielded = yieldContinuation();\n        } finally {\n            assert (Thread.currentThread() == this)\n                    &amp;&amp; (state() == RUNNING || state() == PARKING);\n            // 执行Continuation.yield()执行完毕后，如果该unparker任务未完成则进行取消操作\n            cancel(unparker);\n        }\n\n        // Continuation.yield()调用失败，则重新计算等待时间并基于运载线程进行park操作\n        if (!yielded) {\n            long deadline = startTime + nanos;\n            if (deadline &lt; 0L)\n                deadline = Long.MAX_VALUE;\n            parkOnCarrierThread(true, deadline - System.nanoTime());\n        }\n    }\n}\n\n// 当前虚拟线程的运载线程park（阻塞）直至指定等候时间，这就是前面提到过的pinned thread产生的过程\nprivate void parkOnCarrierThread(boolean timed, long nanos) {\n    assert state() == PARKING;\n\n    var pinnedEvent = new VirtualThreadPinnedEvent();\n    pinnedEvent.begin();\n    // 设置状态为PINNED\n    setState(PINNED);\n    try {\n        // 如果没有park许可，则不处理，否则使用Usafe的park api进行平台线程阻塞\n        if (!parkPermit) {\n            if (!timed) {\n                U.park(false, 0);\n            } else if (nanos &gt; 0) {\n                U.park(false, nanos);\n            }\n        }\n    } finally {\n        // 阻塞解除后状态为RUNNING\n        setState(RUNNING);\n    }\n\n    // 解除阻塞后此park操作消耗了park许可\n    setParkPermit(false);\n\n    pinnedEvent.commit();\n}\n\n@ChangesCurrentThread\nprivate Future&lt;?&gt; scheduleUnpark(long nanos) {\n    Thread carrier = this.carrierThread;\n    // need to switch to current platform thread to avoid nested parking\n    carrier.setCurrentThread(carrier);\n    try {\n        return UNPARKER.schedule(() -&gt; unpark(), nanos, NANOSECONDS);\n    } finally {\n        carrier.setCurrentThread(this);\n    }\n}\n\n// 如果unpark任务未完成则取消它，这个过程需要切换到当前平台线程以避免嵌套park操作\n@ChangesCurrentThread\nprivate void cancel(Future&lt;?&gt; future) {\n    if (!future.isDone()) {\n        Thread carrier = this.carrierThread;\n        // need to switch to current platform thread to avoid nested parking\n        carrier.setCurrentThread(carrier);\n        try {\n            future.cancel(false);\n        } finally {\n            carrier.setCurrentThread(this);\n        }\n    }\n}\n\n// unpark操作，重新启用当前虚拟线程进行调度，如果虚拟线程处于park状态会将它解除阻塞\n@Override\n@ChangesCurrentThread\nvoid unpark() {\n    Thread currentThread = Thread.currentThread();\n    // 重置park许可false -&gt; true，并且判断当前线程是虚拟线程\n    if (!getAndSetParkPermit(true) &amp;&amp; currentThread != this) {\n        int s = state();\n        // 命中虚拟线程PARKED状态，则CAS设置为RUNNABLE状态，并且重新提交Continuation的Runnable包装器到调度器中，这个提交过程需要切换到当前运载线程，然后恢复为当前虚拟线程\n        if (s == PARKED &amp;&amp; compareAndSetState(PARKED, RUNNABLE)) {\n            if (currentThread instanceof VirtualThread vthread) {\n                Thread carrier = vthread.carrierThread;\n                carrier.setCurrentThread(carrier);\n                try {\n                    submitRunContinuation();\n                } finally {\n                    carrier.setCurrentThread(vthread);\n                }\n            } else {\n                submitRunContinuation();\n            }\n        } else if (s == PINNED) {\n            // park操作基于运载线程阻塞，则调用Usafe的unpark api进行唤醒，唤醒后在parkOnCarrierThread()中会重新被修改为RUNNING状态\n            synchronized (carrierThreadAccessLock()) {\n                Thread carrier = carrierThread;\n                if (carrier != null &amp;&amp; state() == PINNED) {\n                    U.unpark(carrier);\n                }\n            }\n        }\n    }\n}\n\n// 尝试执行Continuation.yield()\nvoid tryYield() {\n    assert Thread.currentThread() == this;\n    // 设置状态为YIELDING\n    setState(YIELDING);\n    try {\n        // 执行Continuation.yield()，忽略返回值处理\n        yieldContinuation();\n    } finally {\n        assert Thread.currentThread() == this;\n        // 虚拟线程重新mount并且运行，设置为RUNNING状态\n        if (state() != RUNNING) {\n            assert state() == YIELDING;\n            setState(RUNNING);\n        }\n    }\n}\n\n// 执行Continuation.yield()\nprivate boolean yieldContinuation() {\n    boolean notifyJvmti = notifyJvmtiEvents;\n    // 当前虚拟线程进行unmount操作\n    if (notifyJvmti) notifyJvmtiUnmountBegin(false);\n    unmount();\n    try {\n        // 执行Continuation.yield()\n        return Continuation.yield(VTHREAD_SCOPE);\n    } finally {\n        // 当前虚拟线程重新进行mount操作\n        mount();\n        if (notifyJvmti) notifyJvmtiMountEnd(false);\n    }\n}\n</code></pre> \n<p>总的来说就是：</p> \n<ul> \n <li>阻塞：通过<code>Continuation.yield()</code>调用实现阻塞，主要是提供给<code>Thread.sleep()</code>调用</li> \n <li>限时阻塞：<code>Continuation.yield()</code>调用之前计算唤醒时间并且向调度线程池（<code>UNPARKER</code>）提交一个<strong>延时执行</strong>的<code>unpark</code>任务通过\"懒提交\"方式重新运行<code>Continuation.run()</code>调用链解除阻塞，主要是提供给<code>Thread.sleep(long nanos)</code>调用</li> \n <li><code>join(Nanos)</code>：通过<code>CountDownLatch.await()</code>调用实现阻塞，在虚拟线程终结钩子方法<code>afterTerminate()</code>中调用<code>CountDownLatch.countDown()</code>解除阻塞，<code>join(Nanos)()</code>方法主要是提供给<code>Thread.join()</code>调用</li> \n <li>特殊情况：如果<code>Continuation.yield()</code>调用失败，则会通过<code>Unsafe</code>提供的<code>park API</code>阻塞在运载线程上，在<code>unpark</code>任务中通过<code>Unsafe</code>提供的<code>unpark API</code>解除阻塞</li> \n</ul> \n<p>分析完虚拟线程实现的核心代码，这里总结一下虚拟线程的状态切换，由于支持的状态比较多，这里通过一张状态图进行展示：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/356bb6c0-9bb0-4755-8b2d-ccaf2e0704a2.jpg; charset=utf-8\" alt=\"vt-source-code-13\" loading=\"lazy\"></p> \n<p>还有其他像获取虚拟线程栈、<code>JVM</code>状态通知、获取虚拟线程状态、状态切换的<code>CAS</code>操作等方法限于篇幅这里就不展开分析。</p> \n<h3 id=\"线程建造器\">线程建造器</h3> \n<p>线程建造器和线程工厂建造器用于快速创建平台线程实例、平台线程工厂实例、虚拟线程实例或者虚拟线程工厂实例。熟悉<code>Builder</code>模式的开发者看这个新引入的功能源码应该比较轻松：</p> \n<pre><code class=\"language-java\">// 内部类：java.lang.Thread.Builder\n// Builder只对OfPlatform、OfVirtual、BaseThreadBuilder开放继承权限\n@PreviewFeature(feature = PreviewFeature.Feature.VIRTUAL_THREADS)\npublic sealed interface Builder\n        permits Builder.OfPlatform,\n                Builder.OfVirtual,\n                ThreadBuilders.BaseThreadBuilder {\n\n    // 设置线程名称\n    Builder name(String name);\n    \n    // 设置线程名称规则，最终线程名称为：$prefix$start++\n    // 如prefix: worker-, start: 0，则worker-0, worker-1.... worker-n\n    Builder name(String prefix, long start);\n\n    Builder allowSetThreadLocals(boolean allow);\n\n    // 是否开启InheritableThreadLocal\n    Builder inheritInheritableThreadLocals(boolean inherit);\n\n    // 设置未捕获异常处理器\n    Builder uncaughtExceptionHandler(UncaughtExceptionHandler ueh);\n\n    // 设置非启动前的任务实例\n    Thread unstarted(Runnable task);\n\n    // 设置任务实例并且马上启动\n    Thread start(Runnable task);\n\n    // 构建线程工厂实例\n    ThreadFactory factory();\n\n    // 平台线程Builder接口\n    @PreviewFeature(feature = PreviewFeature.Feature.VIRTUAL_THREADS)\n    sealed interface OfPlatform extends Builder\n            permits ThreadBuilders.PlatformThreadBuilder {\n\n        @Override OfPlatform name(String name);\n        @Override OfPlatform name(String prefix, long start);\n        @Override OfPlatform allowSetThreadLocals(boolean allow);\n        @Override OfPlatform inheritInheritableThreadLocals(boolean inherit);\n        @Override OfPlatform uncaughtExceptionHandler(UncaughtExceptionHandler ueh);\n\n        // 设置平台线程组\n        OfPlatform group(ThreadGroup group);\n\n        // 设置新建平台线程是否为守护线程\n        OfPlatform daemon(boolean on);\n\n        // 判断新建平台线程是否为守护线程\n        default OfPlatform daemon() {\n            return daemon(true);\n        }\n\n        // 设置优先级\n        OfPlatform priority(int priority);\n\n        // 设置线程栈大小\n        OfPlatform stackSize(long stackSize);\n    }\n\n    // 虚拟线程Builder接口\n    @PreviewFeature(feature = PreviewFeature.Feature.VIRTUAL_THREADS)\n    sealed interface OfVirtual extends Builder\n            permits ThreadBuilders.VirtualThreadBuilder {\n\n        @Override OfVirtual name(String name);\n        @Override OfVirtual name(String prefix, long start);\n        @Override OfVirtual allowSetThreadLocals(boolean allow);\n        @Override OfVirtual inheritInheritableThreadLocals(boolean inherit);\n        @Override OfVirtual uncaughtExceptionHandler(UncaughtExceptionHandler ueh);\n    }\n}\n</code></pre> \n<p>上面的<code>Builder</code>接口都在<code>java.lang.ThreadBuilders</code>中进行实现，因为整体实现比较简单，这里只看全新引入的<code>VirtualThreadFactory</code>和<code>VirtualThreadBuilder</code>：</p> \n<pre><code class=\"language-java\">// 内部类：java.lang.ThreadBuilders.VirtualThreadFactory\nprivate static class VirtualThreadFactory extends BaseThreadFactory {\n\n    // 执行器或者说调度器实例\n    private final Executor scheduler;\n    \n    // 线程工厂构造函数基本与平台线程工厂实现一致，但是必须提供执行器实例\n    VirtualThreadFactory(Executor scheduler,\n                         String name,\n                         long start,\n                         int characteristics,\n                         UncaughtExceptionHandler uhe) {\n        super(name, start, characteristics, uhe);\n        this.scheduler = scheduler;\n    }\n\n    @Override\n    public Thread newThread(Runnable task) {\n        Objects.requireNonNull(task);\n        // 获取下一个虚拟线程名称，start &gt;= 0则为$name$start++，否则固定为name\n        String name = nextThreadName();\n        // 创建新的虚拟线程实例\n        Thread thread = newVirtualThread(scheduler, name, characteristics(), task);\n        UncaughtExceptionHandler uhe = uncaughtExceptionHandler();\n        if (uhe != null)\n            // 设置未捕获异常处理器\n            thread.uncaughtExceptionHandler(uhe);\n        return thread;\n    }\n}\n\n// 静态方法：java.lang.ThreadBuilders#newVirtualThread()\nstatic Thread newVirtualThread(Executor scheduler,\n                               String name,\n                               int characteristics,\n                               Runnable task) {\n    // 当前JVM支持Continuation，则创建初始化一个新的虚拟线程实例\n    if (ContinuationSupport.isSupported()) {\n        return new VirtualThread(scheduler, name, characteristics, task);\n    } else {\n        // 当前的JVM不支持Continuation，则虚拟线程退化为一个平台线程的包装类，要求执行器必须为空\n        if (scheduler != null)\n            throw new UnsupportedOperationException();\n        return new BoundVirtualThread(name, characteristics, task);\n    }\n}\n\n// 内部类：java.lang.ThreadBuilders.VirtualThreadBuilder\nstatic final class VirtualThreadBuilder\n        extends BaseThreadBuilder&lt;OfVirtual&gt; implements OfVirtual {\n\n    // 执行器成员变量\n    private Executor scheduler;\n\n    VirtualThreadBuilder() {\n    }\n    \n    // 目前VirtualThreadBuilder的构造都是默认修饰符，Executor只能在单元测试中调用\n    // 也就是用户无法设置Executor，因为所有虚拟线程默认都是由全局的ForkJoinPool调度\n    // invoked by tests\n    VirtualThreadBuilder(Executor scheduler) {\n        if (!ContinuationSupport.isSupported())\n            throw new UnsupportedOperationException();\n        this.scheduler = Objects.requireNonNull(scheduler);\n    }\n    \n    // 创建虚拟线程实例，设置任务，处于非启动状态\n    @Override\n    public Thread unstarted(Runnable task) {\n        Objects.requireNonNull(task);\n        var thread = newVirtualThread(scheduler, nextThreadName(), characteristics(), task);\n        UncaughtExceptionHandler uhe = uncaughtExceptionHandler();\n        if (uhe != null)\n            thread.uncaughtExceptionHandler(uhe);\n        return thread;\n    }\n\n    // 创建虚拟线程实例，设置任务并且马上启动\n    @Override\n    public Thread start(Runnable task) {\n        Thread thread = unstarted(task);\n        thread.start();\n        return thread;\n    }\n    \n    // 初始化虚拟线程工厂实例\n    @Override\n    public ThreadFactory factory() {\n        return new VirtualThreadFactory(scheduler, name(), counter(), characteristics(),\n                uncaughtExceptionHandler());\n    }\n}\n</code></pre> \n<p>值得注意的是：虚拟线程实现上来看都是\"守护线程\"，也就是说虚拟线程不需要设置<code>daemon</code>参数。平台线程或者虚拟线程的建造器或者工厂实现都是包访问权限的内部类，其父类使用了<code>permits</code>关键字指定继承范围，目前是只能通过链式设置值的方式初始化，无法修改其中的成员或者方法。</p> \n<h2 id=\"其他探讨\">其他探讨</h2> \n<p>其他探讨主要包括：</p> \n<ul> \n <li>自定义执行器</li> \n <li>内存占用评估</li> \n <li>局限性</li> \n <li>适用场景</li> \n <li><code>JUC</code>亲和性</li> \n</ul> \n<h3 id=\"自定义执行器\">自定义执行器</h3> \n<p>虽然虚拟线程建造器屏蔽了执行器<code>Executor</code>实例的公共访问权限，在目前预留功能版本下只能所有虚拟线程的任务最终都是由全局的<code>ForkJoinPool</code>执行，可以通过<code>VarHandle</code>对其进行强制值设置，这样就能修改虚拟线程底层的载体线程为我们自定义线程池中的平台线程，例如这样：</p> \n<pre><code class=\"language-java\">public class VirtualThreadCustomExecutor {\n\n    /**\n     * virtual thread with custom executor\n     * add VM options: --add-opens java.base/java.lang=ALL-UNNAMED --add-opens java.base/java.lang.reflect=ALL-UNNAMED\n     */\n    public static void main(String[] args) throws Exception {\n        ExecutorService carrier = Executors.newSingleThreadExecutor(runnable -&gt; {\n            Thread thread = new Thread(runnable);\n            thread.setDaemon(true);\n            thread.setName(\"CustomVirtualCarrier\");\n            return thread;\n        });\n        Thread.Builder.OfVirtual ofVirtual = Thread.ofVirtual();\n        Class&lt;?&gt; klass = Class.forName(\"java.lang.ThreadBuilders$VirtualThreadBuilder\");\n        VarHandle varHandle = MethodHandles.privateLookupIn(klass, MethodHandles.lookup()).findVarHandle(klass, \"scheduler\", Executor.class);\n        varHandle.set(ofVirtual, carrier);\n        ThreadFactory factory = ofVirtual.name(\"VirtualWorker-\", 0).allowSetThreadLocals(false).factory();\n        ExecutorService virtualWorkerPool = Executors.newThreadPerTaskExecutor(factory);\n        virtualWorkerPool.execute(() -&gt; {\n            Thread thread = Thread.currentThread();\n            System.out.printf(\"first task ==&gt; 线程名称:%s,载体线程名称:%s,是否虚拟线程:%s\\n\", thread.getName(), getCurrentCarrierThreadName(thread), thread.isVirtual());\n        });\n        virtualWorkerPool.execute(() -&gt; {\n            Thread thread = Thread.currentThread();\n            System.out.printf(\"second task ==&gt; 线程名称:%s,载体线程名称:%s,是否虚拟线程:%s\\n\", thread.getName(), getCurrentCarrierThreadName(thread), thread.isVirtual());\n        });\n        Thread.sleep(Long.MAX_VALUE);\n    }\n\n    private static String getCurrentCarrierThreadName(Thread currentThread) {\n        if (currentThread.isVirtual()) {\n            try {\n                MethodHandle methodHandle = MethodHandles.privateLookupIn(Thread.class, MethodHandles.lookup())\n                        .findStatic(Thread.class, \"currentCarrierThread\", MethodType.methodType(Thread.class));\n                Thread carrierThread = (Thread) methodHandle.invoke();\n                return carrierThread.getName();\n            } catch (Throwable e) {\n                e.printStackTrace();\n            }\n        }\n        return \"UNKNOWN\";\n    }\n}\n\n// 运行结果\nfirst task ==&gt; 线程名称:VirtualWorker-0,载体线程名称:CustomVirtualCarrier,是否虚拟线程:true\nsecond task ==&gt; 线程名称:VirtualWorker-1,载体线程名称:CustomVirtualCarrier,是否虚拟线程:true\n</code></pre> \n<p>可以看到最终效果，虚拟线程中的任务最终在自定义线程池中的唯一平台线程中运行。<strong>这里只是做一个实验性例子</strong>，使用反射或者<code>MethodHandle</code>对未稳定的<code>API</code>进行操作以后有很大概率会出现兼容性问题，不建议在生产环境这样操作，待虚拟线程完成预览正式发布后应该会提供对应的<code>API</code>让开发者设置自定义执行器。</p> \n<h3 id=\"资源占用评估\">资源占用评估</h3> \n<p>平台线程（单个实例）的资源占用：</p> \n<ul> \n <li>通常是预留<code>1 mb</code>线程栈空间，额外需要<code>16 kb</code>操作系统核心数据源结构</li> \n <li>对于已经启动的平台线程实例，会占据<code>2000+ byte</code>数据，包括<code>VM</code>中平台线程的元数据等</li> \n</ul> \n<p>虚拟线程（单个实例）的资源占用：</p> \n<ul> \n <li><code>Continuation</code>栈会占据数百<code>byte</code>到数百<code>kb</code>内存空间</li> \n <li>虚拟线程实例会占据<code>200 - 240 byte</code></li> \n</ul> \n<p>两者对比一看，理论上得知单个平台线程占用的内存空间至少是<code>kb</code>级别的，而通常单个虚拟线程实例占用的内存空间是<code>byte</code>级别，两者的内存占用相差<code>1</code>个数量级。这里可以<strong>使用<code>NMT</code>参数和<code>jcmd</code>命令</strong>进行验证，见下面的代码和结果。</p> \n<pre><code class=\"language-java\">public class PlatformThreadFootprint {\n\n    private static final int COUNT = 100000;\n\n    /**\n     * platform thread footprint -Xms1g -Xmx1g -XX:NativeMemoryTracking=detail\n     *\n     * @param args args\n     */\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i &lt; COUNT; i++) {\n            new Thread(() -&gt; {\n                try {\n                    Thread.sleep(Long.MAX_VALUE);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }, String.valueOf(i)).start();\n        }\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n</code></pre> \n<p>上面的程序运行后启动<code>10w</code>平台线程，通过<code>NMT</code>参数和<code>jcmd</code>命令查看所有线程占据的内存空间如下：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/792c72ba-6b67-4e8a-940e-abfa11b7c52c.jpg; charset=utf-8\" alt=\"vt-source-code-3\" loading=\"lazy\"></p> \n<p>可见总已提交内存大部分来自创建的平台线程，这些平台线程占用了大概<code>613 mb</code>空间，它们的总线程栈空间占用约为<code>5862 mb</code>，两者加起来占据总使用内存（<code>7495 mb</code>）的<code>86 %</code>以上。用类似的方式编写运行虚拟线程的程序：</p> \n<pre><code class=\"language-java\">public class VirtualThreadFootprint {\n\n    private static final int COUNT = 100000;\n\n    /**\n     * virtual thread footprint -Xms10m -Xmx100m -XX:NativeMemoryTracking=detail\n     *\n     * @param args args\n     */\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i &lt; COUNT; i++) {\n            Thread.startVirtualThread(() -&gt; {\n                try {\n                    Thread.sleep(Long.MAX_VALUE);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            });\n        }\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n</code></pre> \n<p>上面的程序运行后启动<code>10w</code>虚拟线程，同样通过<code>NMT</code>参数和<code>jcmd</code>命令查看：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/ffae621f-0a6b-4b0c-8731-9230cdb10d79.jpg; charset=utf-8\" alt=\"vt-source-code\" loading=\"lazy\"></p> \n<p>这里有意缩小虚拟线程程序的最小最大堆内存为<code>-Xms10m -Xmx100m</code>，程序依然正常运行，并且堆内存的实际占用量和总内存的实际占用量都不超过<code>200 mb</code>，由此可以证明虚拟线程确实在极大量创建的前提下不会占据大量内存空间（这里暂时没有考虑到复杂调用情况下<code>Continuation</code>栈占据内存空间大小，不过已经大幅度优于平台线程）。</p> \n<h3 id=\"局限性\">局限性</h3> \n<p>当前的虚拟线程实现有如下局限性：</p> \n<ul> \n <li><code>Continuation</code>栈存在<code>native</code>方法或者外部函数（<code>FFM</code>的<code>API</code>，见<code>JEP-424</code>）调用不能进行<code>yield</code>操作</li> \n <li>当持有监视器或者等待监视器的时候（一般是使用了<code>synchronized</code>关键字或者<code>Object.wait()</code>）不能进行<code>yield</code>操作</li> \n <li><code>Continuation</code>栈存在<code>native</code>方法调用、外部函数调用或者当持有监视器或者等待监视器的时候，虚拟线程会<code>Pin</code>到平台线程，导致虚拟线程无法从平台线程卸载，虽然不会影响程序正确执行，但是会影响性能，也就是如果这些虚拟线程是可复用的，永远无法切换到其运载线程，导致任务切换开销永久性增大</li> \n <li>虚拟线程可以像平台线程一样使用<code>ThreadLocal</code>，但是由于一般虚拟线程实例是会大量创建的，<code>ThreadLocal</code>本质是哈希表的一个链接，创建大量哈希表会带来额外的内存开销（这一点不算局限性，更接近于开发建议，<strong>建议使用虚拟线程的时候禁用ThreadLocal</strong>）</li> \n</ul> \n<p>对于前三点出现的情况，一些文档中提到会导致虚拟线程无法从运载线程卸载，这个现象称为<code>Pinned Thread</code>，通过系统参数<code>jdk.tracePinnedThreads</code>可以打印具体的<code>Pinned Thread</code>栈，从而定位到哪些虚拟线程被固定到哪些平台线程中。对于这个问题，目前可以通过编程规范去规避，也就是虚拟线程执行的任务尽量规避调用<code>native</code>方法或者外部函数，对于<code>synchronized</code>关键字可以使用<code>JUC</code>中的锁<code>API</code>进行替换，例如<code>ReentrantLock</code>等等。</p> \n<h3 id=\"适用场景\">适用场景</h3> \n<p>基于继承的特性，通过对<code>java.lang.Thread</code>（虚拟线程的超类）薄封装，也就是基于<code>Thread</code>的<code>API</code>可以直接透明地实现虚拟线程的挂起和恢复等操作，对使用者屏蔽了虚拟线程复杂的调度实现。由于虚拟线程实例占据的资源比较少，可以大量地创建而无须考虑池化，因此满足类似下面的使用场景：</p> \n<ul> \n <li>大批量的处理时间较短的计算任务</li> \n <li>大量的<code>IO</code>阻塞等待处理</li> \n <li><code>thread-per-request</code>风格的应用程序，例如主流的<code>Tomcat</code>线程模型或者基于类似线程模型实现的<code>SpringMVC</code>框架等等</li> \n</ul> \n<h3 id=\"juc亲和性\">JUC亲和性</h3> \n<p>还是基于继承的特性，<code>java.lang.VirtualThread</code>是<code>java.lang.Thread</code>子类型，因此使用到<code>Thread</code>类型的地方原则上可以透明使用<code>VirtualThread</code>，就是说通过下面的形式可以<strong>池化虚拟线程</strong>：</p> \n<pre><code class=\"language-java\">public class VirtualThreadPool {\n    \n    public static void main(String[] args) throws Exception {\n        ThreadFactory factory = Thread.ofVirtual().allowSetThreadLocals(false)\n                .name(\"VirtualFactoryWorker-\", 0)\n                .inheritInheritableThreadLocals(false)\n                .factory();\n        // core = max = 10\n        ThreadPoolExecutor fixedVirtualThreadPool\n                = new ThreadPoolExecutor(10, 10, 0, TimeUnit.SECONDS, new LinkedBlockingQueue&lt;&gt;(), factory);\n        fixedVirtualThreadPool.execute(() -&gt; {\n            Thread thread = Thread.currentThread();\n            System.out.printf(\"线程名称:%s,是否虚拟线程:%s\\n\", thread.getName(), thread.isVirtual());\n        });\n        fixedVirtualThreadPool.shutdown();\n        fixedVirtualThreadPool.awaitTermination(5, TimeUnit.SECONDS);\n    }\n}\n</code></pre> \n<p>但是前面也提到过：由于虚拟线程本身是轻量级的，在执行计算任务的时候更建议每个任务新创建一个虚拟线程实例，<strong>因为池化操作本身是会引入额外开销</strong>。另外，<code>JUC</code>下很多类库都是基于<code>AQS</code>数据结构实现，而<code>AQS</code>中无论独占模式还是共享模式，在队列中等待的节点以及抢占虚拟头节点的对象本质都是<code>Thread</code>实例，基于这一点来看，<code>AQS</code>也是无缝适配<code>VirtualThread</code>。见下面的例子：</p> \n<pre><code class=\"language-java\">public class VirtualThreadJuc {\n\n    public static void main(String[] args) throws Exception {\n        CountDownLatch latch = new CountDownLatch(1);\n        Thread.startVirtualThread(() -&gt; {\n            try {\n                System.out.println(\"before await\");\n                latch.await();\n                System.out.println(\"after await\");\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            Thread thread = Thread.currentThread();\n            System.out.printf(\"线程名称:%s,是否虚拟线程:%s\\n\", thread.getName(), thread.isVirtual());\n        });\n        Thread.sleep(1000);\n        System.out.println(\"main count down\");\n        latch.countDown();\n        Thread.sleep(Long.MAX_VALUE);\n    }\n}\n\n// 运行结果\nbefore await\nmain count down\nafter await\n线程名称:,是否虚拟线程:true\n</code></pre> \n<p>总的来说，<code>VirtualThread</code>与<code>JUC</code>既有类库是亲和的，大部分类库可以在虚拟线程任务中使用，并且不建议池化虚拟线程而是从使用<code>per task per virtual thread</code>的编程模式。</p> \n<h2 id=\"小结\">小结</h2> \n<p>本文详细介绍了平台线程与虚拟线程的区别、虚拟线程实现原理、虚拟线程的源码实现以及关于虚拟线程的一些探讨，希望能够帮到读者理解<code>Java</code>虚拟线程。在<code>JDK19</code>中，虚拟线程是预览特性，希望这个特性能够早点发布<code>GA</code>版本，这样才能填补<code>Java</code>协程这一块短板，也能让大量基础<code>API</code>和框架进行一轮革新。</p> \n<p>参考资料：</p> \n<ul> \n <li><code>JEP-425</code>：<code>https://openjdk.org/jeps/425</code></li> \n <li><code>JVMLS2018.pdf</code>（这份PDF文档详细地介绍了Loom项目的目标和实现方式）：<code>https://cr.openjdk.java.net/~rpressler/loom/loom/JVMLS2018.pdf</code></li> \n</ul> \n<p>（本文完 e-a-20221005 c-3-d）</p>',100,NULL,0,'https://www.cnblogs.com/throwable/p/16758997.html','2022-10-07 06:30:18'),(23,'.Net WebApi 中的 FromBody FromForm FromQuery FromHeader FromRoute',NULL,NULL,0,0,'<p>　　在日常后端Api开发中，我们跟前端的沟通中，通常需要协商好入参的数据类型，和参数是通过什么方式存在于请求中的，是表单（form）、请求体（body）、地址栏参数（query）、还是说通过请求头（header）。</p> \n<p>　　当协商好后，我们的接口又需要怎么去接收这些数据呢？很多小伙伴可能上手就是直接写一个实体，作为 api 函数的入参，然后就愉快的编写代码了；前端调用时却报 400 错误，可以说是一脸懵；当然，很多情况下这样写是不会报错的，因为我们需要的数据，往往只会存在于一个地方，就是请求体（body），而我们的 .Net Core 又足够的强大，导致本不严谨的操作却不会发生 bug。</p> \n<p>　　而当出现这样的一个需求的时候，小伙伴们思考一下应该怎么做：一个 Post 请求，参数分别放在了 地址栏（url?key=#$!fsefes&amp;token......）、和请求体中（ {“name”:\"小明\",\"\"sex:\"男\"} ）；像这个需求我们的后端接口应该怎么写呢？下面我们尝试一下不严谨的做法。</p> \n<p>　　首先我们定义一个实体 Info</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span><span style=\"color: rgba(0, 0, 0, 1)\"> Info\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">string</span>? Name { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">string</span>? Sex { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n}</span></pre> \n</div> \n<p>　　而又因为 Url 中的参数数量比较多，常规的一个做法，也是定义一个实体类去接收</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span><span style=\"color: rgba(0, 0, 0, 1)\"> Parameters\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">string</span>? Key { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">string</span>? Token { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">string</span>? Time { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n}</span></pre> \n</div> \n<p>　　然后编写 Post 接口函数，非常简单</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 0, 1)\">[HttpPost]\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span> Post(<span style=\"color: rgba(0, 0, 255, 1)\">Parameters</span><span style=\"color: rgba(0, 0, 0, 1)\"> parameters, Info info)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(128, 0, 128, 1)\">200</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n}</span></pre> \n</div> \n<p>　　我们直接 F5 把项目跑起来，你会发现，程序报错了，因为程序分不清谁跟谁了</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/22bc2991-8229-43eb-bbce-38ead0c674ba.png\" alt=\"\" loading=\"lazy\"></p> \n<p>&nbsp;</p> \n<p>&nbsp;　　而错误提示非常的清楚，你要使用 FromQuery 特性，现在我们给参数加上这个特性</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 0, 1)\">[HttpPost]\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\"> Post([FromQuery]Parameters parameters, Info info)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(128, 0, 128, 1)\">200</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n}</span></pre> \n</div> \n<p>　　再次启动后，代码不报错了，我们看一下 swagger</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/bba72bc6-d54f-400c-932b-3354580717b0.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　由于我们给 parameters 参数加上了 FromQuery 的特性，所以程序就不懵了</p> \n<p>&nbsp;</p> \n<p>　　下面给大家说下&nbsp;FromBody FromForm FromQuery FromHeader FromRoute 的区别</p> \n<p>　　FromBody：当请求的&nbsp;content-type 为&nbsp;application/json 时，可以不加上这个特性，因为当入参类型为实体类时，系统默认从请求体（body）中获取数据，在这里建议大家加上；</p> \n<p>　　FromForm：当请求属于表单提交，也就是&nbsp;content-type 为&nbsp;application/x-www-form-urlencoded，则必须给参数加上&nbsp;FromForm 特性，否者会报 400 错误；</p> \n<p>　　FromQuery：获取地址烂参数，当接口参数是一个实体类时，建议必须加上该特性；</p> \n<p>　　FromHeader：获取请求头参数；</p> \n<p>　　FromRoute：获取路由参数，这个可能有些小伙伴会很疑惑，我贴出个代码大家就懂了：</p> \n<div class=\"cnblogs_code\"> \n <pre>[HttpPost(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">{id}</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">)]\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span> Post([FromRoute]<span style=\"color: rgba(0, 0, 255, 1)\">string</span><span style=\"color: rgba(0, 0, 0, 1)\"> id, [FromQuery]Parameters parameters, Info info)\n{\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(128, 0, 128, 1)\">200</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n}</span></pre> \n</div> \n<p>&nbsp;　　好了，本文到此结束，感谢大佬们的观看，谢谢！</p> \n<p>原文链接：<a class=\"ng-star-inserted\" href=\"https://www.cnblogs.com/ysmc/p/16758995.html\" rel=\"noopener\" target=\"_blank\">https://www.cnblogs.com/ysmc/p/16758995.html</a></p>',100,NULL,0,'https://www.cnblogs.com/ysmc/p/16758995.html','2022-10-07 06:30:21'),(24,'[CG从零开始] 6. 加载一个柴犬模型学习UV贴图',NULL,NULL,0,0,'<p>在第 5 篇文章中，我们成功加载了 fbx 模型，并且做了 MVP 变换，将立方体按照透视投影渲染了出来。但是当时只是随机给顶点颜色，并且默认 fbx 文件里只有一个 mesh，这次我们来加载一个柴犬模型，并且给模型贴图，模型可以从 <a href=\"https://sketchfab.com/3d-models/shiba-faef9fe5ace445e7b2989d1c1ece361c\" target=\"_blank\" rel=\"noopener\">sketchfab 下载</a>。</p> \n<p>本文没有涉及到理论解释，更多的是代码实践。</p> \n<blockquote> \n <p>完整代码在 <a href=\"https://github.com/MangoWAY/CGLearner/tree/v0.3\" target=\"_blank\" rel=\"noopener\">https://github.com/MangoWAY/CGLearner/tree/v0.3</a> tag v0.3</p> \n</blockquote> \n<h2 id=\"1-创建纹理加载图片\">1. 创建纹理，加载图片</h2> \n<p>我们来封装一个 Texture 类用来加载图片，创建、bind 纹理，加载图片我用的是 pillow 库。</p> \n<pre><code class=\"language-py\">from OpenGL import GL as gl\nfrom PIL import Image\nimport numpy as np\nclass Texture:\n    COUNT = 0\n    def __init__(self) -&gt; None:\n        self.texid = -1\n        self.count = -1\n\n    def create(self):\n        self.texid = gl.glGenTextures(1)\n        \n    def load_from_path(self, path: str):\n        gl.glActiveTexture(gl.GL_TEXTURE0 + Texture.COUNT)\n        self.count = Texture.COUNT\n        Texture.COUNT +=1\n        gl.glBindTexture(gl.GL_TEXTURE_2D, self.texid)\n        # Set the texture wrapping parameters\n        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_S, gl.GL_REPEAT)\n        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_WRAP_T, gl.GL_REPEAT)\n        # Set texture filtering parameters\n        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MIN_FILTER, gl.GL_LINEAR)\n        gl.glTexParameteri(gl.GL_TEXTURE_2D, gl.GL_TEXTURE_MAG_FILTER, gl.GL_LINEAR)\n        # load image\n        image = Image.open(path)\n        img_data = np.array(list(image.getdata()), np.uint8)\n        gl.glTexImage2D(gl.GL_TEXTURE_2D, \n                        0, \n                        gl.GL_RGB, \n                        image.width, \n                        image.height, \n                        0, \n                        gl.GL_RGB, \n                        gl.GL_UNSIGNED_BYTE, \n                        img_data)\n        gl.glGenerateMipmap(gl.GL_TEXTURE_2D)\n\n    def bind(self):\n        gl.glActiveTexture(gl.GL_TEXTURE0 + self.count)\n        gl.glBindTexture(gl.GL_TEXTURE_2D, self.texid)\n</code></pre> \n<h2 id=\"2-uv-采样\">2. UV 采样</h2> \n<p>在之前的文章中，我们基本只用到了顶点的位置信息，这次我们需要用到顶点的 uv 坐标，我们根据 uv 坐标对纹理进行采样，获取当前的颜色。如下，在之前封装的模型加载类里，用 pyassimp 获取 uv 坐标。</p> \n<pre><code class=\"language-py\"># model_importer.py\n...\n    def load_mesh(self, path: str):\n        scene = pyassimp.load(path)\n        mmeshes = []\n        for mesh in scene.meshes:\n            ...\n            # 获取 uv 坐标\n            mmesh.uvs = mesh.texturecoords.squeeze(0)\n            ...\n        return mmeshes\n...\n</code></pre> \n<p>有了 uv 以后，我们需要将它放到我们的顶点数组里，然后正确设置长度、偏移等等，和位置、法线等数据类似。有一点需要注意一下，图片的坐标系原点一般在左上，而 uv 坐标的原点在左下，因此需要 y 方向需要翻转一下。vert 如下，我们新加一个 uv 的顶点属性，然后将它传递到 frag shader 中。在 frag 中翻转一下 y，然后采样纹理。</p> \n<pre><code class=\"language-glsl\">// vert\n#version 330 core\n...\nlayout(location = 3) in vec2 aUV;\nout vec3 c;\nout vec2 uv;\nuniform mat4 u_mvp;\nvoid main(){\n    gl_Position = u_mvp * vec4(aPos,1.0);\n    c = aColor;\n    uv = aUV;\n}\n// frag\n#version 330 core\nout vec4 color;\nin vec3 c;\nin vec2 uv;\nuniform sampler2D ourTexture;\nvoid main(){\n    ...\n    vec2 uv1 = vec2(uv.x,1.0-uv.y);\n    color = texture(ourTexture, uv1);\n}\n\n</code></pre> \n<h2 id=\"3-绘制多个网格\">3. 绘制多个网格</h2> \n<p>这个柴犬模型里有 3 个网格，我们需要绘制 3 个网格，因此我们需要修改一下之前主函数的逻辑，之前是默认加载的第一个网格，现在需要加载每一个网格，然后创建 VAO、VBO、EBO 等渲染数据，然后加载纹理资源，最后在渲染循环中依次渲染。</p> \n<pre><code class=\"language-py\"># main.py\n...\nverts = []\nindes = []\nrenderData = []\nfor mesh in meshes:\n    vert = []\n    for i in range(len(mesh.vertices)):\n        if i % 3 == 0:\n            vert.extend([mesh.vertices[i],mesh.vertices[i + 1],mesh.vertices[i + 2]])\n            vert.extend([mesh.normals[i],mesh.normals[i + 1],mesh.normals[i + 2]])\n            vert.extend([random.random(),random.random(),random.random()])\n            vert.extend([mesh.uvs[int(i/3),0],mesh.uvs[int(i/3),1]])\n    verts.append(vert)\n    inde = mesh.subMeshes[0].indices\n    indes.append(inde)\n    data = RendererData()\n    data.build_data([desp,desp1,desp2,desp3],vert, inde)\n    renderData.append(data)\n...\ntex = Texture()\ntex.create()\ntex.load_from_path(\"default_Base_Color.png\")\ntex.bind()\n\nwhile (...):\n       ...\n        for data in renderData:\n            data.use()\n            data.draw()\n            data.unuse()\n       ...\n\n</code></pre> \n<p>我们可以调一调之前定义的 Transform 的位置、角度，或者相机的角度等，渲染的结果如下：</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/4c6cf7b9-01be-436d-a772-46c60a81b2e1.png\" alt=\"柴犬模型\" loading=\"lazy\"></p> \n<h2 id=\"4-总结\">4. 总结</h2> \n<ul> \n <li>加载 uv 坐标传递到 shader 中；</li> \n <li>利用 pyopengl 加载纹理贴图；</li> \n <li>渲染多个网格数据；</li> \n</ul>',100,NULL,0,'https://www.cnblogs.com/WAoyu/p/16758981.html','2022-10-07 06:30:22'),(25,'Redis实现布隆过滤器解析',NULL,NULL,0,0,'<h2>布隆过滤器原理介绍</h2> \n<p><span style=\"font-size: 18px\">　　【1】概念说明</span></p> \n<p><span style=\"font-size: 18px\">　　　　1）布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都远远超过一般的算法，缺点是有一定的误识别率和删除困难。</span></p> \n<p><span style=\"font-size: 18px\">　　【2】设计思想</span></p> \n<p><span style=\"font-size: 18px\">　　　　1）BF是由一个长度为m比特的位数组（bit array）与k个哈希函数（hash function）组成的数据结构。位数组均初始化为0，所有哈希函数都可以分别把输入数据尽量均匀地散列。</span></p> \n<p><span style=\"font-size: 18px\">　　　　2）当要插入一个元素时，将其数据分别输入k个哈希函数，产生k个哈希值。以哈希值作为位数组中的下标，将所有k个对应的比特置为1。</span></p> \n<p><span style=\"font-size: 18px\">　　　　3）当要查询（即判断是否存在）一个元素时，同样将其数据输入哈希函数，然后检查对应的k个比特。如果有任意一个比特为0，表明该元素一定不在集合中。如果所有比特均为1，表明该集合有（较大的）可能性在集合中。为什么不是一定在集合中呢？因为一个比特被置为1有可能会受到其他元素的影响，这就是所谓“假阳性”（false positive）。相对地，“假阴性”（false negative）在BF中是绝不会出现的。</span></p> \n<p><span style=\"font-size: 18px\">　　【3】图示</span></p> \n<p><span style=\"font-size: 18px\">&nbsp;&nbsp;　　　　　　　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/02ae7c3f-f9f0-44b2-b8a3-a169fcc7a8c3.png\" alt=\"\" loading=\"lazy\"></span></p> \n<p><span style=\"font-size: 18px\">　　【4】优缺点</span></p> \n<p><span style=\"font-size: 18px\">　　　　1）优点</span></p> \n<p><span style=\"font-size: 18px\">　　　　　　1.不需要存储数据本身，只用比特表示，因此空间占用相对于传统方式有巨大的优势，并且能够保密数据；</span></p> \n<p><span style=\"font-size: 18px\">　　　　　　2.时间效率也较高，插入和查询的时间复杂度均为O(k)；</span></p> \n<p><span style=\"font-size: 18px\">　　　　　　3.哈希函数之间相互独立，可以在硬件指令层面并行计算。</span></p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　　　2）缺点</span></p> \n<p><span style=\"font-size: 18px\">　　　　　　1.存在假阳性的概率，不适用于任何要求100%准确率的情境；</span></p> \n<p><span style=\"font-size: 18px\">　　　　　　2.只能插入和查询元素，不能删除元素，这与产生假阳性的原因是相同的。我们可以简单地想到通过计数（即将一个比特扩展为计数值）来记录元素数，但仍然无法保证删除的元素一定在集合中。（因此<span style=\"color: rgba(255, 0, 0, 1)\">只能进行重建</span>）</span></p> \n<p>&nbsp;</p> \n<h2>guava框架如何实现布隆过滤器</h2> \n<p><span style=\"font-size: 18px\">　　【1】引入依赖</span></p> \n<div class=\"cnblogs_code\"> \n <pre>&lt;dependency&gt;\n   &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n   &lt;artifactId&gt;guava&lt;/artifactId&gt;\n   &lt;version&gt;28.0-jre&lt;/version&gt;\n&lt;/dependency&gt;</pre> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　【2】简单使用</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">布隆过滤器-数字指纹存储在当前jvm当中</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span><span style=\"color: rgba(0, 0, 0, 1)\"> LocalBloomFilter {\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span> <span style=\"color: rgba(0, 0, 255, 1)\">static</span> <span style=\"color: rgba(0, 0, 255, 1)\">final</span> BloomFilter&lt;String&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(StandardCharsets.UTF_8),1000000,0.01<span style=\"color: rgba(0, 0, 0, 1)\">);\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">/**</span><span style=\"color: rgba(0, 128, 0, 1)\">\n     * 谷歌guava布隆过滤器\n     * </span><span style=\"color: rgba(128, 128, 128, 1)\">@param</span><span style=\"color: rgba(0, 128, 0, 1)\"> id\n     * </span><span style=\"color: rgba(128, 128, 128, 1)\">@return</span>\n     <span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">static</span> <span style=\"color: rgba(0, 0, 255, 1)\">boolean</span><span style=\"color: rgba(0, 0, 0, 1)\"> match(String id){\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> bloomFilter.mightContain(id);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">static</span> <span style=\"color: rgba(0, 0, 255, 1)\">void</span><span style=\"color: rgba(0, 0, 0, 1)\"> put(Long id){\n        bloomFilter.put(id</span>+\"\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n    }\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　【3】源码分析（由上面的三个主要方法看起，create方法，mightContain方法，put方法）</span></p> \n<p><span style=\"font-size: 18px\">　　　　1）create方法深入分析</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 0, 1)\">@VisibleForTesting\n</span><span style=\"color: rgba(0, 0, 255, 1)\">static</span> &lt;T&gt; BloomFilter&lt;T&gt; create(Funnel&lt;? <span style=\"color: rgba(0, 0, 255, 1)\">super</span> T&gt; funnel, <span style=\"color: rgba(0, 0, 255, 1)\">long</span> expectedInsertions, <span style=\"color: rgba(0, 0, 255, 1)\">double</span><span style=\"color: rgba(0, 0, 0, 1)\"> fpp, Strategy strategy) {\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">检测序列化器</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">    checkNotNull(funnel);\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">检测存储容量</span>\n    checkArgument(expectedInsertions &gt;= 0, \"Expected insertions (%s) must be &gt;= 0\"<span style=\"color: rgba(0, 0, 0, 1)\">, expectedInsertions);\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">容错率应该在0-1之前</span>\n    checkArgument(fpp &gt; 0.0, \"False positive probability (%s) must be &gt; 0.0\"<span style=\"color: rgba(0, 0, 0, 1)\">, fpp);\n    checkArgument(fpp </span>&lt; 1.0, \"False positive probability (%s) must be &lt; 1.0\"<span style=\"color: rgba(0, 0, 0, 1)\">, fpp);\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">检测策略</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">    checkNotNull(strategy);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (expectedInsertions == 0<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      expectedInsertions </span>= 1<span style=\"color: rgba(0, 0, 0, 1)\">;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 这里numBits即底下LockFreeBitArray位数组的长度，可以看到计算方式就是外部传入的期待数和容错率</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">long</span> numBits =<span style=\"color: rgba(0, 0, 0, 1)\"> optimalNumOfBits(expectedInsertions, fpp);\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> numHashFunctions =<span style=\"color: rgba(0, 0, 0, 1)\"> optimalNumOfHashFunctions(expectedInsertions, numBits);\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">try</span><span style=\"color: rgba(0, 0, 0, 1)\"> {\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">new</span> BloomFilter&lt;T&gt;(<span style=\"color: rgba(0, 0, 255, 1)\">new</span><span style=\"color: rgba(0, 0, 0, 1)\"> BitArray(numBits), numHashFunctions, funnel, strategy);\n    } </span><span style=\"color: rgba(0, 0, 255, 1)\">catch</span><span style=\"color: rgba(0, 0, 0, 1)\"> (IllegalArgumentException e) {\n      </span><span style=\"color: rgba(0, 0, 255, 1)\">throw</span> <span style=\"color: rgba(0, 0, 255, 1)\">new</span> IllegalArgumentException(\"Could not create BloomFilter of \" + numBits + \" bits\"<span style=\"color: rgba(0, 0, 0, 1)\">, e);\n    }\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1)\">private</span> BloomFilter(BitArray bits, <span style=\"color: rgba(0, 0, 255, 1)\">int</span> numHashFunctions, Funnel&lt;? <span style=\"color: rgba(0, 0, 255, 1)\">super</span> T&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> funnel, Strategy strategy) {\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">检测hash函数个数应该在0-255之间</span>\n    checkArgument(numHashFunctions &gt; 0, \"numHashFunctions (%s) must be &gt; 0\"<span style=\"color: rgba(0, 0, 0, 1)\">, numHashFunctions);\n    checkArgument(numHashFunctions </span>&lt;= 255, \"numHashFunctions (%s) must be &lt;= 255\"<span style=\"color: rgba(0, 0, 0, 1)\">, numHashFunctions);\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">this</span>.bits =<span style=\"color: rgba(0, 0, 0, 1)\"> checkNotNull(bits);\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">this</span>.numHashFunctions =<span style=\"color: rgba(0, 0, 0, 1)\"> numHashFunctions;\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">this</span>.funnel =<span style=\"color: rgba(0, 0, 0, 1)\"> checkNotNull(funnel);\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">this</span>.strategy =<span style=\"color: rgba(0, 0, 0, 1)\"> checkNotNull(strategy);\n}\n\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">计算容量大小</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">@VisibleForTesting\n</span><span style=\"color: rgba(0, 0, 255, 1)\">static</span> <span style=\"color: rgba(0, 0, 255, 1)\">long</span> optimalNumOfBits(<span style=\"color: rgba(0, 0, 255, 1)\">long</span> n, <span style=\"color: rgba(0, 0, 255, 1)\">double</span><span style=\"color: rgba(0, 0, 0, 1)\"> p) {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (p == 0<span style=\"color: rgba(0, 0, 0, 1)\">) {\n      p </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> Double.MIN_VALUE;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> (<span style=\"color: rgba(0, 0, 255, 1)\">long</span>) (-n * Math.log(p) / (Math.log(2) * Math.log(2<span style=\"color: rgba(0, 0, 0, 1)\">)));\n}\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">计算满足条件时，应进行多少次hash函数</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">@VisibleForTesting\n</span><span style=\"color: rgba(0, 0, 255, 1)\">static</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span> optimalNumOfHashFunctions(<span style=\"color: rgba(0, 0, 255, 1)\">long</span> n, <span style=\"color: rgba(0, 0, 255, 1)\">long</span><span style=\"color: rgba(0, 0, 0, 1)\"> m) {\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> (m / n) * log(2), but avoid truncation due to division!</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">return</span> Math.max(1, (<span style=\"color: rgba(0, 0, 255, 1)\">int</span>) Math.round((<span style=\"color: rgba(0, 0, 255, 1)\">double</span>) m / n * Math.log(2<span style=\"color: rgba(0, 0, 0, 1)\">)));\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　　　2）mightContain方法深入分析</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">boolean</span><span style=\"color: rgba(0, 0, 0, 1)\"> mightContain(T object) {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> strategy.mightContain(object, funnel, numHashFunctions, bits);\n}\n\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> &lt;T&gt; <span style=\"color: rgba(0, 0, 255, 1)\">boolean</span> mightContain(T object, Funnel&lt;? <span style=\"color: rgba(0, 0, 255, 1)\">super</span> T&gt; funnel, <span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\"> numHashFunctions, BloomFilterStrategies.BitArray bits) {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">long</span> bitSize =<span style=\"color: rgba(0, 0, 0, 1)\"> bits.bitSize();\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">long</span> hash64 =<span style=\"color: rgba(0, 0, 0, 1)\"> Hashing.murmur3_128().hashObject(object, funnel).asLong();\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> hash1 = (<span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\">)hash64;\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> hash2 = (<span style=\"color: rgba(0, 0, 255, 1)\">int</span>)(hash64 &gt;&gt;&gt; 32<span style=\"color: rgba(0, 0, 0, 1)\">);\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">for</span>(<span style=\"color: rgba(0, 0, 255, 1)\">int</span> i = 1; i &lt;= numHashFunctions; ++<span style=\"color: rgba(0, 0, 0, 1)\">i) {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> combinedHash = hash1 + i *<span style=\"color: rgba(0, 0, 0, 1)\"> hash2;\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (combinedHash &lt; 0<span style=\"color: rgba(0, 0, 0, 1)\">) {\n            combinedHash </span>= ~<span style=\"color: rgba(0, 0, 0, 1)\">combinedHash;\n        }\n\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!bits.get((<span style=\"color: rgba(0, 0, 255, 1)\">long</span>)combinedHash %<span style=\"color: rgba(0, 0, 0, 1)\"> bitSize)) {\n            </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　　　3）put方法深入分析</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 0, 1)\">@CanIgnoreReturnValue\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">boolean</span><span style=\"color: rgba(0, 0, 0, 1)\"> put(T object) {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> strategy.put(object, funnel, numHashFunctions, bits);\n}\n\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">策略实现填入bits</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">public</span> &lt;T&gt; <span style=\"color: rgba(0, 0, 255, 1)\">boolean</span> put(T object, Funnel&lt;? <span style=\"color: rgba(0, 0, 255, 1)\">super</span> T&gt; funnel, <span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\"> numHashFunctions, BloomFilterStrategies.BitArray bits) {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">long</span> bitSize =<span style=\"color: rgba(0, 0, 0, 1)\"> bits.bitSize();\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">long</span> hash64 =<span style=\"color: rgba(0, 0, 0, 1)\"> Hashing.murmur3_128().hashObject(object, funnel).asLong();\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> hash1 = (<span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\">)hash64;\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> hash2 = (<span style=\"color: rgba(0, 0, 255, 1)\">int</span>)(hash64 &gt;&gt;&gt; 32<span style=\"color: rgba(0, 0, 0, 1)\">);\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">boolean</span> bitsChanged = <span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">for</span>(<span style=\"color: rgba(0, 0, 255, 1)\">int</span> i = 1; i &lt;= numHashFunctions; ++<span style=\"color: rgba(0, 0, 0, 1)\">i) {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> combinedHash = hash1 + i *<span style=\"color: rgba(0, 0, 0, 1)\"> hash2;\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (combinedHash &lt; 0<span style=\"color: rgba(0, 0, 0, 1)\">) {\n            combinedHash </span>= ~<span style=\"color: rgba(0, 0, 0, 1)\">combinedHash;\n        }\n\n        bitsChanged </span>|= bits.set((<span style=\"color: rgba(0, 0, 255, 1)\">long</span>)combinedHash %<span style=\"color: rgba(0, 0, 0, 1)\"> bitSize);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> bitsChanged;\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<h2>采用Redis实现布隆过滤器</h2> \n<p><span style=\"font-size: 18px\">　　【1】抽出guava框架中部分核心逻辑方法形成工具类</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">/**</span><span style=\"color: rgba(0, 128, 0, 1)\">\n * 算法过程：\n * 1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数\n * 2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0\n * 3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1\n * 4. 判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。\n * @description: 布隆过滤器，摘录自Google-guava包\n *</span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span> BloomFilterHelper&lt;T&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\"> numHashFunctions;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\"> bitSize;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span> Funnel&lt;T&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> funnel;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> BloomFilterHelper(Funnel&lt;T&gt; funnel, <span style=\"color: rgba(0, 0, 255, 1)\">int</span> expectedInsertions, <span style=\"color: rgba(0, 0, 255, 1)\">double</span><span style=\"color: rgba(0, 0, 0, 1)\"> fpp) {\n        Preconditions.checkArgument(funnel </span>!= <span style=\"color: rgba(0, 0, 255, 1)\">null</span>, \"funnel不能为空\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">this</span>.funnel =<span style=\"color: rgba(0, 0, 0, 1)\"> funnel;\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 计算bit数组长度</span>\n        bitSize =<span style=\"color: rgba(0, 0, 0, 1)\"> optimalNumOfBits(expectedInsertions, fpp);\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 计算hash方法执行次数</span>\n        numHashFunctions =<span style=\"color: rgba(0, 0, 0, 1)\"> optimalNumOfHashFunctions(expectedInsertions, bitSize);\n    }\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\">[] murmurHashOffset(T value) {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span>[] offset = <span style=\"color: rgba(0, 0, 255, 1)\">new</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\">[numHashFunctions];\n\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">有点类似于hashmap中采用高32位与低32位相与获得hash值</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">long</span> hash64 =<span style=\"color: rgba(0, 0, 0, 1)\"> Hashing.murmur3_128().hashObject(value, funnel).asLong();\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> hash1 = (<span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\">) hash64;\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> hash2 = (<span style=\"color: rgba(0, 0, 255, 1)\">int</span>) (hash64 &gt;&gt;&gt; 32<span style=\"color: rgba(0, 0, 0, 1)\">);\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">采用对低32进行变更以达到随机哈希函数的效果</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">for</span> (<span style=\"color: rgba(0, 0, 255, 1)\">int</span> i = 1; i &lt;= numHashFunctions; i++<span style=\"color: rgba(0, 0, 0, 1)\">) {\n            </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> nextHash = hash1 + i *<span style=\"color: rgba(0, 0, 0, 1)\"> hash2;\n            </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (nextHash &lt; 0<span style=\"color: rgba(0, 0, 0, 1)\">) {\n                nextHash </span>= ~<span style=\"color: rgba(0, 0, 0, 1)\">nextHash;\n            }\n            offset[i </span>- 1] = nextHash %<span style=\"color: rgba(0, 0, 0, 1)\"> bitSize;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> offset;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">/**</span><span style=\"color: rgba(0, 128, 0, 1)\">\n     * 计算bit数组长度\n     * Math.log(2) = 0.6931471805599453;（取0.693147来用）\n     * (Math.log(2) * Math.log(2)) = 0.48045237;\n     * 假设传入n为1,000,000  , p为0.01;\n     * Math.log(0.01) = -4.605170185988091;\n     * 则返回值为9,585,071 ,即差不多是预设容量的10倍\n     * \n     * 要知道 1MB = 1024KB , 1KB = 1024B ,1B=8bit。\n     * 也就是对一百万数据预计花费的内存为1.143MB的内存\n     </span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">private</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span> optimalNumOfBits(<span style=\"color: rgba(0, 0, 255, 1)\">long</span> n, <span style=\"color: rgba(0, 0, 255, 1)\">double</span><span style=\"color: rgba(0, 0, 0, 1)\"> p) {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (p == 0<span style=\"color: rgba(0, 0, 0, 1)\">) {\n            </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 设定最小期望长度</span>\n            p =<span style=\"color: rgba(0, 0, 0, 1)\"> Double.MIN_VALUE;\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> (<span style=\"color: rgba(0, 0, 255, 1)\">int</span>) (-n * Math.log(p) / (Math.log(2) * Math.log(2<span style=\"color: rgba(0, 0, 0, 1)\">)));\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">/**</span><span style=\"color: rgba(0, 128, 0, 1)\">\n     * 计算hash方法执行次数\n     </span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">private</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span> optimalNumOfHashFunctions(<span style=\"color: rgba(0, 0, 255, 1)\">long</span> n, <span style=\"color: rgba(0, 0, 255, 1)\">long</span><span style=\"color: rgba(0, 0, 0, 1)\"> m) {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> Math.max(1, (<span style=\"color: rgba(0, 0, 255, 1)\">int</span>) Math.round((<span style=\"color: rgba(0, 0, 255, 1)\">double</span>) m / n * Math.log(2<span style=\"color: rgba(0, 0, 0, 1)\">)));\n    }\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　【2】构建Redis实现布隆过滤器的服务类</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span><span style=\"color: rgba(0, 0, 0, 1)\"> BloomRedisService {\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span> RedisTemplate&lt;String, Object&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> redisTemplate;\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span><span style=\"color: rgba(0, 0, 0, 1)\"> BloomFilterHelper bloomFilterHelper;\n\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">void</span><span style=\"color: rgba(0, 0, 0, 1)\"> setBloomFilterHelper(BloomFilterHelper bloomFilterHelper) {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">this</span>.bloomFilterHelper =<span style=\"color: rgba(0, 0, 0, 1)\"> bloomFilterHelper;\n    }\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">void</span> setRedisTemplate(RedisTemplate&lt;String, Object&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> redisTemplate) {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">this</span>.redisTemplate =<span style=\"color: rgba(0, 0, 0, 1)\"> redisTemplate;\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">/**</span><span style=\"color: rgba(0, 128, 0, 1)\">\n     * 根据给定的布隆过滤器添加值\n     * 这里可以考虑LUA脚本进行优化，减少传输次数\n     * 如 eval \"redis.call(\'setbit\',KEYS[1],ARGV[1],1) redis.call(\'setbit\',KEYS[1],ARGV[2],1) \" 1 mybool  243 5143 \n     * 但是又需要衡量操作的时间，与如果次数很多导致的传输的数据量很大容易阻塞问题\n     </span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">public</span> &lt;T&gt; <span style=\"color: rgba(0, 0, 255, 1)\">void</span><span style=\"color: rgba(0, 0, 0, 1)\"> addByBloomFilter(String key, T value) {\n        Preconditions.checkArgument(bloomFilterHelper </span>!= <span style=\"color: rgba(0, 0, 255, 1)\">null</span>, \"bloomFilterHelper不能为空\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span>[] offset =<span style=\"color: rgba(0, 0, 0, 1)\"> bloomFilterHelper.murmurHashOffset(value);\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">for</span> (<span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\"> i : offset) {\n            redisTemplate.opsForValue().setBit(key, i, </span><span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n        }\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">/**</span><span style=\"color: rgba(0, 128, 0, 1)\">\n     * 根据给定的布隆过滤器判断值是否存在\n     </span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">public</span> &lt;T&gt; <span style=\"color: rgba(0, 0, 255, 1)\">boolean</span><span style=\"color: rgba(0, 0, 0, 1)\"> includeByBloomFilter(String key, T value) {\n        Preconditions.checkArgument(bloomFilterHelper </span>!= <span style=\"color: rgba(0, 0, 255, 1)\">null</span>, \"bloomFilterHelper不能为空\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span>[] offset =<span style=\"color: rgba(0, 0, 0, 1)\"> bloomFilterHelper.murmurHashOffset(value);\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">for</span> (<span style=\"color: rgba(0, 0, 255, 1)\">int</span><span style=\"color: rgba(0, 0, 0, 1)\"> i : offset) {\n            </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span> (!<span style=\"color: rgba(0, 0, 0, 1)\">redisTemplate.opsForValue().getBit(key, i)) {\n                </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n            }\n        }\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n    }\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　【3】编辑配置类</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 0, 1)\">@Slf4j\n@Configuration\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span> BloomFilterConfig <span style=\"color: rgba(0, 0, 255, 1)\">implements</span><span style=\"color: rgba(0, 0, 0, 1)\"> InitializingBean{\n\n    @Autowired\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span><span style=\"color: rgba(0, 0, 0, 1)\"> PmsProductService productService;\n\n    @Autowired\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span><span style=\"color: rgba(0, 0, 0, 1)\"> RedisTemplate template;\n\n    @Bean\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> BloomFilterHelper&lt;String&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> initBloomFilterHelper() {\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">new</span> BloomFilterHelper&lt;&gt;((Funnel&lt;String&gt;) (from, into) -&gt;<span style=\"color: rgba(0, 0, 0, 1)\"> into.putString(from, Charsets.UTF_8)\n                .putString(from, Charsets.UTF_8), </span>1000000, 0.01<span style=\"color: rgba(0, 0, 0, 1)\">);\n    }\n\n    </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\"> 布隆过滤器bean注入</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">    @Bean\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span><span style=\"color: rgba(0, 0, 0, 1)\"> BloomRedisService bloomRedisService(){\n        BloomRedisService bloomRedisService </span>= <span style=\"color: rgba(0, 0, 255, 1)\">new</span><span style=\"color: rgba(0, 0, 0, 1)\"> BloomRedisService();\n        bloomRedisService.setBloomFilterHelper(initBloomFilterHelper());\n        bloomRedisService.setRedisTemplate(template);\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span><span style=\"color: rgba(0, 0, 0, 1)\"> bloomRedisService;\n    }\n\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">void</span> afterPropertiesSet() <span style=\"color: rgba(0, 0, 255, 1)\">throws</span><span style=\"color: rgba(0, 0, 0, 1)\"> Exception {\n        List</span>&lt;Long&gt; list =<span style=\"color: rgba(0, 0, 0, 1)\"> productService.getAllProductId();\n        log.info(</span>\"加载产品到布隆过滤器当中,size:{}\"<span style=\"color: rgba(0, 0, 0, 1)\">,list.size());\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">if</span>(!<span style=\"color: rgba(0, 0, 0, 1)\">CollectionUtils.isEmpty(list)){\n            list.stream().forEach(item</span>-&gt;<span style=\"color: rgba(0, 0, 0, 1)\">{\n                </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">LocalBloomFilter.put(item);</span>\n                bloomRedisService().addByBloomFilter(RedisKeyPrefixConst.PRODUCT_REDIS_BLOOM_FILTER,item+\"\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n            });\n        }\n    }\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　【4】构建布隆过滤器的拦截器</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">拦截器，所有需要查看商品详情的请求必须先过布隆过滤器</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">@Slf4j\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span> BloomFilterInterceptor <span style=\"color: rgba(0, 0, 255, 1)\">implements</span><span style=\"color: rgba(0, 0, 0, 1)\"> HandlerInterceptor {\n\n    @Autowired\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">private</span><span style=\"color: rgba(0, 0, 0, 1)\"> BloomRedisService bloomRedisService;\n\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">boolean</span> preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) <span style=\"color: rgba(0, 0, 255, 1)\">throws</span><span style=\"color: rgba(0, 0, 0, 1)\"> Exception {\n        String currentUrl </span>=<span style=\"color: rgba(0, 0, 0, 1)\"> request.getRequestURI();\n        PathMatcher matcher </span>= <span style=\"color: rgba(0, 0, 255, 1)\">new</span><span style=\"color: rgba(0, 0, 0, 1)\"> AntPathMatcher();\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">解析出pathvariable</span>\n        Map&lt;String, String&gt; pathVariable = matcher.extractUriTemplateVariables(\"/pms/productInfo/{id}\"<span style=\"color: rgba(0, 0, 0, 1)\">, currentUrl);\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">布隆过滤器存储在redis中</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">if</span>(bloomRedisService.includeByBloomFilter(RedisKeyPrefixConst.PRODUCT_REDIS_BLOOM_FILTER,pathVariable.get(\"id\"<span style=\"color: rgba(0, 0, 0, 1)\">))){\n            </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">true</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n        }\n\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">/*</span><span style=\"color: rgba(0, 128, 0, 1)\">\n         * 不在布隆过滤器当中，直接返回验证失败\n         * 设置响应头\n         </span><span style=\"color: rgba(0, 128, 0, 1)\">*/</span><span style=\"color: rgba(0, 0, 0, 1)\">\n        response.setHeader(</span>\"Content-Type\",\"application/json\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n        response.setCharacterEncoding(</span>\"UTF-8\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n        String result </span>= <span style=\"color: rgba(0, 0, 255, 1)\">new</span> ObjectMapper().writeValueAsString(CommonResult.validateFailed(\"产品不存在!\"<span style=\"color: rgba(0, 0, 0, 1)\">));\n        response.getWriter().print(result);\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">false</span><span style=\"color: rgba(0, 0, 0, 1)\">;\n    }\n\n}</span></pre> \n</div> \n<p>&nbsp;</p> \n<p><span style=\"font-size: 18px\">　　【5】将拦截器注册进SpringMVC中</span></p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 0, 1)\">@Configuration\n</span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span> IntercepterConfiguration <span style=\"color: rgba(0, 0, 255, 1)\">implements</span><span style=\"color: rgba(0, 0, 0, 1)\"> WebMvcConfigurer {\n\n    @Override\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">void</span><span style=\"color: rgba(0, 0, 0, 1)\"> addInterceptors(InterceptorRegistry registry) {\n        </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">注册拦截器</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">        registry.addInterceptor(authInterceptorHandler())\n                .addPathPatterns(</span>\"/pms/productInfo/**\"<span style=\"color: rgba(0, 0, 0, 1)\">);\n    }\n\n    @Bean\n    </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span><span style=\"color: rgba(0, 0, 0, 1)\"> BloomFilterInterceptor authInterceptorHandler(){\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">return</span> <span style=\"color: rgba(0, 0, 255, 1)\">new</span><span style=\"color: rgba(0, 0, 0, 1)\"> BloomFilterInterceptor();\n    }\n}</span></pre> \n</div> \n<p>&nbsp;</p>',100,NULL,0,'https://www.cnblogs.com/chafry/p/16756954.html','2022-10-07 06:30:24'),(26,'数据库基础，看完这篇就够了！',NULL,NULL,0,0,'<p>转载请注明出处️</p> \n<p>作者：<a href=\"https://www.caituotuo.top/\" target=\"_blank\" rel=\"noopener\">测试蔡坨坨</a></p> \n<p>原文链接：<a href=\"https://www.caituotuo.top/747a74ea.html\" target=\"_blank\" rel=\"noopener\">caituotuo.top/747a74ea.html</a></p> \n<hr> \n<p>你好，我是测试蔡坨坨。</p> \n<p>对于测试同学来说，除了知道测试基础知识外，还需要掌握一些测试基本技能，主要有Linux、数据库、计算机网络等，在此之前我们已经讨论过Linux基础知识以及在实际工作中的应用，可参考往期文章「<a href=\"https://www.caituotuo.top/77afc7de.html\" target=\"_blank\" rel=\"noopener\">学会 Linux，看完这篇就行了！</a>」。</p> \n<p>今天，我们就来聊一聊数据库，数据库是大学本科计算机系核心课程之一，其重要性不言而喻。</p> \n<p>数据库在面试中基本属于必考内容，最多的就是手写SQL或口述SQL，面试官会给你出一个场景，比如班级、分数、课程之类的，一般考察表查询语句居多，例如多表查询、连接查询、子查询等。所以，当你准备转行踏入IT行业的时候，就首先需要掌握数据库。</p> \n<p>本文主要科普作为一枚测试应该知道的数据库理论基础知识，知道这些不仅可以在面试时加分，而且可以加深你对数据库的理解，而不是仅仅停留在只会写几个SQL上面。</p> \n<p>测试人员对于数据库理论知识的学习，肯定不需要像开发那么深入，但是一些基本的内容需要知道并掌握，简单来说，数据库基础，看完接下来的文章并搞明白就完全够用了。</p> \n<p>当然，关于数据库进阶知识，比如数据库索引、事务、数据库三大范式、数据库调优、存储过程等内容也会在后续的文章中与大家讨论。</p> \n<p>作为测试，数据库在日常工作中的权重占比还是比较大的，主要有以下几个应用场景：</p> \n<ul> \n <li> <p><strong>项目部署及部署完后数据的准备</strong></p> <p>开发配置好环境，但是没有连接数据库，就需要我们自己新建数据库并连接。</p> <p>已经建好数据库，但是没有创建数据表，就需要我们自己创建数据表。</p> <p>已经创建好数据库和数据表，但是数据表中没有数据，就需要我们自己添加数据。</p> <p>数据表中有数据，但是数据量不够，开发只提供一两条样例数据，测试就需要大量造数据。</p> <p>项目的后台管理没有注册功能，就需要我们自己手动向数据表中插入用户名和密码。</p> </li> \n <li> <p><strong>在前端页面增删改查，查看数据库是否做了相应更新，核对数据存储的准确性</strong></p> <p>举栗1：在CRM项目中，新建客户以后，在数据库的表中查看是否与新建的客户信息一致。</p> <p>举栗2：支付交易产生的订单可以从数据库中查看订单是否真实存储，数据信息是否一致。</p> </li> \n <li> <p><strong>对数据直接操作来满足测试用例所需的极限场景</strong></p> <p>比如有些场景像CRM项目中的新建客户功能，我们只是要验证一个输入框的边界值，但是却需要在前端页面一直新建，一直提交保存，每次新建都需要填写暂时不需要测试的必填项，太麻烦，就可以直接去修改数据表中对应的字段值。</p> </li> \n <li> <p><strong>性能测试或自动化测试通过脚本产生大量数据时，查看数据库是否批量有效存储</strong></p> </li> \n <li> <p><strong>通过操作数据库优化测试用例，提升测试效率</strong></p> </li> \n <li> <p><strong>前端输入框字段报错时，可能是数据库参数类型设置有误或字段长度不够，就可以打开数据库查看字段参数类型和长度是否正确</strong></p> </li> \n <li> <p><strong>性能测试，通过优化SQL语句或表结构来提高系统的性能，例如慢查询等</strong></p> </li> \n <li> <p><strong>造数据场景，构造某些用例的前置条件</strong></p> <p>举栗1：统计年盈利额，需要1~12月都需要数据，不可能一个需求测一年吧，就可以在数据库中直接插入数据。</p> <p>举栗2：手机号注册时，通过改数据库表字段非唯一状态来重复使用一个手机号，进行反复注册。</p> <p>举栗3：通过修改金额、价格等用来做支付测试，比如原本需要100￥，就可以通过修改数据为0.01￥。</p> <p>举栗4：会员积分，就可以在数据库直接修改积分，看是否达到会员。</p> </li> \n <li> <p><strong>理解如何通过接口操作数据库</strong></p> </li> \n <li> <p><strong>做测试结构分析时，可以通过数据库搞清楚数据流向，哪个表放哪个字段什么时候在哪里展示</strong></p> </li> \n</ul> \n<p>and so on ……</p> \n<p>以上，仅列举了一些日常工作中比较常见的场景，供大家参考。</p> \n<p>同时欢迎评论区补充哦~</p> \n<p>紧接着，就来介绍一下数据库以及常用的SQL语句。</p> \n<h3 id=\"认识数据库\">认识数据库</h3> \n<h4 id=\"什么是数据库\">什么是数据库？</h4> \n<p>数据库的英文单词：Database ，简称DB。</p> \n<p>数据库方向的岗位叫DBA（Database Administrat），也就是数据库管理员，专门和数据库打交道的，属于运维工程师的一个分支，主要负责业务数据库从设计、测试到部署交付的全生命周期管理。</p> \n<p>数据库实际上就是一个文件集合，是一个存储数据的仓库，本质就是一个文件系统，数据库是按照特定的格式把数据存储起来，用户可以对存储的数据进行增删改查操作。</p> \n<p>简单概括，数据库就是用于存储和管理数据的仓库。</p> \n<p>具体来说，就是前端页面用户输入的数据通过接口传给后端，然后存储到数据库中，同时也支持从数据库中取数据传给前端页面做一个展示。</p> \n<h4 id=\"数据库的两大分类\">数据库的两大分类</h4> \n<ul> \n <li> <p>关系型数据库：是建立在关系模型基础上的数据库，比如MySQL、Oracle、SQL Server、DB2、PostgreSQL等，还有一些国产的数据库比如达梦数据库、神通数据库、人大金仓数据库等。</p> </li> \n <li> <p>非关系型数据库（NO SQL）：通常指数据之间无关系的数据库，比如MongoDB、Redis，以键值对的方式存储。</p> </li> \n</ul> \n<h4 id=\"新手入门该学习哪个数据库\">新手入门该学习哪个数据库？</h4> \n<p>上面说了这么多数据库，而目前企业中使用最多的就是MySQL和Oracle数据库，后者因为是收费的，所以互联网公司尤其是中小型企业使用最多的就是MySQL数据库，数据库的学习其实和编程语言一样，当你熟练掌握其中一种时，其他的也就分分钟上手了。</p> \n<p>因此，推荐初学者从MySQL数据库开始学习。</p> \n<h4 id=\"mysql简介\">MySQL简介</h4> \n<ul> \n <li>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB公司开发。</li> \n <li>世界上最流行的几款数据库之一。</li> \n <li>优点：是一款轻量级数据库、免费、开源、适用于中大型网站。</li> \n <li>MySQL默认端口号：3306。</li> \n</ul> \n<h4 id=\"数据库服务器数据库和表的关系\">数据库服务器、数据库和表的关系</h4> \n<ul> \n <li> <p>所谓安装数据库服务器，只是在机器上装一个数据库管理系统（比如： MySQL、Oracle、SQL Server），用来管理多个数据库，一般开发人员会针对每一个应用创建一个数据库。</p> </li> \n <li> <p>为保存应用中实体的数据，一般会在数据库创建多个表，以保存程序中实体的数据。</p> <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/ea5ba47e-4c30-45b6-b98e-678ec922ac2c.png\" alt=\"\" loading=\"lazy\"></p> </li> \n</ul> \n<h4 id=\"xshellxftpnavicat\">Xshell、Xftp、Navicat</h4> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/86df3daa-9a13-4b2d-a9bf-b66f52b9b790.png\" alt=\"\" loading=\"lazy\"></p> \n<p>PS：Xshell或Xftp连接Linux服务器默认端口：22</p> \n<h4 id=\"sql介绍\">SQL介绍</h4> \n<p>Structured Query Language：结构化查询语言。</p> \n<p>SQL是专门为数据库而建立的操作命令集，是一种功能齐全的数据库语言。在使用它时，只需要发出“做什么”命令，“怎么做”是不用使用者考虑的。</p> \n<h4 id=\"sql语法特点\">SQL语法特点</h4> \n<ul> \n <li>不区分大小写。</li> \n <li>关键字、字段名、表名需要用空格或逗号隔开。</li> \n <li>每一个SQL语句是用分号结尾。</li> \n <li>语句可以写一行也可以分开写多行。</li> \n</ul> \n<h4 id=\"如何自学数据库\">如何自学数据库</h4> \n<p>在哪里练习？想要练习数据库需要首先需要有数据的环境，有以下两种方法：</p> \n<ol> \n <li> <p>本地安装一个数据库，例如MySQL</p> </li> \n <li> <p>推荐在线练习SQL网站：www.nowcoder.com/ta/sql</p> <p>可以在线练习SQL实战，会根据你的输入实时判断对错，不会的话还可以参考别人写的SQL语句。</p> <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/77869a18-d7d1-47b2-9464-95ea52c39818.png\" alt=\"\" loading=\"lazy\"></p> </li> \n</ol> \n<h3 id=\"数据库常用操作命令\">数据库常用操作命令</h3> \n<h4 id=\"1-mysql登录\">1. MySQL登录</h4> \n<pre><code class=\"language-mysql\">mysql -uroot -p密码\n</code></pre> \n<pre><code class=\"language-mysql\">mysql -uroot -p（回车）\nEnter password: （输入密码）\n</code></pre> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/07/648da29d-4fb0-4bbc-996d-796a24cb7e21.png\"> \n<pre><code class=\"language-mysql\">mysql -hip -P端口 -uroot -p\n</code></pre> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/4814459d-a2e6-457a-bb8b-14973f816e19.png\" alt=\"\" loading=\"lazy\"></p> \n<pre><code class=\"language-mysql\">mysql --host=ip --user=root --password=密码\n</code></pre> \n<h4 id=\"2-mysql退出\">2. MySQL退出</h4> \n<ul> \n <li> <p>exit</p> <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/32a89990-90a3-4b01-8dee-c32ea3d25088.png\" alt=\"\" loading=\"lazy\"></p> </li> \n <li> <p>quit</p> <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/e6f217dd-fe92-4d23-89cd-fad3806518e4.png\" alt=\"\" loading=\"lazy\"></p> </li> \n</ul> \n<h4 id=\"3-创建查看删除使用数据库\">3. 创建、查看、删除、使用数据库</h4> \n<ol> \n <li> <p>创建数据库命令</p> \n  <ul> \n   <li> <p>创建数据库：</p> <p>格式：create database [数据库名称];</p> <p>例如：</p> <pre><code class=\"language-mysql\">create database caituotuo;\n</code></pre> </li> \n   <li> <p>创建数据库，并指定字符集：</p> <p>格式：create database [数据库名称] character set [字符集名];</p> <p>例如：</p> <pre><code class=\"language-mysql\">create database caituotuo character set utf8;\n</code></pre> </li> \n   <li> <p>创建数据库，并指定字符集、排序规则：</p> <p>格式：create database [数据库名称] character set [字符集名] collate [排序规则];</p> <p>例如：</p> <pre><code class=\"language-mysql\">create database caituotuo character set utf8 collate utf8_general_ci;\n</code></pre> </li> \n  </ul> </li> \n <li> <p>查看数据库命令</p> \n  <ul> \n   <li> <p>显示所有数据库：</p> <pre><code class=\"language-mysql\">show databases;\n</code></pre> </li> \n   <li> <p>模糊查询数据库：</p> <pre><code class=\"language-mysql\">show databases like \'%tuotu%\';\n</code></pre> </li> \n   <li> <p>查看查询某个数据库的创建语句、字符集：</p> <p>格式：show create database [数据库名称];</p> <p>例如：</p> <pre><code class=\"language-mysql\">show create database caituotuo;\n</code></pre> </li> \n  </ul> </li> \n <li> <p>删除数据库命令</p> <p>格式：drop database [数据库名称];</p> <p>例如：</p> <pre><code class=\"language-mysql\">drop database caituotuo;\n</code></pre> </li> \n <li> <p>选中某个数据库</p> <p>格式：use [数据库名称];</p> <p>例如：</p> <pre><code class=\"language-mysql\">use caituotuo;\n</code></pre> <p>PS：这个命令可以不加分号。</p> </li> \n</ol> \n<h4 id=\"4-创建查看删除修改数据表\">4. 创建、查看、删除、修改数据表</h4> \n<h5 id=\"数据在数据库中的存储方式\">数据在数据库中的存储方式</h5> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/07/b520ef1b-c1c9-43bb-a57b-6d568631d4e8.png\" alt=\"image-20210115184201422\"> \n<h5 id=\"表中列的数据类型数值型\">表中列的数据类型——数值型</h5> \n<table> \n <thead> \n  <tr> \n   <th>类型</th> \n   <th>大小</th> \n   <th>用途</th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td>TINYINT</td> \n   <td>1字节</td> \n   <td>小整数值</td> \n  </tr> \n  <tr> \n   <td>SMALLINT</td> \n   <td>2字节</td> \n   <td>大整数值</td> \n  </tr> \n  <tr> \n   <td>MEDIUMINT</td> \n   <td>3字节</td> \n   <td>大整数值</td> \n  </tr> \n  <tr> \n   <td>INT或INTEGER</td> \n   <td>4字节</td> \n   <td>大整数值</td> \n  </tr> \n  <tr> \n   <td>BIGINT</td> \n   <td>8字节</td> \n   <td>极大整数值</td> \n  </tr> \n  <tr> \n   <td>FLOAT</td> \n   <td>4字节</td> \n   <td>单精度浮点数值</td> \n  </tr> \n  <tr> \n   <td>DOUBLE</td> \n   <td>8字节</td> \n   <td>双精度浮点数值</td> \n  </tr> \n  <tr> \n   <td>DECIMAL</td> \n   <td>对于DECIMAL(M,D)，如果M&gt;D则为M+2，否则为D+2</td> \n   <td>小数值</td> \n  </tr> \n </tbody> \n</table> \n<h5 id=\"有符号和无符号unsigned\">有符号和无符号（UNSIGNED）</h5> \n<p>在计算机中，可以区分正负的类型，称为有符号类型。</p> \n<p>无正负的类型，称为无符号类型。</p> \n<p>简单的理解为就是，有符号值可以表示负数、0、正数，无符号值只能为0或者正数。</p> \n<h5 id=\"floatdoubledecimal\">FLOAT、DOUBLE、DECIMAL</h5> \n<p>FLOAT(10,2)：总长度为10，小数点后有2位。</p> \n<p>DOUBLE和DECIMAL也类似。</p> \n<p>超出范围会四舍五入。</p> \n<h5 id=\"表中列的数据类型字符型\">表中列的数据类型——字符型</h5> \n<ul> \n <li>CHAR：定长字符串。CHAR(4) -- <code>\' d\'</code></li> \n <li>VARCHAR：变长字符串。VARCHAR(4) -- <code>\'d\'</code></li> \n <li>CHAR的查询效率要高于VARCHAR。</li> \n</ul> \n<h5 id=\"表中列的数据类型日期型\">表中列的数据类型——日期型</h5> \n<table> \n <thead> \n  <tr> \n   <th>类型</th> \n  </tr> \n </thead> \n <tbody> \n  <tr> \n   <td>DATE</td> \n  </tr> \n  <tr> \n   <td>TIME</td> \n  </tr> \n  <tr> \n   <td>YEAR</td> \n  </tr> \n  <tr> \n   <td>DATETIME</td> \n  </tr> \n  <tr> \n   <td>TIMESTAMP</td> \n  </tr> \n </tbody> \n</table> \n<p>TIMESTAMP和DATETIME的异同：</p> \n<ul> \n <li>相同点：两者都可以用来表示YYYY-MM-DD HH:MM:SS类型的日期。</li> \n <li>不同点： \n  <ul> \n   <li>两者的存储方式不一样： \n    <ul> \n     <li>对于TIMESTAMP，它把客户端插入的时间从当前时区转化为UTC（世界标准时间）进行存储。查询时，又将其转化为客户端当前时区进行返回。（PS：中国时区为+8区）</li> \n     <li>而对于DATETIME，不做任何改变，基本上是原样输入和输出。</li> \n    </ul> </li> \n   <li>两者所能存储的时间范围不一样： \n    <ul> \n     <li>TIMESTAMP所能存储的时间范围为：\'1970-01-01 00:00:01.000000\'到\'2038-01-19 03:14:07.999999\'</li> \n     <li>DATETIME所能存储的时间范围为：\'1000-01-01 00:00:00.000000\'到\'9999-12-31 23:59:59.999999\'</li> \n    </ul> </li> \n  </ul> </li> \n</ul> \n<h5 id=\"数据表操作命令\">数据表操作命令</h5> \n<h6 id=\"创建表\">创建表</h6> \n<ol> \n <li> <p>创建表基础命令</p> <pre><code class=\"language-mysql\">-- 格式：\nCREATE TABLE [表名] ([列名 1 ] [列类型],[列名 2 ] [列类型],[列名 3 ] [列类型] );\n-- 例如：\nCREATE TABLE STU (ID INT,NAME VARCHAR ( 20 );AGE INT );\n</code></pre> <p>注意：</p> \n  <ul> \n   <li>创建表前，要先选中某个数据库（use [数据库名称]）；</li> \n   <li>列和列之间用逗号隔开，列内用空格隔开；</li> \n   <li>创建表时，要根据需保存的数据创建相应的列，并根据要存储数据的类型定义相应的列类型。</li> \n  </ul> </li> \n <li> <p>约束条件</p> <p>约束条件就是给列加一些约束，使该字段存储的值更加符合我们的预期。</p> \n  <table> \n   <thead> \n    <tr> \n     <th>约束条件</th> \n     <th>含义</th> \n    </tr> \n   </thead> \n   <tbody> \n    <tr> \n     <td>UNSIGNED</td> \n     <td>无符号，值从0开始，无负数</td> \n    </tr> \n    <tr> \n     <td>ZEROFILL</td> \n     <td>零填充，当数据的显示长度不够的时候可以使用填补0的效果填充至指定长度，字段会自动添加UNSIGNED</td> \n    </tr> \n    <tr> \n     <td>NOT NULL</td> \n     <td>非空约束，表示该字段的值不能为空</td> \n    </tr> \n    <tr> \n     <td>DEFAULT</td> \n     <td>表示如果插入数据时没有给该字段赋值，那么就使用默认值</td> \n    </tr> \n    <tr> \n     <td>PRIMARY KEY</td> \n     <td>主键约束，表示唯一标识，不能为空，且一个表只能有一个主键</td> \n    </tr> \n    <tr> \n     <td>AUTO_INCREMENT</td> \n     <td>自增长，只能用于数值列，默认起始值从1开始，每次增长1</td> \n    </tr> \n    <tr> \n     <td>UNITQUE KEY</td> \n     <td>唯一值，表示该字段下的值不能重复，可以为空，可以有多个</td> \n    </tr> \n    <tr> \n     <td>COMMENT</td> \n     <td>描述</td> \n    </tr> \n   </tbody> \n  </table> <p>注意：</p> <p>如果一列同时有UNSIGNED、ZEROFILL、NOT NULL这几个约束，<code>UNSIGNED、ZEROFILL必须在NOT NULL前面</code>，否则会报错。</p> <p>例子：</p> <pre><code class=\"language-mysql\">create table user_info_tab(\nuser_id int not null auto_increment,\nuser_name char(10),\npassword varchar(10),\nuser_nick varchar(10),\ncard_num bigint,\nprimary key(user_id)\n);\n</code></pre> </li> \n</ol> \n<h6 id=\"查看表\">查看表</h6> \n<ol> \n <li> <p>显示当前数据库中所有表的名字</p> <p>格式：</p> <pre><code class=\"language-mysql\">show tables;\n</code></pre> </li> \n <li> <p>显示某张表每一列的属性（列名、数据类型、约束）</p> <p>格式：desc [数据表名称];</p> <p>例如：</p> <pre><code class=\"language-mysql\">desc user_info_tab;\n</code></pre> </li> \n</ol> \n<h6 id=\"删除表\">删除表</h6> \n<p>格式：drop table [数据表名称];</p> \n<p>例如：</p> \n<pre><code class=\"language-mysql\">drop table hesheng;\n</code></pre> \n<h6 id=\"修改表\">修改表</h6> \n<ol> \n <li> <p>向数据表中添加一列</p> <p>格式：ALTER TABLE [数据表名称] ADD [列名] [列的数据格式] [约束];</p> <p>例如：</p> <pre><code class=\"language-mysql\">ALTER TABLE user_info_tab ADD phone VARCHAR(11);\n</code></pre> <p>PS：</p> \n  <ul> \n   <li> <p>默认自动添加到数据表字段的末尾；</p> </li> \n   <li> <p>如果要加在第一列在最后加个FIRST；</p> </li> \n   <li> <p>如果要加在某一列的后面，在最后面加个AFTER某一列列名。</p> </li> \n  </ul> </li> \n <li> <p>删除数据表的某一列</p> <p>格式：ALTER TABLE [数据表名称] DROP [列名];</p> </li> \n <li> <p>修改列的类型和名称</p> <p>ALTER TABLE [表名] MODIFY [列名] [数据格式];（列名不变，其他要变）</p> <p>ALTER TABLE [表名] CHANGE [旧列名] [新列名] [数据格式];（列名也要改变）</p> </li> \n</ol> \n<h4 id=\"5数据表的增删改查\">5.数据表的增删改查</h4> \n<h5 id=\"增insert\">增（insert）</h5> \n<pre><code class=\"language-mysql\">-- 插入数据\nINSERT INTO user_info ( user_id, user_name, PASSWORD, user_nick, card_num )\nVALUES\n	( 1, \'zhangsan\', \'abc123\', \'zhangsanfeng\', 124567894651329785 ),\n	( 2, \'lisi\', \'122bbb\', \'limochou\', 124567894651324567 ),\n	( 3, \'wangwu\', \'123aaa\', \'wangbaiwan\', 214567894651324567 ),\n	( 4, \'liuqi\', \'12aaa\', \'liuchuanfeng\', 214563356651324567 ),\n	( 5, \'zhangliu\', \'12aaa\', \'zhangwuji\', 214563356658966567 );\n</code></pre> \n<h5 id=\"删delete\">删（delete）</h5> \n<p>语法：</p> \n<ol> \n <li>delete from 表名 where 条件</li> \n <li>delete语句不能删除某一列的值。（可以使用 update 表名 set username = \"\" where userid = 1）</li> \n <li>使用delete语句仅删除符合where条件的行的数据，不删除表中其他行和表本身。</li> \n <li>truncate user_info_table（直接把数据清空掉）</li> \n</ol> \n<p>drop和delete的区别：</p> \n<ul> \n <li>drop是删除数据库、数据表、数据表中的某一列。</li> \n <li>delete是删除某一行数据。</li> \n</ul> \n<h5 id=\"改update\">改（update）</h5> \n<p>语法：</p> \n<ol> \n <li>update [表名] set [列名]=[新值] where [列名]=[某值];</li> \n <li>update语法可以新增、更新原有表行中的各列。</li> \n <li>set子句指示要修改哪些列和要给予哪些值。</li> \n <li>where子句指定应更新哪些行。如果没有where子句，则更新所有的行。</li> \n</ol> \n<pre><code class=\"language-mysql\">update user_info set username = \"poopoo\" where userid = 1;\n</code></pre> \n<h5 id=\"查select\">查（select）</h5> \n<p>文末练习题中会给出查询语句相关示例。</p> \n<h4 id=\"6-数据表的排序聚合命令分组\">6. 数据表的排序、聚合命令、分组</h4> \n<h5 id=\"排序order-by\">排序（order by）</h5> \n<ul> \n <li> <p>使用order by子句，对查询结果进行排序。</p> </li> \n <li> <p>order by 指定排序的列 asc（升序）/desc（降序）。</p> </li> \n <li> <p>order by 子句一般位于select语句的结尾。</p> </li> \n</ul> \n<pre><code class=\"language-mysql\">SELECT product_name,weight FROM products_info ORDER BY weight DESC;\n</code></pre> \n<h5 id=\"聚合命令\">聚合命令</h5> \n<ol> \n <li> <p>distinct：对某一列数据去重。</p> <p>语句：select distinct 列名 from 表名; -- 显示此列不重复的数据</p> </li> \n <li> <p>count：统计总行数。</p> \n  <ul> \n   <li> <p>count(*)：包括所有列，返回表中的总行数，在统计结果的时候，不会忽略值为Null的行数。</p> </li> \n   <li> <p>count(1)：包括所有列，1表示一个固定值，没有实际含义，在统计结果的时候，不会忽略列值为Null的行数，和count(*)的区别是执行效率不同。</p> </li> \n   <li> <p>count(列名)：只包括列名指定列，返回指定列的行数，在统计结果的时候，不统计列值为Null，即列值为Null的行数不统计在内。</p> </li> \n   <li> <p>count(distinct 列名)：返回指定列的不重复的行数，在统计结果的时候，会忽略列值为NULL的行数（不包括空字符和0），即列值为NULL的行数不统计在内。</p> </li> \n   <li> <p>count(*)、count(1)、count(列名)执行效率比较：</p> \n    <ul> \n     <li> <p>如果列为主键，count(列名)优于count(1)</p> </li> \n     <li> <p>如果列不为主键，count(1)优于count(列名)</p> </li> \n     <li> <p>如果表中存在主键，count(主键列名)效率最优</p> </li> \n     <li> <p>如果表中只有一列，则count(*)效率最优</p> </li> \n     <li> <p>如果表中有多列，且不存在主键，则count(1)效率优于count(*)</p> </li> \n    </ul> </li> \n  </ul> </li> \n <li> <p>MAX：最大值</p> </li> \n <li> <p>MIN：最小值</p> </li> \n <li> <p>AVG：平均值</p> </li> \n <li> <p>SUM：求和</p> <pre><code class=\"language-mysql\">select max(列名) from 表名;\nselect min(列名) from 表名;\nselect avg(列名) from 表名;\nselect sum(列名) from 表名;\n- 也可以跟where子句\n</code></pre> </li> \n <li> <p>limit</p> <p>语法：</p> \n  <ul> \n   <li> <p>select * from 表名 limit m,n;</p> </li> \n   <li> <p>其中m是指从哪行开始，m从0取值，0表示第一行。</p> </li> \n   <li> <p>n是指从第m+1条开始，取n条。</p> </li> \n   <li> <p>select * from 表名 limit 0,2（从第一行开始，显示两行结果）</p> </li> \n   <li> <p>如果只给定一个参数，它表示返回最大的行数目：</p> <p>select * from table limit 5;查询前5行</p> </li> \n   <li> <p>limit n 等价于 limit 0,n</p> </li> \n  </ul> </li> \n</ol> \n<h5 id=\"分组\">分组</h5> \n<p>语法：GROUP BY</p> \n<ul> \n <li> <p>使用group by子句对列进行分组。</p> </li> \n <li> <p>还可以使用having子句过滤，having通常跟在group by后，它作用于组。</p> </li> \n <li> <p>不加having过滤：select 列名,聚合函数 from 表名 where 子句 group by 列名;</p> </li> \n <li> <p>加上having过滤：select 列名,聚合函数 from 表名 where 子句 group by 列名 having 聚合函数 过滤条件;</p> </li> \n <li> <p>注意：使用group by后只能展示分组的列名+聚合函数结果，因为其余列已经基于分组这一列合并。</p> </li> \n</ul> \n<pre><code class=\"language-mysql\">select sum(price), count(user_id), product_id from order_info_table group by product_id having count(user_id) &gt; 2;\n</code></pre> \n<h4 id=\"7-数据表的连接查询子查询\">7. 数据表的连接查询、子查询</h4> \n<h5 id=\"两张表连接查询\">两张表连接查询</h5> \n<p>INNER JOIN（内连接）：获取两个表中字段匹配关系的行的所有信息。</p> \n<p>语法：SELECT * FROM [表名] a INNER JOIN [表名] b ON a.[列名] = b.[列名];</p> \n<p>例如：</p> \n<pre><code class=\"language-sql\">SELECT * FROM user_info_table a INNER JOIN order_info_table b ON a.user_id = b.user_id;\nSELECT * FROM user_info_table a INNER JOIN order_info_table b ON a.user_id = b.user_id WHERE b.user_id IS NULL;\n</code></pre> \n<p>LEFT JOIN（左连接）：以左表为基准，获取左表所有行的信息，即使右表没有对应匹配的行的信息。右表没有匹配的部分用NULL代替。</p> \n<p>语法：SELECT * FROM [表名] a LEFT JOIN [表名] b ON a.[列名] = b.[列名];</p> \n<pre><code class=\"language-mysql\">SELECT * FROM products_info a LEFT JOIN suppliers_info b ON a.supplier_id = b.supplier_id;\n</code></pre> \n<p>RIGHT JOIN（右连接）：与左连接相反，以右表为基准，用于获取右表所有记录，及时左表没有对应匹配的行的所有信息，左表没有匹配的部分用NULL代替。</p> \n<p>语法：SELECT * FROM [表名] a RIGHT JOIN [表名] b ON a.[列名] = b.[列名];</p> \n<pre><code class=\"language-mysql\">SELECT * FROM products_info a RIGHT JOIN suppliers_info b ON a.supplier_id = b.supplier_id;\n</code></pre> \n<p>子查询（嵌套查询）</p> \n<ul> \n <li>嵌套在其他查询中的查询。</li> \n <li>语句：select 列名1 from 表1 where 列名2 in (select 列名2 from 表2 where 列名3 = 某某某);</li> \n <li>注意：一般在子查询中，程序先运行嵌套在最内层的语句，再运行外层。因此在写子查询语句时，可以先测试一下内层的子查询语句是否输出了想要的内容，再一层一层往外测试，增加子查询的正确率。</li> \n</ul> \n<p><strong>其他注意事项</strong>：<code>数据库名和表名</code>在Windows中是大小写不敏感的，但是在大多数类型的UNIX系统中大小写是敏感的。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/28eb8446-9384-44fc-af6a-b624e8df7cf2.png\" alt=\"\" loading=\"lazy\"></p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/d4b5edd3-b6fd-4f07-8d0d-4b6e2f304111.png\" alt=\"\" loading=\"lazy\"></p> \n<h3 id=\"笔试面试题\">笔试面试题</h3> \n<p>一、创建如下要求的表格，并完成相应的题目。</p> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/07/e52a4bb8-65e7-4362-88ac-959eddac2b60.png\" style=\"zoom: 80%\"> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/07/99a85c8d-8a78-4766-b72f-aaa7c69ee5a2.png\" style=\"zoom: 80%\"> \n<pre><code class=\"language-mysql\">-- 创建表\nCREATE TABLE user_info (\n	user_id INT NOT NULL AUTO_INCREMENT,\n	user_name CHAR ( 10 ),\n	password VARCHAR ( 10 ),\n	user_nick VARCHAR ( 10 ),\n	card_num BIGINT,\n	PRIMARY KEY ( user_id ) \n);\n</code></pre> \n<pre><code class=\"language-mysql\">-- 插入数据\nINSERT INTO user_info ( user_id, user_name, PASSWORD, user_nick, card_num )\nVALUES\n	( 1, \'zhangsan\', \'abc123\', \'zhangsanfeng\', 124567894651329785 ),\n	( 2, \'lisi\', \'122bbb\', \'limochou\', 124567894651324567 ),\n	( 3, \'wangwu\', \'123aaa\', \'wangbaiwan\', 214567894651324567 ),\n	( 4, \'liuqi\', \'12aaa\', \'liuchuanfeng\', 214563356651324567 ),\n	( 5, \'zhangliu\', \'12aaa\', \'zhangwuji\', 214563356658966567 );\n</code></pre> \n<pre><code class=\"language-mysql\">-- user_nick长度不够，修改user_nick的长度再重新插入数据\nALTER TABLE user_info MODIFY user_nick VARCHAR ( 20 );\n</code></pre> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/07/f20a2fde-8624-4006-8b5a-7e2dc7df4c6d.png\" style=\"zoom: 80%\"> \n<img src=\"http://localhost:8080/static/blogImages/2022/10/07/a9547d6d-15a6-4c86-9f84-45a7636f7477.png\" style=\"zoom: 80%\"> \n<pre><code class=\"language-mysql\">-- 创建订单表\nCREATE TABLE order_info (\n	order_id INT UNSIGNED ZEROFILL NOT NULL,\n	price DECIMAL ( 10, 2 ) NOT NULL,\n	order_status VARCHAR ( 30 ) NOT NULL,\n	product_id INT NOT NULL,\n	created datetime DEFAULT \"2019-01-01 00:00:00\",\n	user_id INT NOT NULL,\nPRIMARY KEY ( order_id ) \n);\n</code></pre> \n<pre><code class=\"language-mysql\">-- 插入数据\nINSERT INTO order_info\nVALUES\n	( 1, 4.99, \'pay\', 1001, \'2019-09-25 10:25:26\', 1 ),\n	( 2, 9.99, \'nopay\', 1002, \'2019-09-26 10:25:26\', 1 ),\n	( 3, 4.99, \'pay\', 1001, \'2019-09-25 10:25:26\', 2 ),\n	( 4, 9.99, \'nopay\', 1002, \'2019-09-24 10:25:26\', 2 ),\n	( 5, 19.99, \'pay\', 1003, \'2019-09-26 10:25:26\', 2 ),\n	( 6, 4.99, \'pay\', 1001, \'2019-09-25 10:25:26\', 3 ),\n	( 7, 4.99, \'pay\', 1001, \'2019-09-25 10:25:26\', 4 ),\n	( 8, 9.99, \'pay\', 1002, \'2019-09-25 10:25:26\', 4 ),\n	( 9, 19.99, \'pay\', 1003, \'2019-09-26 10:25:26\', 4 ),\n	( 10, 29.99, \'pay\', 1002, \'2019-09-26 10:25:26\', 6 );\n</code></pre> \n<pre><code class=\"language-mysql\">-- where子句小练习\n-- 1. 满足价格大于等于9的所有信息\nSELECT * FROM order_info WHERE price &gt;= 9;\n\n-- 2. 查找满足product_id在1002和1003之间的\nSELECT * FROM order_info WHERE product_id BETWEEN 1002 AND 1003;\n\n-- 3. 查找user_id在1、3、5这三个数内的信息\nSELECT * FROM order_info WHERE user_id IN (1,3,5);\n\n-- 4. 查找订单状态是已支付的信息\nSELECT * FROM order_info WHERE order_status = \'pay\';\n\n-- 5. 查找用户名类似于已li开头的信息\nSELECT * FROM user_info WHERE user_name LIKE \'li%\';\n\n-- 6. 查找用户名中第二个字母是h的信息\nSELECT * FROM user_info WHERE user_name LIKE \'_h%\';\n\n-- 7. 查找用户名中第二个字母不是h的信息\nSELECT * FROM user_info WHERE user_name NOT LIKE \'_h%\';\n\n-- 8. 查找用户名中最后一个字母以i结尾的信息\nSELECT * FROM user_info WHERE user_name LIKE \'%i\';\n\n-- 9. 查找价格大于8，并且订单状态是已支付的所有信息\nSELECT * FROM order_info WHERE price &gt; 8 AND order_status = \'pay\';\n\n-- 10.查找用户表中user_nick为null的信息\nSELECT * FROM user_info WHERE user_nick IS NULL;\n\n-- 11.查找用户表中user_nick为 not null的信息\nSELECT * FROM user_info WHERE user_nick IS NOT NULL;\n</code></pre> \n<pre><code class=\"language-mysql\">-- 聚合函数练习\n-- 1. 查找订单表中最大的价格，查找订单表中最小的价格\nSELECT MAX(price),MIN(price) FROM order_info;\n\n-- 2. 查找订单表中user_id=2的最小价格\nSELECT MIN(price) FROM order_info WHERE user_id = 2;\n\n-- 3. 分别列出订单表中user_id=2的最小价格和最大价格\nSELECT MIN(price),MAX(price) FROM order_info WHERE user_id = 2;\n\n-- 4. 分别列出订单表中user_id=2的最小价格和最大价格，并把最小价格的展示结果的列名改为\"min_price\"\nSELECT MIN(price) AS min_price,MAX(price) FROM order_info WHERE user_id = 2;\n\n-- 5. 求订单表的价格的平均值，求订单表中user_id=2的价格的平均值\nSELECT AVG(price) FROM order_info;\nSELECT AVG(price) FROM order_info WHERE user_id = 2;\n\n-- 6. 分别列出订单表中user_id=2的价格的平均值、最小值、最大值\nSELECT AVG(price),MIN(price),MAX(price) FROM order_info WHERE user_id = 2;\n\n-- 7. 求订单表中user_id=1的价格的总和\nSELECT SUM(price) FROM order_info WHERE user_id = 1;\n\n-- 8. 求订单表中user_id=1或者user_id=3的价格总和\nSELECT SUM(price) FROM order_info WHERE user_id = 1 OR user_id = 3;\n</code></pre> \n<pre><code class=\"language-mysql\">-- 分组练习\n-- 1.首先筛选状态为已支付的订单，然后按照user_id分组，分组后每一组对支付金额进行求和，最终展示user_id和对应组求和金额\nSELECT user_id,SUM(price) FROM order_info WHERE order_status = \'pay\' GROUP BY user_id;\n\n-- 2.首先筛选状态为支付的订单，然后按照user_id分组，分组后每一组对支付金额进行求和，再过滤求和金额大于10的，最终展示user_id和对应组的求和金额\nSELECT user_id,SUM(price) FROM order_info WHERE order_status = \'pay\' GROUP BY user_id HAVING SUM(price) &gt; 10;\n</code></pre> \n<pre><code class=\"language-mysql\">-- 数据表连接查询和子查询练习\n-- 1.查询订单表中的价格大于10元的用户的昵称（小提示：用户昵称在用户表中，订单价格在订单表中）\nSELECT a.user_nick FROM user_info a INNER JOIN order_info b ON a.user_id = b.user_id WHERE b.price &gt; 10;\nSELECT user_nick FROM user_info WHERE user_id IN (SELECT user_id FROM order_info WHERE price &gt; 10);\n\n-- 2.查询用户名以l开头的用户买过的所有订单id和对应价格（小提示：订单id和对应价格在订单表中，用户名在用户表中）\nSELECT o.order_id,o.price FROM order_info o WHERE o.user_id IN (SELECT user_id FROM user_info u WHERE u.user_name LIKE \'l%\');\n</code></pre> \n<p>二、创建如下要求的表格，并完成相应的题目。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/9d5faab9-8ebc-46d6-b62d-046f9695aa6e.png\" alt=\"\" loading=\"lazy\"></p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/0f524508-a3c8-4655-93e8-b1987b4f8f51.png\" alt=\"\" loading=\"lazy\"></p> \n<pre><code class=\"language-mysql\">-- 1.按照表定义创建商品表+供应商表\n-- 2.按照表数据插入所有数据\n\n-- 创建商品表\nCREATE TABLE products_info (\n	product_id INT UNSIGNED ZEROFILL NOT NULL,\n	product_name VARCHAR ( 30 ) DEFAULT \'water\',\n	classification VARCHAR ( 30 ),\n	weight FLOAT ( 10, 2 ),\n	supplier_id INT,\nPRIMARY KEY ( product_id ) \n);\n\n-- 向商品表插入数据\nINSERT INTO products_info\nVALUES\n	( 1001, \'water\', \'Daily_Necessities\', 0.55, 1 ),\n	( 1002, \'soap\', \'Daily_Necessities\', 0.15, 2 ),\n	( 1003, \'paper\', \'Daily_Necessities\', 0.12, 3 ),\n	( 1004, \'pingpangqiu\', \'sports\', 0.05, 4 ),\n	( 1005, \'yumaoqiu\', \'sports\', 0.04, 6 );\n</code></pre> \n<pre><code class=\"language-mysql\">-- 创建供应商表\nCREATE TABLE suppliers_info (\n	supplier_id INT NOT NULL AUTO_INCREMENT,\n	supplier_name VARCHAR ( 30 ),\n	Registration_number INT,\n	contacts VARCHAR ( 30 ),\n	contacts_phone_num CHAR ( 11 ),\nPRIMARY KEY ( supplier_id ) \n);\n\n-- 向供应商表插入数据\nINSERT INTO suppliers_info\nVALUES\n	( 1, \'nongfushanquan\', 1000001, \'mayun\', \'18026156362\' ),\n	( 2, \'jiajieshi\', 1000002, \'liuqiangdong\', \'13826156363\' ),\n	( 3, \'qingfeng\', 1000003, \'mahuateng\', \'18926156364\' ),\n	( 4, \'361du\', 1000004, \'renzhenfei\', \'18226156365\' ),\n	( 5, \'anta\', 1000005, \'leijun\', \'18626156366\' );\n</code></pre> \n<pre><code class=\"language-mysql\">-- 3.修改供应商id为4的供应商名称为‘hongshuangxi’\nUPDATE suppliers_info SET supplier_name = \'hongshuangxi\' WHERE supplier_id = 4;\n\n-- 4.查询商品重量大于0.10的商品的名称\nSELECT product_name FROM products_info WHERE weight &gt; 0.10;\n\n-- 5.查询商品名称以字母p开头的商品的所有信息\nSELECT * FROM products_info WHERE product_name like \'p%\';\n\n-- 6.查询商品重量大于0.10,小于0.20的商品名称\nSELECT product_name FROM products_info WHERE weight &gt; 0.10 AND weight &lt; 0.20;\n\n-- 7.按照商品分类统计各自的商品总个数，显示每个分类和其对应的商品总个数\nSELECT classification,COUNT(classification) FROM products_info GROUP BY classification;\n\n-- 8.将所有商品的名称按照商品重量由高到低显示\nSELECT product_name,weight FROM products_info ORDER BY weight DESC;\n\n-- 9.显示所有商品的信息，在右边显示有供应商的商品对应的供应商信息\nSELECT * FROM products_info a LEFT JOIN suppliers_info b ON a.supplier_id = b.supplier_id;\n\n-- 10.显示重量大于等于0.15的商品的供应商的联系人和手机号\nSELECT s.contacts,s.contacts_phone_num FROM suppliers_info s INNER JOIN products_info p ON s.supplier_id = p.supplier_id and p.weight &gt;= 0.15;\n</code></pre>',100,NULL,0,'https://www.cnblogs.com/caituotuo/p/16758937.html','2022-10-07 06:30:48'),(27,'CentOS 7.9 安装 MySQL 5.7.35',NULL,NULL,0,0,'<h3><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 18px\">一、CentOS 7.9 安装 MySQL 5.7.35</span></h3> \n<hr> \n<p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>1</strong> 下载地址：<a href=\"https://downloads.mysql.com/archives/community/\" target=\"_blank\" rel=\"noopener\">https://downloads.mysql.com/archives/community/</a></span></p> \n<div>\n <img src=\"http://localhost:8080/static/blogImages/2022/10/07/78351877-91bf-4f58-8fd8-58f086e821a6.png\" alt=\"\" height=\"529\" width=\"520\"> \n <p id=\"1665087105556\"></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>2 </strong>mysql 5.7.35 安装包上传到linux服务器</span></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">使用Xftp 或者 <span style=\"color: rgba(228, 55, 233, 1)\">wget </span>在服务器上下载</span></p> \n <pre class=\"language-python highlighter-hljs\"><code># 推荐使用wget\nyun install -y wget\nwget https://downloads.mysql.com/archives/get/p/23/file/mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz</code></pre> \n <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/4ac724a4-7160-44f1-ae29-4bb3e63a4de3.png\" alt=\"\" height=\"313\" width=\"700\"></p> \n <p id=\"1665067332681\"></p> \n <p id=\"1665066461413\"></p> \n <p><strong style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">3</strong><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"> 检查系统是否安装过mysql，如果没有略过此步骤</span></p> \n</div> \n<div> \n <pre class=\"language-python highlighter-hljs\"><code>[root@ecs-65685 ~]# rpm -qa|grep mysql</code></pre> \n</div> \n<div>\n <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/c870020e-20c3-4b51-8fb0-25b7d3335cc7.png\" alt=\"\" height=\"92\" width=\"500\"></span> \n <p id=\"1665067029724\"><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">没有任何输出说明没有安装过mysql！</span></p> \n</div> \n<div> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">如果系统自带mysql，查询所有mysql 对应的文件夹，全部删除，使用命令：</span></p> \n</div> \n<div> \n <pre class=\"language-python highlighter-hljs\"><code>whereis mysql\nfind / -name mysql\nrpm -qa| grep mysql</code></pre> \n</div> \n<div>\n <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">来查看所有mysql关联的目录，然后全部删除。</span>\n</div> \n<div>\n <img src=\"http://localhost:8080/static/blogImages/2022/10/07/e514eba4-c8b9-4a2b-b784-2557a83ccb6f.png\" alt=\"\" height=\"149\" width=\"500\"> \n <p id=\"1665068882795\"></p> \n <p id=\"1665067623269\"></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>4</strong> 卸载CentOS7系统自带mariadb</span></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">查看系统自带的Mariadb，没有略过此步骤</span></p> \n <p id=\"1665067606740\"></p> \n</div> \n<div> \n <pre class=\"language-python highlighter-hljs\"><code>rpm -qa|grep mariadb</code></pre> \n</div> \n<div> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">卸载系统自带的Mariadb</span></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">因为centos7自带的mariadb 与mysql冲突，所以需要先卸载</span></p> \n</div> \n<div> \n <pre class=\"language-python highlighter-hljs\"><code>yum remove mariadb-libs -y</code></pre> \n</div> \n<div>\n <img src=\"http://localhost:8080/static/blogImages/2022/10/07/17042844-ccef-415f-8255-7d257f497951.png\" alt=\"\" height=\"69\" width=\"500\"> \n <p id=\"1665069905729\"><strong style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">5</strong><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"> 删除etc目录下的my.cnf</span></p> \n</div> \n<div> \n <div> \n  <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">查看 /etc 目录下有没有 my.cnf 文件，如果有，删除：</span></p> \n  <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/0e69ca45-835b-40cf-928a-b8bbc4cba03c.png\" alt=\"\" height=\"89\" width=\"500\"></p> \n  <div> \n   <p id=\"1665068589809\"><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>6</strong> 创建用户和组</span></p> \n  </div> \n  <div> \n   <div> \n    <pre class=\"language-python highlighter-hljs\"><code>useradd mysqlxyz -s /sbin/nologin\nid mysqlxyz</code></pre> \n   </div> \n   <div>\n    <img src=\"http://localhost:8080/static/blogImages/2022/10/07/f648f333-f519-47b2-9ae9-ecab257d2045.png\" alt=\"\" height=\"113\" width=\"500\">\n   </div> \n   <div>\n    &nbsp;\n   </div> \n  </div> \n  <h3><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 18px\">二、创建目录，并解压</span></h3> \n  <hr> \n  <p id=\"1665068985632\"></p> \n </div> \n <div> \n  <div> \n   <div>\n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>1</strong> 创建软件目录</span>\n   </div> \n   <div> \n    <pre class=\"language-python highlighter-hljs\"><code>mkdir -p /opt/mysqlxyz/database</code></pre> \n   </div> \n   <div>\n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>2</strong> 创建数据目录</span>\n   </div> \n   <div> \n    <pre class=\"language-plaintext highlighter-hljs\"><code>mkdir -p /opt/mysqlxyz/data</code></pre> \n   </div> \n   <div>\n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>3 </strong>创建日志目录</span>\n   </div> \n   <div> \n    <pre class=\"language-plaintext highlighter-hljs\"><code>mkdir -p /opt/mysqlxyz/binlog</code></pre> \n   </div> \n   <div>\n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>4 </strong>设置权限</span>\n   </div> \n   <div> \n    <pre class=\"language-plaintext highlighter-hljs\"><code>chown -R mysqlxyz.mysqlxyz /opt/mysqlxyz/database /opt/mysqlxyz/data /opt/mysqlxyz/binlog</code></pre> \n   </div> \n  </div> \n  <div>\n   &nbsp;\n   <img src=\"http://localhost:8080/static/blogImages/2022/10/07/122698bf-9958-4ed8-9ec3-4833842c6949.png\" alt=\"\" height=\"231\" width=\"700\"> \n   <p id=\"1665070576566\"></p> \n   <p id=\"1665070570973\"></p> \n  </div> \n  <div>\n   &nbsp;\n  </div> \n  <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>5</strong> 解压安装mysql安装包到 /opt/mysqlxyz/database/ 目录下</span></p> \n  <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">tar -zxvf mysql-5.7.35-linux-glibc2.12-x86_64.tar.gz -C /opt/mysqlxyz/database/</span></p> \n  <div> \n   <div>\n    <img src=\"http://localhost:8080/static/blogImages/2022/10/07/bccc31d8-81dc-4263-a2a7-598062e9c6ab.png\" alt=\"\" height=\"319\" width=\"700\"> \n    <p id=\"1665070468758\"></p> \n   </div> \n  </div> \n  <div>\n   <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>&nbsp;6 </strong>名字太长，修改为 mysql-5.7.35</span>\n  </div> \n  <div> \n   <pre class=\"language-plaintext highlighter-hljs\"><code>cd /opt/mysqlxyz/database\nmv mysql-5.7.35-linux-glibc2.12-x86_64/ mysql-5.7.35</code></pre> \n  </div> \n  <div>\n   <img src=\"http://localhost:8080/static/blogImages/2022/10/07/da2643f5-ae8d-42e2-9965-0f73eba9232e.png\" alt=\"\" height=\"363\" width=\"700\"> \n   <p id=\"1665071074090\"></p> \n   <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>7</strong> 更改 mysql-5.7.35 目录下所有文件夹所属的用户组、用户以及权限</span>\n  </div> \n  <div> \n   <pre class=\"language-plaintext highlighter-hljs\"><code>cd /opt/mysqlxyz/database/mysql-5.7.35\nchown -R mysqlxyz. *</code></pre> \n   <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/51b9ff59-8271-429c-b6df-37420e3619df.png\" alt=\"\" height=\"396\" width=\"500\"></p> \n   <p id=\"1665071237057\"></p> \n   <p id=\"1665071232107\"></p> \n   <div>\n    &nbsp;\n   </div> \n   <h3><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 18px\"><strong>三、</strong>设置环境变量</span></h3> \n   <hr> \n   <div> \n    <pre class=\"language-bash highlighter-hljs\"><code>vim /etc/profile\nexport PATH=$PATH:/opt/mysqlxyz/database/mysql-5.7.35/bin\nsource /etc/profile</code></pre> \n   </div> \n   <div>\n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">查看版本</span>\n   </div> \n   <div> \n    <pre class=\"language-bash highlighter-hljs\"><code>mysql -V</code></pre> \n   </div> \n   <div>\n    <img src=\"http://localhost:8080/static/blogImages/2022/10/07/e848aa46-460c-4f12-9fbf-520fed037433.png\" alt=\"\" height=\"199\" width=\"500\"> \n    <p id=\"1665071750039\"></p> \n    <p>&nbsp;</p> \n    <h3><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 18px\"><strong>四、</strong>安装 mysql5.7.35</span></h3> \n    <hr> \n    <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>1</strong> 初始化系统库表（带有<span style=\"color: rgba(228, 55, 233, 1)\">临时密码</span>）</span></p> \n    <pre class=\"language-bash highlighter-hljs\"><code>mysqld --initialize --user=mysqlxyz --basedir=/opt/mysqlxyz/database/mysql-5.7.35 --datadir=/opt/mysqlxyz/data</code></pre> \n    <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong><img src=\"http://localhost:8080/static/blogImages/2022/10/07/74d047a6-1d49-4ce9-9041-52fe5bdcd57c.png\" alt=\"\" height=\"356\" width=\"700\"></strong></span></p> \n    <p>&nbsp;</p> \n    <p id=\"1665074349750\"></p> \n    <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>2&nbsp;</strong>初始化系统库表（<span style=\"color: rgba(228, 55, 233, 1)\">密码为空</span>）</span></p> \n    <pre class=\"language-bash highlighter-hljs\"><code>mysqld --initialize-insecure --user=mysqlxyz --basedir=/opt/mysqlxyz/database/mysql-5.7.35 --datadir=/opt/mysqlxyz/data</code></pre> \n    <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/21954945-53de-4996-bdc4-44aca9a202e3.png\" alt=\"\" height=\"90\" width=\"500\"></span></p> \n    <div>\n     <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">联网状态或者有yum源可以直接安装缺失的包文件：</span>\n    </div> \n    <div> \n     <pre class=\"language-bash highlighter-hljs\"><code>yum install libncurses* -y</code></pre> \n    </div> \n    <p id=\"1665072010415\"></p> \n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">再次执行</span>\n   </div> \n   <div> \n    <pre class=\"language-bash highlighter-hljs\"><code>cd /opt/mysqlxyz/data\nmysqld --initialize-insecure --user=mysqlxyz --basedir=/opt/mysqlxyz/database/mysql-5.7.35 --datadir=/opt/mysqlxyz/data\n# 安装多个mysql 把 --datadir 修改下即可，还有端口</code></pre> \n   </div> \n   <div>\n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/b8de3442-cbaf-41b1-a0ae-3eb4a8efd138.png\" alt=\"\" height=\"375\" width=\"700\"></span> \n    <p id=\"1665072616424\"></p> \n   </div> \n   <div>\n    &nbsp;\n   </div> \n   <div> \n    <div>\n     <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>3 </strong>配置文件设置&nbsp; /etc/my.cnf</span>\n    </div> \n    <div> \n     <pre class=\"language-bash highlighter-hljs\"><code>cat&gt;/etc/my.cnf&lt;&lt;EOF\n[mysqld]\nuser=mysqlxyz\nbasedir=/opt/mysqlxyz/database/mysql-5.7.35\ndatadir=/opt/mysqlxyz/data\nport=3306\nsocket=/tmp/mysql57.sock\nserver_id=6\n[mysql]\nsocket=/tmp/mysql57.sock\n[client]\nsocket=/tmp/mysql57.sock\nEOF</code></pre> \n    </div> \n    <div>\n     <img src=\"http://localhost:8080/static/blogImages/2022/10/07/32f9f026-c82b-4f26-b0fe-572388ccd523.png\" alt=\"\" height=\"216\" width=\"500\"> \n     <p id=\"1665076689847\"></p> \n     <p id=\"1665074672681\"></p> \n     <p id=\"1665074667560\"></p> \n    </div> \n    <div>\n     <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>4 </strong>启动脚本</span>\n    </div> \n    <div> \n     <pre class=\"language-bash highlighter-hljs\"><code>cd /opt/mysqlxyz/database/mysql-5.7.35/support-files/\n# 将服务文件拷贝到init.d下，并重命名为mysql\ncp mysql.server /etc/init.d/mysqld\n# 赋予可执行权限 可省略\nchmod +x /etc/init.d/mysqld\n# 添加服务\nchkconfig --add mysqld\n# 显示服务列表\nchkconfig --list\n# 启动mysql\nsystemctl start mysqld</code></pre> \n    </div> \n    <div>\n     <img src=\"http://localhost:8080/static/blogImages/2022/10/07/c3be7e76-2baa-4012-8337-9fae679b4b22.png\" alt=\"\" height=\"187\" width=\"700\"> \n     <p id=\"1665074586527\"></p> \n    </div> \n    <div>\n     <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\"><strong>5 </strong>使用 mysqladmin 修改密码</span>\n    </div> \n    <div> \n     <pre class=\"language-bash highlighter-hljs\"><code>mysqladmin -uroot -p password iyuyi.xyz@gamil.com\nmysql -uroot -p</code></pre> \n    </div> \n    <div> \n     <p id=\"1665077101795\"></p> \n     <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/d4e787d3-93c1-43fb-ac50-a3a52b73ea58.png\" alt=\"\" height=\"375\" width=\"700\"></p> \n     <p>&nbsp;</p> \n     <h3><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 18px\"><strong>五、</strong>开放远程连接</span></h3> \n     <hr> \n     <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">localhost修改为%，使用远程连接</span></p> \n     <pre class=\"language-bash highlighter-hljs\"><code>use mysql;\nselect user, host from user;\nupdate user set host = \'%\' where user = \'root\';\nflush privileges;</code></pre> \n    </div> \n    <div>\n     <img src=\"http://localhost:8080/static/blogImages/2022/10/07/9390a83d-86b8-48fc-b3f3-62a2b25b1929.png\" alt=\"\" height=\"399\" width=\"500\">\n    </div> \n   </div> \n   <div> \n    <div class=\"jb51code\"> \n     <div id=\"highlighter_172566\" class=\"syntaxhighlighter  sql\"></div> \n    </div> \n    <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">允许远程连接 授权</span></p> \n    <pre class=\"language-bash highlighter-hljs\"><code>use mysql;\nGRANT ALL PRIVILEGES ON *.* TO \'root\'@\'%\' IDENTIFIED BY \'iyuyi.xyz@gamil.com\' WITH GRANT OPTION;</code></pre> \n   </div> \n   <div>\n    <span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">最好刷新一下权限；不刷新有可能也能生效</span>\n   </div> \n  </div> \n  <div> \n   <pre class=\"language-bash highlighter-hljs\"><code>flush privileges;</code></pre> \n  </div> \n </div> \n</div> \n<div>\n <img src=\"http://localhost:8080/static/blogImages/2022/10/07/8ce20260-f72a-44b6-9639-23294e627ec8.png\" alt=\"\" height=\"118\" width=\"700\"> \n <p>&nbsp;</p> \n <h3><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 18px\"><strong>六、</strong>防火墙</span></h3> \n <hr> \n <pre class=\"language-bash highlighter-hljs\"><code># 关闭防火墙\nsystemctl stop firewalld\n\n# 开放3306端口命令\nfirewall-cmd --zone=public --add-port=3306/tcp --permanent\n# 配置立即生效\nfirewall-cmd --reload</code></pre> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">&nbsp;</span></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">云主机需配置安全组</span></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">在入方向规则，允许3306放行</span></p> \n <p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/b00bb26c-343c-4cd2-81e8-d1629476e958.png\" alt=\"\" height=\"28\" width=\"700\"></p> \n <p id=\"1665078978380\"></p> \n <p id=\"1665078925748\"></p> \n <p><span style=\"font-family: &quot;Microsoft YaHei&quot;; font-size: 16px\">navicat连接</span></p> \n <img src=\"http://localhost:8080/static/blogImages/2022/10/07/9665b8e3-3704-4da7-906f-af2caa752669.png\" alt=\"\" height=\"511\" width=\"500\"> \n <p id=\"1665078572091\"></p> \n</div> \n<div>\n &nbsp;\n</div>',100,NULL,0,'https://www.cnblogs.com/huaxiayuyi/p/16758720.html','2022-10-07 06:31:13'),(28,'【.NET 6+Loki+Grafana】实现轻量级日志可视化服务功能','前言：日志功能是几乎所有程序或系统都必备的一个功能。该文章通过使用Loki+Grafana来实现日志记录与可视化查询，欢迎围观。有关环境：操作系统：WIN 10.NET环境：.NET 6开发环境：VS 20221、首先下载Grafana安装包，此处下载最新的企业版，当前最新的版本是9.1.7。大佬们可以根据自','2022-10-07 19:13:19',0,0,'<p><span style=\"font-family: 楷体, &quot;Kaiti SC&quot;; font-size: 18px\">前言：日志功能是几乎所有程序或系统都必备的一个功能。该文章通过使用Loki+Grafana来实现日志记录与可视化查询，欢迎围观。</span></p><p><span style=\"font-family: 楷体, &quot;Kaiti SC&quot;; font-size: 18px\">有关环境：</span></p><p><span style=\"font-family: 楷体, &quot;Kaiti SC&quot;; font-size: 18px\">操作系统：WIN 10</span></p><p><span style=\"font-family: 楷体, &quot;Kaiti SC&quot;; font-size: 18px\">.NET环境：.NET 6</span></p><p><span style=\"font-family: 楷体, &quot;Kaiti SC&quot;; font-size: 18px\">开发环境：VS 2022</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">1、首先下载Grafana安装包，此处下载最新的企业版，当前最新的版本是9.1.7。大佬们可以根据自己需要选择有关版本</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">下载地址：https://grafana.com/grafana/download?platform=windows</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/b50143d2-24ba-4007-ac90-8820e952db58.png\" alt=\"\"/></span></p><p>&nbsp;</p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">2、然后下载Loki环境。我选择的2.6.0版本(最新版是2.6.1,但是还没有提供Windows安装版本。大佬们感兴趣也可以下载Loki源码自行编译为安装包)</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">下载地址：https://github.com/grafana/loki/releases</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a0b77bdf-f215-4331-98e4-55b0465a34d9.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">3、安装grafana</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/d1d8b2e3-a1c2-497a-83b1-79049a8f326b.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">4、安装完毕以后，浏览器输入 http://localhost:3000 即可跳转到登陆页面。初始用户名和密码都是admin</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a291278d-a6fe-41b7-8ce1-e9983acea329.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">5、登陆以后，就可以看到grafana的主页面了。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a387f188-de49-477e-9f21-06182b99fd67.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">6、可选部分：下载promtail环境。该组建用于日志的中转使用，以下文章内容没有使用到该组建，可以自行选择使用。如果要做强大一点的，建议使用。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">如果以上三个工具都不好下载，可以进入文章原文：【https://www.cnblogs.com/weskynet/p/16759677.html】，通过公众号回复关键字进行领取我本地下载好的安装包等内容，包括该文章的源码。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/2e961f00-171d-459e-9ec1-85c32943e7d8.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">7、把下载好的Loki解压出来备用</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/451cdb70-601c-4a53-abb7-12d91316c284.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">8、进入到解压后的Loki文件夹下，可以看到Loki的运行程序，此处我们在该目录下，新家一个配置文件。大概内容，如图所示。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">备注：retention_period如果是小时数，必须是24小时的整数倍。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">详情有关Loki配置文件的配置内容，可以参考Loki的官方文档：https://grafana.com/docs/loki/latest/configuration/</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/61d0c088-6436-4d1a-a49f-ba7012846396.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">9、启动Loki服务。建议在控制台下进行启动，否则可能一闪而过。启动命令： xxx.exe --config.file=配置文件.yaml</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">如果启动都没有问题，也可以挂载到Windows服务。如何挂载到Windows服务(.bat文件、exe文件、带有服务启动信息的dll等都可以挂载为Windows服务)，可以参考另一篇文章，关于挂载Elasticsearch等到Windows服务的方法：https://www.cnblogs.com/weskynet/p/14961565.html</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/cc4f8f09-f211-47f8-90a2-373105b40921.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">10、接下来创建一个简单的测试案例，来试一下Loki日志的效果。创建一个基于.NET6的webapi服务。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/ba693f7c-12f0-4255-83ae-5f5afaf4a767.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">11、引用serilog包，有关引用的包详情，可以参考下图所示。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/84b73c7c-d4c5-4d59-97ee-d0df7e6a6272.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">12、然后在appsetrtings配置文件内，添加有关配置信息。此处把日志分别输出到控制台和Loki上。并且在Loki上，配置对应日志标签，标签用于做查询和日志一些规则匹配使用.</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/bb77224a-4951-4c3e-ad9d-f8d273b86ef3.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">13、在启动项内，添加对serilog日志的服务注册，注册服务的有关配置，通过获取配置文件自动关联。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">如果需要了解serilog日志开发的其他方面的教程，可以参考我以前写的专题文章：https://www.cnblogs.com/weskynet/p/14829299.html</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/4376f3a2-9cb5-4539-a246-ded8d2ddb248.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">14、新增一个控制器，用来做日志写入测试。构造函数注入日志服务，并进行输出三个不同类型的日志。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/251178e2-7f6d-41da-bf2c-d726eb22e149.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">15、运行程序，在swagger内调用一下。访问成功以后，可以看到控制台已有日志输出。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/822c2e66-cd39-4e97-9671-dcce25ed49c0.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">16、打开grafana，左下角选择 数据源(Data sources)</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/e4ea503b-22aa-4267-9fae-3efc6a6f0c3c.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">17、选择Loki数据源，并输入Loki部署的地址(此处是本地地址，如果需要修改部署地址和端口，可以Loki配置文件内修改)。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/1ebfc28e-1bf6-4bcb-b61c-1d215bf9b149.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">18、配置地址完毕以后，选择保持和测试，提示成功即可。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/fb55a5b0-3ac8-4d20-92af-f044de6358a4.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">19、然后转到Explore菜单栏，可以对查询功能进行预设。区间如图所示。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/4151e1ad-3fb8-4073-b0db-da095beda643.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">20、在搜索栏里面，选择标签信息。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/284a8987-9a52-409c-a04c-36c8741f15a7.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">21、然后选择标签值信息</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/478ce2ab-807a-4c42-80e5-240a5f044358.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">22、根据选择时间区间查询，即可查到对应日志。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/2456ccdc-7539-425b-af27-5fdbe3d63490.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">23、也可以通过Json形式进行查看。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/4950d5b1-2bd1-4179-a459-40fd32885ad0.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">24、也可以做关键字查询。具体查询套路，也可以参考grafana的有关文档进行了解。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a4095f1e-d97f-448c-be2f-a1f73d57bdbb.png\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">25、如果需要文章内配套的安装包以及源码，可以微信扫描下方二维码，或者搜索公众号【Dotnet Dancer】，在公众号聊天窗口回复【Loki】即可获取以上所有内容：包括grafana安装包、Loki程序以及对应配置文件、promtail程序以及预设配置文件、LokiDemo源码。</span></p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/9212767d-c3e1-4c38-bf34-5808ec709b4b.jpeg\" alt=\"\"/></span></p><p>&nbsp;</p><p><span style=\"font-family: arial, helvetica, sans-serif; font-size: 18px\">以上就是该文章的全部内容，如果有帮助，欢迎转发、点赞和评论。谢谢大家围观~如果对.NET开发感兴趣，也可以转到原文【https://www.cnblogs.com/weskynet/p/16759677.html】，到最下方点击QQ群链接，即可申请入群。再次感谢大佬们围观~~<br/></span></p><p>&nbsp;</p>',1,NULL,1,'https://www.cnblogs.com/weskynet/p/16759677.html','2022-10-07 15:01:39'),(29,'分布式存储系统之Ceph集群CephX认证和授权',NULL,NULL,0,0,'<p>　　前文我们了解了Ceph集群存储池操作相关话题，回顾请参考<a href=\"https://www.cnblogs.com/qiuhom-1874/p/16743611.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/qiuhom-1874/p/16743611.html</a>；今天我们来聊一聊在ceph上认证和授权的相关话题；</p> \n<p>　　我们知道ceph作为一个分布式存储系统，用户想要在其上面存储数据，首先得通过认证以后，才能正常使用ceph；那么对于ceph来讲，它是怎么认证用户的呢？除了认证，我们知道不是所有用户都能在ceph上创建存储池，删除存储池等；这也意味着每个用户都有一定的权限，在自己的权限范围内操作，ceph才算得上是一个安全的存储系统；那么ceph的认证和授权到底是怎么做的呢？</p> \n<p>　　CephX认证机制</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/0bfe10aa-a4a4-42c0-b529-aa3e4894c649.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　Ceph使用cephx协议对客户端进行身份认证，其过程大致是这样的；每个mon都可以对客户端进行身份验证并分发密钥；这意味着认证靠mon节点完成，不会存在单点和性能瓶颈；mon会返回用于身份验证的数据结构，其中包含获取Ceph服务时用到的session key；所谓session key就是客户端用来向mon请求所需服务的凭证；session key是通过客户端的密钥进行加密传输；当mon收到客户端认证请求后，首先生成session key，然后用客户端的密钥加密session key，然后发送给客户端，客户端用自己的密钥将其解密，拿到session key；客户端有了session key以后，它就可以用这个session key向mon请求服务，mon收到客户端的请求（携带session key），此时mon会向客户端提供一个ticket（入场卷，票据）然后用session key加密后发送给客户端；随后客户端用session key解密，拿着这个凭证到对应osd完成认证；</p> \n<p>　　以上过程，我们需要注意，客户端的密钥是通过mon节点在创建用户帐号时就会生成，所以mon节点有对应客户端的密钥，所以通过客户端的密钥加密，客户端可以用自己的密钥解密；其次mon节点生成的session key 是有记录的，所以对于不同客户端来说，都有不同的记录；并且该session key是有时间限制的；过期即便是对应客户端，也没法正常使用；所以客户端拿着对应session key向mon请求服务，对应mon都是认可的，所以mon会发放ticket；最后我们要知道，MON和OSD都是共享客户端的密钥和session key，以及mon发放的ticket，所以客户端拿着mon发放的ticket，对应osd是认可的；这也意味着不管是那个mon节点发放的ticket，对应所有mon节点和osd都是知道的；简单讲就是集群组件之间共享同一个secret；</p> \n<p>　　CephX身份验证MDS和OSD</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/d1549783-0cca-4f08-a0ab-dccac3876969.png\" alt=\"\" loading=\"lazy\"></p> \n<p>　　提示：简要过程是客户端请求创建用户，mon创建用户并返回与共享密钥给客户端；客户端向mon发起认证，认证成功，mon会返回一个session key；在规定时效范围内，客户端拿着session key向mon请求ticket，mon生成ticket并用对应session加密，客户端收到对应mon返回的数据用session key解密，拿到ticket；随后客户端拿着对应当ticket去mds或者osd进行数据存取操作，对应组件会被认证通过，因为mon和mds、osd之间都是共享secret；</p> \n<p>　　这里需要注意，CephX身份验正功能仅限制Ceph的各组件之间，它不能扩展到其它非Ceph组件；其次它并不解决数据传输加密的问题；什么意思呢？我们知道ceph的客户端接口有rbd、cephfs和radosgw；对于ceph来讲，它并不关心什么样的客户端通过rbd、cephfs、radosgw接口量访问数据；它只关心rbd、cephfs、radosgw这些客户端接口程序能够正常认证通过；简单讲就是数据最后“一公里”它不负责，至于用rbd、cephfs、radosgw这些接口的客户端是谁，怎么传输数据它管不着；</p> \n<p>　　认证与授权相关术语</p> \n<p>　　无论Ceph客户端是何类型，Ceph都会在存储池中将所有数据存储为对象；Ceph用户需要拥有存储池访问权限才能读取和写入数据；Ceph用户必须拥有执行权限才能使用Ceph的管理命令；</p> \n<p>　　用户：所谓用户是指个人或系统参与者（例如应用）；通过创建用户，可以控制谁（或哪个参与者）能够访问Ceph存储集群、以及可访问的存储池及存储池中的数据；Ceph支持多种类型的用户，但可管理的用户都属于Client类型；区分用户类型的原因在于，MON、OSD和MDS等系统组件也使用cephx协议，但它们非人为客户端；通过点号来分隔用户类型和用户名，格式为TYPE.ID，例如client.admin等</p> \n<p>　　授权和使能：Ceph基于“使能(caps)”来描述用户可针对MON、OSD或MDS使用的权限范围或级别；通用语法格式：daemon-type \'allow caps\' [...]；MON使能，包括r、w、x和allow profile cap，例如：mon \'allow rwx\'，以及mon \'allow profile osd\'等；OSD使能包括r、w、x、class-read、class-write和profile osd；此外，OSD 使能还允许进行存储池和名称空间设置；MDS使能只需要allow，或留空；</p> \n<p>　　使能的意义</p> \n<p>　　allow：需先于守护进程的访问设置指定，仅对MDS表示rw之意，其它的表示字面意义；</p> \n<p>　　r：读取权限，访问MON以检索CRUSH时依赖此使能；</p> \n<p>　　w：对象写入权限；<br>　　x：调用类方法（读取和写入）的能力，以及在MON上执行auth操作的能力；<br>　　class-read：x能力的子集，授予用户调用类读取方法的能力；<br>　　class-write：x的子集，授予用户调用类写入方法的能力；<br>　　*：授予用户对特定守护进程/存储池的读取、写入和执行权限，以及执行管理命令的能力；</p> \n<p>　　profile osd：授予用户以某个OSD身份连接到其他OSD或监视器的权限，授予OSD权限，使OSD能够处理复制检测信号流量和状态报告；</p> \n<p>　　profile mds：&nbsp;授予用户以某个MDS身份连接到其他MDS或监视器的权限；</p> \n<p>　　profile bootstrap-osd：&nbsp;授予用户引导OSD的权限，授权给部署工具，使其在引导OSD时有权添加密钥；</p> \n<p>　　profile bootstrap-mds：授予用户引导元数据服务器的权限，授权给部署工具，使其在引导元数据服务器时有权添加密钥；</p> \n<p>　　Ceph用户管理</p> \n<p>　　Ceph集群管理员能够直接在Ceph集群中创建、更新和删除用户；创建用户时，可能需要将密钥分发到客户端，以便将密钥添加到密钥环；所谓密钥环，我们就可以理解为存放密钥的一个文件，该文件可以同时存放一个或多个用户的密钥信息；有点类似我们生活中的钥匙环，我们可以在上面挂一个或多个钥匙；</p> \n<p>　　列出用户命令：ceph auth list</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth list\ninstalled auth entries:\n\nmds.ceph-mon02\n        key: AQDT1y9jaMUZDRAA79b3XSXqBbXUlNsT0RLeiw==\n        caps: [mds] allow\n        caps: [mon] allow profile mds\n        caps: [osd] allow rwx\nosd.0\n        key: AQD3+i1j5IJQCxAAOjQdvckg8TskXu7c4MbPAA==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.1\n        key: AQAo7C1j+dEDEBAAAA47bD+nZQZuV4kJjnqACA==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.2\n        key: AQA77C1j5ot+DhAAJ+Y1KwgI2zsxRHmTUkfing==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.3\n        key: AQBM7C1jdIuHEhAAYBA9gzC4J+kZUxkMzhjq4g==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.4\n        key: AQBq7C1jZrNZKhAAK+TvnPgK0jAWIwz0PYFT/g==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.5\n        key: AQB57C1jVcczERAAxJ3iqvKS/2kfE4HlFQHIWQ==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.6\n        key: AQCP7C1jB80KGhAA9iXzAg+9ANWjgPb2ZdWdhw==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.7\n        key: AQCe7C1jbx4rNxAANOB3PPLxRXi/st1UYiTWqQ==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.8\n        key: AQCz7C1jUGzQIhAAj6aTVM6rNsTO3Lp08rePzg==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nosd.9\n        key: AQDA7C1jwXTrEBAATszxwOKepUHzZ5WKwIMu7w==\n        caps: [mgr] allow profile osd\n        caps: [mon] allow profile osd\n        caps: [osd] allow *\nclient.admin\n        key: AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps: [mds] allow *\n        caps: [mgr] allow *\n        caps: [mon] allow *\n        caps: [osd] allow *\nclient.bootstrap-mds\n        key: AQB94C1jRPwjJhAAZsfgne6whasyCmSCgefocw==\n        caps: [mon] allow profile bootstrap-mds\nclient.bootstrap-mgr\n        key: AQB94C1jvQQkJhAA9y2LmEvBTG0Mjew8k0ecdw==\n        caps: [mon] allow profile bootstrap-mgr\nclient.bootstrap-osd\n        key: AQB94C1jDg4kJhAAhQPCebi6JfF9HZo4q39WGA==\n        caps: [mon] allow profile bootstrap-osd\nclient.bootstrap-rbd\n        key: AQB94C1jkxYkJhAAEUjId8hdDCA67PX+SQXAYw==\n        caps: [mon] allow profile bootstrap-rbd\nclient.bootstrap-rgw\n        key: AQB94C1jPx4kJhAAXIwArGEkQ76tQG1NnJ0Wmw==\n        caps: [mon] allow profile bootstrap-rgw\nclient.rgw.ceph-mon01\n        key: AQD0zS9jI7e4BRAA7fvC/02D6j2YoGHZwveQCQ==\n        caps: [mon] allow rw\n        caps: [osd] allow rwx\nmgr.ceph-mgr01\n        key: AQDi5S1jgpYLHRAAWHJeiwwD86AVg0YzUOPCmQ==\n        caps: [mds] allow *\n        caps: [mon] allow profile mgr\n        caps: [osd] allow *\nmgr.ceph-mgr02\n        key: AQDk5S1jY6tkBhAAXPIK4N+bia3W6IoqlJRehw==\n        caps: [mds] allow *\n        caps: [mon] allow profile mgr\n        caps: [osd] allow *\nmgr.ceph-mon01\n        key: AQDD9C1ja0vhOBAAnUkp5RcLBkZl8qfb4qXXLw==\n        caps: [mds] allow *\n        caps: [mon] allow profile mgr\n        caps: [osd] allow *\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：该命令是列出集群上所有用户信息，即非人为用户和普通用户；也可以是ceph auth ls命令来列出所有用户信息；</p> \n<p>　　检索特定用户命令格式：ceph auth get TYPE.ID或者ceph auth export TYPE.ID</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth get client.admin\nexported keyring for client.admin\n[client.admin]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow *\"\n        caps osd = \"allow *\"\n[root@ceph-admin ~]# ceph auth export client.admin\nexport auth(auid = 18446744073709551615 key=AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA== with 4 caps)\n[client.admin]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow *\"\n        caps osd = \"allow *\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：如果我们需要将上述信息导出到文件，可以使用-o来指定文件，或者输出重定向到方式；</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth get client.admin -o client.admin.keyring\nexported keyring for client.admin\n[root@ceph-admin ~]# ls\nceph-deploy-ceph.log  client.admin.keyring\n[root@ceph-admin ~]# cat client.admin.keyring\n[client.admin]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow *\"\n        caps osd = \"allow *\"\n[root@ceph-admin ~]# ceph auth export client.admin &gt; client.admin.cluster.keyring\nexport auth(auid = 18446744073709551615 key=AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA== with 4 caps)\n[root@ceph-admin ~]# ls\nceph-deploy-ceph.log  client.admin.cluster.keyring  client.admin.keyring\n[root@ceph-admin ~]# cat client.admin.cluster.keyring\n[client.admin]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow *\"\n        caps osd = \"allow *\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　添加用户命令格式：auth add &lt;entity&gt; {&lt;caps&gt; [&lt;caps&gt;...]}</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth add client.testuser mon \'allow r\' osd \'allow rw\'\nadded key for client.testuser\n[root@ceph-admin ~]# ceph auth get client.testuser\nexported keyring for client.testuser\n[client.testuser]\n        key = AQAoaThjCJLsBhAA8gwl/UQkjjSF+DwB6oB/wg==\n        caps mon = \"allow r\"\n        caps osd = \"allow rw\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：ceph add 是添加用户的规范方法，它能够创建用户、生成密钥并添加指定的caps；这里需要注意我指定的用户是有type.id组成，一般普通用户都是client类型，后面的ID就是用户名称；</p> \n<p>　　ceph auth get-or-create：简便方法，创建用户并返回密钥文件格式的密钥信息，或者在用户存在时返回用户名及密钥文件格式的密钥信息；</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth get-or-create client.testuser mon \'allow *\' osd \'allow rw pool=rbdpool\'\nError EINVAL: key for client.testuser exists but cap mon does not match\n[root@ceph-admin ~]# ceph auth get-or-create client.testuser mon \'allow r\' osd \'allow rw\'       [client.testuser]\n        key = AQAoaThjCJLsBhAA8gwl/UQkjjSF+DwB6oB/wg==\n[root@ceph-admin ~]# ceph auth get-or-create client.tom mon \'allow *\' osd \'allow rw pool=rbdpool\'\n[client.tom]\n        key = AQBcajhj8INfChAAKKFCESxmbHFJqAwiRE4ufg==\n[root@ceph-admin ~]#  ceph auth get client.tom\nexported keyring for client.tom\n[client.tom]\n        key = AQBcajhj8INfChAAKKFCESxmbHFJqAwiRE4ufg==\n        caps mon = \"allow *\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]#\n</pre> \n</div> \n<p>　　提示：使用ceph auth get-or-create命令添加用户，如果用户存在，但授权不匹配，它会提示我们用户存在，但是权限不匹配；如果用户存在，权限信息也都匹配，则返回对应用户的key；如果用户不存在，则创建对应用并返回用户的key；</p> \n<p>　　ceph auth get-or-create-key：简便方法，创建用户并返回密钥信息，或者在用户存在时返回密钥信息；</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth get-or-create-key client.testuser mon \'allow r\' osd \'allow *\' \nError EINVAL: key for client.testuser exists but cap osd does not match\n[root@ceph-admin ~]# ceph auth get-or-create-key client.testuser mon \'allow r\' osd \'allow rw\'\nAQAoaThjCJLsBhAA8gwl/UQkjjSF+DwB6oB/wg==\n[root@ceph-admin ~]# ceph auth get-or-create-key client.jerry mon \'allow r\' osd \'allow rw\'        \nAQDDazhjLbMTIhAADsXyBkPS079vU7dqGs2E+A==\n[root@ceph-admin ~]# ceph auth get client.jerry\nexported keyring for client.jerry\n[client.jerry]\n        key = AQDDazhjLbMTIhAADsXyBkPS079vU7dqGs2E+A==\n        caps mon = \"allow r\"\n        caps osd = \"allow rw\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：该命令和上面的get-or-create类似，都是用户存在，如果权限匹配则返回对应用户的key，如果不匹配则告诉我们用户存在，但权限不匹配；如果不存在则创建，并返回对应用户的key；不同的是返回key的格式不同；get-or-create是返回keyring文件中的格式；而get-or-create-key则返回key的值，没有key = ；</p> \n<p>　　注意：典型的用户至少对 Ceph monitor 具有读取功能，并对 Ceph OSD 具有读取和写入功能；另外，用户的 OSD 权限通常应该限制为只能访问特定的存储池，否则，他将具有访问集群中所有存储池的权限；</p> \n<p>　　列出用户的密钥格式&nbsp;命令：ceph auth print-key TYPE.ID</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth print-key client.jerry\nAQDDazhjLbMTIhAADsXyBkPS079vU7dqGs2E+A==[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　导入用户命令：ceph auth import</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ll\ntotal 16\n-rw-r--r-- 1 root root 1568 Sep 25 11:40 ceph-deploy-ceph.log\n-rw-r--r-- 1 root root  151 Oct  2 00:14 client.admin.cluster.keyring\n-rw-r--r-- 1 root root  151 Oct  2 00:14 client.admin.keyring\n-rw-r--r-- 1 root root  164 Oct  2 00:43 client.test.keyring\n[root@ceph-admin ~]# cat client.test.keyring \n[client.test]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow r\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# ceph auth get client.test\nError ENOENT: failed to find client.test in keyring\n[root@ceph-admin ~]# ceph auth import -i client.test.keyring\nimported keyring\n[root@ceph-admin ~]# ceph auth get client.test              \nexported keyring for client.test\n[client.test]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow r\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：从keyring文件导入用户需要用到-i选项来指定对应导入的keyring文件；</p> \n<p>　　修改用户caps命令：ceph auth caps TYPE.ID daemon \'allow [r|w|x|*|...] [pool=pool-name]&nbsp;[namespace=namespace-name]\' ...</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth get client.test\nexported keyring for client.test\n[client.test]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow r\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# ceph auth caps client.test mds \'allow rw\' mgr \'allow r\' mon \'allow rw\'   \nupdated caps for client.test\n[root@ceph-admin ~]# ceph auth get client.test\nexported keyring for client.test\n[client.test]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow rw\"\n        caps mgr = \"allow r\"\n        caps mon = \"allow rw\"\n[root@ceph-admin ~]# ceph auth caps client.test mds \'allow rw\' mgr \'allow r\' mon \'allow rw\' osd \'allow rw pool=rbdpool\'\nupdated caps for client.test\n[root@ceph-admin ~]# ceph auth get client.test\nexported keyring for client.test\n[client.test]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow rw\"\n        caps mgr = \"allow r\"\n        caps mon = \"allow rw\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：该命令会覆盖用户现有权限因此建立事先使用ceph auth get TYPE.ID命令查看用户的caps；若是为添加caps，则需要先指定现有的caps；若为删除某些权限，则对应权限不指定即可；</p> \n<p>　　删除用户命令：ceph auth del TYPE.ID</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth del client.test\nupdated\n[root@ceph-admin ~]# ceph auth del client.tom\nupdated\n[root@ceph-admin ~]# ceph auth del client.jerry\nupdated\n[root@ceph-admin ~]# ceph auth del client.testuser\nupdated\n[root@ceph-admin ~]# ceph auth get client.testuser\nError ENOENT: failed to find client.testuser in keyring\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　Keyring</p> \n<p>　　客户端访问Ceph集群时，客户端会于本地查找密钥环，&nbsp;默认情况下，Ceph会使用以下四个密钥环名称预设密钥环；</p> \n<p>　　• /etc/ceph/cluster-name.user-name.keyring：保存单个用户的keyring<br>　　• /etc/ceph/cluster.keyring：保存多个用户的keyring<br>　　• /etc/ceph/keyring<br>　　• /etc/ceph/keyring.bin</p> \n<p>　　cluster-name是为集群名称，user-name是为用户标识（TYPE.ID），&nbsp;client.admin用户的在名为ceph的集群上的密钥环文件名为ceph.client.admin.keyring；</p> \n<p>　　管理keyring</p> \n<p>　　创建keyring命令：ceph-authtool --create-keyring /path/to/kerying</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph-authtool --create-keyring ./client.abc.keyring\ncreating ./client.abc.keyring\n[root@ceph-admin ~]# cat ./client.abc.keyring\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：创建keyring文件，里面没有任何内容，我们需要用ceph auth add 添加用户，然后通过ceph auth get或export命令将对应用户信息导入到对应keyring文件即可；这里说一下keyring文件的命名规则，keyring文件一般应该保存于/etc/ceph目录中，以便客户端能自动查找；创建包含多个用户的keyring文件时，应该使用cluster-name.keyring作为文件名；创建仅包含单个用户的kerying文件时，应该使用cluster-name.user-name.keyring作为文件名；这个是规范的keyring命名方式；</p> \n<p>　　将用户的keyring合并至一个统一的keyring文件中命令：ceph-authtool /etc/ceph/cluster-name.keyring --import-key /etc/ceph/cluster-name.user-name.keyring</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ll\ntotal 16\n-rw-r--r-- 1 root root 1568 Sep 25 11:40 ceph-deploy-ceph.log\n-rw------- 1 root root    0 Oct  2 00:57 client.abc.keyring\n-rw-r--r-- 1 root root  151 Oct  2 00:14 client.admin.cluster.keyring\n-rw-r--r-- 1 root root  151 Oct  2 00:14 client.admin.keyring\n-rw-r--r-- 1 root root  164 Oct  2 00:43 client.test.keyring\n[root@ceph-admin ~]# cat client.test.keyring                                    \n[client.test]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow r\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# ceph-authtool ./client.test.keyring --import-keyring ./client.admin.keyring  \nimporting contents of ./client.admin.keyring into ./client.test.keyring\n[root@ceph-admin ~]# cat client.test.keyring   \n[client.admin]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow *\"\n        caps osd = \"allow *\"\n[client.test]\n        key = AQB94C1jTO8jJhAAY4Zhy40wduyIONnRqxtkEA==\n        caps mds = \"allow *\"\n        caps mgr = \"allow *\"\n        caps mon = \"allow r\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　使用ceph-authtool命令管理用户</p> \n<p>　　ceph-authtool命令可直接创建用户、授予caps并创建keyring</p> \n<p>　　命令使用帮助</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph-authtool -h\nusage: ceph-authtool keyringfile [OPTIONS]...\nwhere the options are:\n  -l, --list                    will list all keys and capabilities present in\n                                the keyring\n  -p, --print-key               will print an encoded key for the specified\n                                entityname. This is suitable for the\n                                \'mount -o secret=..\' argument\n  -C, --create-keyring          will create a new keyring, overwriting any\n                                existing keyringfile\n  -g, --gen-key                 will generate a new secret key for the\n                                specified entityname\n  --gen-print-key               will generate a new secret key without set it\n                                to the keyringfile, prints the secret to stdout\n  --import-keyring FILE         will import the content of a given keyring\n                                into the keyringfile\n  -n NAME, --name NAME          specify entityname to operate on\n  -u AUID, --set-uid AUID       sets the auid (authenticated user id) for the\n                                specified entityname\n  -a BASE64, --add-key BASE64   will add an encoded key to the keyring\n  --cap SUBSYSTEM CAPABILITY    will set the capability for given subsystem\n  --caps CAPSFILE               will set all of capabilities associated with a\n                                given key, for all subsystems\n  --mode MODE                   will set the desired file mode to the keyring\n                                e.g: \'0644\', defaults to \'0600\'\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：-l或--list表示列出所有用户信息；-p表示打印对应用户的key信息，-C表示keyring文件，-g表示给指定用户生成key；-n用于指定用户名称；--cap 用于指定权限信息；--mode用于指定keyring文件的权限信息，默认是0600，即只有root或对应宿主拥有读写权限；</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph-authtool -C client.usera.keyring  -n client.usera --gen-key --cap mon \'allow r\' --cap osd \'allow rw pool=rbdpool\'\ncreating client.usera.keyring\n[root@ceph-admin ~]# ll\ntotal 20\n-rw-r--r-- 1 root root 1568 Sep 25 11:40 ceph-deploy-ceph.log\n-rw------- 1 root root    0 Oct  2 00:57 client.abc.keyring\n-rw-r--r-- 1 root root  151 Oct  2 00:14 client.admin.cluster.keyring\n-rw-r--r-- 1 root root  151 Oct  2 00:14 client.admin.keyring\n-rw-r--r-- 1 root root  315 Oct  2 01:03 client.test.keyring\n-rw------- 1 root root  121 Oct  2 01:25 client.usera.keyring\n[root@ceph-admin ~]# ceph auth get client.usera\nError ENOENT: failed to find client.usera in keyring\n[root@ceph-admin ~]# cat client.usera.keyring \n[client.usera]\n        key = AQAIeDhjTnmLGhAAWgL3GqtJsPwmOD6CPbJO8Q==\n        caps mon = \"allow r\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：使用这种方式添加用户，对应信息之存在于keyring文件中，并没有存在ceph集群，我们还需要将对应keyring文件中的用户信息导入到集群上；</p> \n<div class=\"cnblogs_Highlighter\"> \n <pre class=\"brush:bash;gutter:true;\">[root@ceph-admin ~]# ceph auth add client.usera -i client.usera.keyring \nadded key for client.usera\n[root@ceph-admin ~]# ceph auth get client.usera\nexported keyring for client.usera\n[client.usera]\n        key = AQAIeDhjTnmLGhAAWgL3GqtJsPwmOD6CPbJO8Q==\n        caps mon = \"allow r\"\n        caps osd = \"allow rw pool=rbdpool\"\n[root@ceph-admin ~]# \n</pre> \n</div> \n<p>　　提示：上述命令等同ceph auth import；</p>',100,NULL,0,'https://www.cnblogs.com/qiuhom-1874/p/16748149.html','2022-10-07 15:01:45'),(30,'Springboot 之 Filter 实现 Gzip 压缩超大 json 对象',NULL,NULL,0,0,'<h3 id=\"简介\">简介</h3> \n<p>在项目中，存在传递超大 json 数据的场景。直接传输超大 json 数据的话，有以下两个弊端</p> \n<ul> \n <li> <p>占用网络带宽，而有些云产品就是按照带宽来计费的，间接浪费了钱</p> </li> \n <li> <p>传输数据大导致网络传输耗时较长<br> 为了避免直接传输超大 json 数据，可以对 json 数据进行 Gzip 压缩后，再进行网络传输。</p> </li> \n <li> <p>请求头添加 Content-Encoding 标识，传输的数据进行过压缩</p> </li> \n <li> <p>Servlet Filter 拦截请求，对压缩过的数据进行解压</p> </li> \n <li> <p>HttpServletRequestWrapper 包装，把解压的数据写入请求体</p> </li> \n</ul> \n<h3 id=\"pomxml-引入依赖\">pom.xml 引入依赖</h3> \n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n	&lt;groupId&gt;com.olive&lt;/groupId&gt;\n	&lt;artifactId&gt;request-uncompression&lt;/artifactId&gt;\n	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n	&lt;packaging&gt;jar&lt;/packaging&gt;\n\n	&lt;name&gt;request-uncompression&lt;/name&gt;\n	&lt;url&gt;http://maven.apache.org&lt;/url&gt;\n\n	&lt;parent&gt;\n		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n		&lt;version&gt;2.5.14&lt;/version&gt;\n		&lt;relativePath /&gt; &lt;!-- lookup parent from repository --&gt;\n	&lt;/parent&gt;\n\n	&lt;properties&gt;\n		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n		&lt;maven.compiler.source&gt;8&lt;/maven.compiler.source&gt;\n		&lt;maven.compiler.target&gt;8&lt;/maven.compiler.target&gt;\n	&lt;/properties&gt;\n\n	&lt;dependencies&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n			&lt;scope&gt;test&lt;/scope&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n			&lt;artifactId&gt;lombok&lt;/artifactId&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n		    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n		    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;com.alibaba.fastjson2&lt;/groupId&gt;\n			&lt;artifactId&gt;fastjson2&lt;/artifactId&gt;\n			&lt;version&gt;2.0.14&lt;/version&gt;\n		&lt;/dependency&gt;\n    &lt;dependency&gt;\n			&lt;groupId&gt;commons-io&lt;/groupId&gt;\n			&lt;artifactId&gt;commons-io&lt;/artifactId&gt;\n			&lt;version&gt;2.9.0&lt;/version&gt;\n		&lt;/dependency&gt;\n	&lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre> \n<h3 id=\"创建压缩工具类\">创建压缩工具类</h3> \n<p>GzipUtils 类提供压缩解压相关方法</p> \n<pre><code>package com.olive.utils;\n\nimport com.alibaba.fastjson2.JSON;\nimport com.olive.vo.ArticleRequestVO;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.*;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\n@Slf4j\npublic class GzipUtils {\n\n    private static final String GZIP_ENCODE_UTF_8 = \"UTF-8\";\n\n    /**\n     * 字符串压缩为GZIP字节数组\n     *\n     * @param str\n     * @return\n     */\n    public static byte[] compress(String str) {\n        return compress(str, GZIP_ENCODE_UTF_8);\n    }\n\n    /**\n     * 字符串压缩为GZIP字节数组\n     *\n     * @param str\n     * @param encoding\n     * @return\n     */\n    public static byte[] compress(String str, String encoding) {\n        if (str == null || str.length() == 0) {\n            return null;\n        }\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        GZIPOutputStream gzip = null;\n        try {\n            gzip = new GZIPOutputStream(out);\n            gzip.write(str.getBytes(encoding));\n        } catch (IOException e) {\n           log.error(\"compress&gt;&gt;\", e);\n        }finally {\n            if(gzip!=null){\n                try {\n                    gzip.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return out.toByteArray();\n    }\n\n    /**\n     * GZIP解压缩\n     *\n     * @param bytes\n     * @return\n     */\n    public static byte[] uncompress(byte[] bytes) {\n        if (bytes == null || bytes.length == 0) {\n            return null;\n        }\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n        GZIPInputStream unGzip = null;\n        try {\n            unGzip = new GZIPInputStream(in);\n            byte[] buffer = new byte[256];\n            int n;\n            while ((n = unGzip.read(buffer)) &gt;= 0) {\n                out.write(buffer, 0, n);\n            }\n        } catch (IOException e) {\n            log.error(\"uncompress&gt;&gt;\", e);\n        }finally {\n            if(unGzip!=null){\n                try {\n                    unGzip.close();\n                } catch (IOException e) {\n                }\n            }\n        }\n        return out.toByteArray();\n    }\n\n    /**\n     * 解压并返回String\n     *\n     * @param bytes\n     * @return\n     */\n    public static String uncompressToString(byte[] bytes) throws IOException {\n        return uncompressToString(bytes, GZIP_ENCODE_UTF_8);\n    }\n\n    /**\n     * @param bytes\n     * @return\n     */\n    public static byte[] uncompressToByteArray(byte[] bytes) throws IOException {\n        return uncompressToByteArray(bytes, GZIP_ENCODE_UTF_8);\n    }\n\n    /**\n     * 解压成字符串\n     *\n     * @param bytes    压缩后的字节数组\n     * @param encoding 编码方式\n     * @return 解压后的字符串\n     */\n    public static String uncompressToString(byte[] bytes, String encoding) throws IOException {\n        byte[] result = uncompressToByteArray(bytes, encoding);\n        return new String(result);\n    }\n\n    /**\n     * 解压成字节数组\n     *\n     * @param bytes\n     * @param encoding\n     * @return\n     */\n    public static byte[] uncompressToByteArray(byte[] bytes, String encoding) throws IOException {\n        if (bytes == null || bytes.length == 0) {\n            return null;\n        }\n        ByteArrayOutputStream out = new ByteArrayOutputStream();\n        ByteArrayInputStream in = new ByteArrayInputStream(bytes);\n        GZIPInputStream unGzip = null;\n        try {\n            unGzip = new GZIPInputStream(in);\n            byte[] buffer = new byte[256];\n            int n;\n            while ((n = unGzip.read(buffer)) &gt;= 0) {\n                out.write(buffer, 0, n);\n            }\n            return out.toByteArray();\n        } catch (IOException e) {\n            log.error(\"uncompressToByteArray&gt;&gt;\", e);\n            throw new IOException(\"解压缩失败！\");\n        }finally {\n            if(unGzip!=null){\n                unGzip.close();\n            }\n        }\n    }\n\n    /**\n     * 将字节流转换成文件\n     *\n     * @param filename\n     * @param data\n     * @throws Exception\n     */\n    public static void saveFile(String filename, byte[] data) throws Exception {\n        FileOutputStream fos = null;\n        try {\n            if (data != null) {\n                String filepath = \"/\" + filename;\n                File file = new File(filepath);\n                if (file.exists()) {\n                    file.delete();\n                }\n                fos = new FileOutputStream(file);\n                fos.write(data, 0, data.length);\n                fos.flush();\n                System.out.println(file);\n            }\n        }catch (Exception e){\n            throw e;\n        }finally {\n            if(fos!=null){\n                fos.close();\n            }\n        }\n    }\n\n}\n</code></pre> \n<h3 id=\"对request进行包装\">对Request进行包装</h3> \n<p>UnZipRequestWrapper 读取输入流，然进行解压；解压完后，再把解压出来的数据封装到输入流中。</p> \n<pre><code>package com.olive.filter;\n\nimport com.olive.utils.GzipUtils;\nimport lombok.extern.slf4j.Slf4j;\n\nimport javax.servlet.ReadListener;\nimport javax.servlet.ServletInputStream;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.io.*;\n\n/**\n *  Json String 经过压缩后保存为二进制文件 -&gt; 解压缩后还原成 Jso nString转换成byte[]写回body中\n */\n@Slf4j\npublic class UnZipRequestWrapper extends HttpServletRequestWrapper {\n\n    private final byte[] bytes;\n\n    public UnZipRequestWrapper(HttpServletRequest request) throws IOException {\n        super(request);\n        try (BufferedInputStream bis = new BufferedInputStream(request.getInputStream());\n             ByteArrayOutputStream baos = new ByteArrayOutputStream()) {\n            final byte[] body;\n            byte[] buffer = new byte[1024];\n            int len;\n            while ((len = bis.read(buffer)) &gt; 0) {\n                baos.write(buffer, 0, len);\n            }\n            body = baos.toByteArray();\n            if (body.length == 0) {\n                log.info(\"Body无内容，无需解压\");\n                bytes = body;\n                return;\n            }\n            this.bytes = GzipUtils.uncompressToByteArray(body);\n        } catch (IOException ex) {\n            log.error(\"解压缩步骤发生异常！\", ex);\n            throw ex;\n        }\n    }\n\n    @Override\n    public ServletInputStream getInputStream() throws IOException {\n        final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(bytes);\n        return new ServletInputStream() {\n\n            @Override\n            public boolean isFinished() {\n                return false;\n            }\n\n            @Override\n            public boolean isReady() {\n                return false;\n            }\n\n            @Override\n            public void setReadListener(ReadListener readListener) {\n\n            }\n\n            public int read() throws IOException {\n                return byteArrayInputStream.read();\n            }\n        };\n    }\n\n    @Override\n    public BufferedReader getReader() throws IOException {\n        return new BufferedReader(new InputStreamReader(this.getInputStream()));\n    }\n\n}\n</code></pre> \n<h3 id=\"定义gzipfilter对请求进行拦截\">定义GzipFilter对请求进行拦截</h3> \n<p>GzipFilter 拦截器根据请求头是否包含<code>Content-Encoding=application/gzip</code>，如果包含就对数据进行解压；否则就直接放过。</p> \n<pre><code>package com.olive.filter;\n\nimport lombok.extern.slf4j.Slf4j;\nimport org.springframework.stereotype.Component;\n\nimport javax.servlet.*;\nimport javax.servlet.http.HttpServletRequest;\nimport java.io.IOException;\n\n/**\n * 解压filter\n */\n@Slf4j\n@Component\npublic class GzipFilter implements Filter {\n\n    private static final String CONTENT_ENCODING = \"Content-Encoding\";\n\n    private static final String CONTENT_ENCODING_TYPE = \"application/gzip\";\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        log.info(\"init GzipFilter\");\n    }\n\n    @Override\n    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {\n        long start = System.currentTimeMillis();\n        HttpServletRequest httpServletRequest = (HttpServletRequest)request;\n        String encodeType = httpServletRequest.getHeader(CONTENT_ENCODING);\n        if (encodeType!=null &amp;&amp; CONTENT_ENCODING_TYPE.equals(encodeType)) {\n            log.info(\"请求:{} 需要解压\", httpServletRequest.getRequestURI());\n            UnZipRequestWrapper unZipRequest = new UnZipRequestWrapper(httpServletRequest);\n            chain.doFilter(unZipRequest, response);\n        }else {\n            log.info(\"请求:{} 无需解压\", httpServletRequest.getRequestURI());\n            chain.doFilter(request,response);\n        }\n        log.info(\"耗时：{}ms\", System.currentTimeMillis() - start);\n    }\n\n    @Override\n    public void destroy() {\n        log.info(\"destroy GzipFilter\");\n    }\n}\n</code></pre> \n<h3 id=\"注册-gzipfilter-拦截器\">注册 GzipFilter 拦截器</h3> \n<pre><code>package com.olive.config;\n\n\nimport com.olive.filter.GzipFilter;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n/**\n * 注册filter\n */\n@Configuration\npublic class FilterRegistration {\n\n    @Autowired\n    private GzipFilter gzipFilter;\n\n    @Bean\n    public FilterRegistrationBean&lt;GzipFilter&gt; gzipFilterRegistrationBean() {\n        FilterRegistrationBean&lt;GzipFilter&gt; registration = new FilterRegistrationBean&lt;&gt;();\n        //Filter可以new，也可以使用依赖注入Bean\n        registration.setFilter(gzipFilter);\n        //过滤器名称\n        registration.setName(\"gzipFilter\");\n        //拦截路径\n        registration.addUrlPatterns(\"/*\");\n        //设置顺序\n        registration.setOrder(1);\n        return registration;\n    }\n}\n</code></pre> \n<h3 id=\"定义-controller\">定义 Controller</h3> \n<p>该 Controller 非常简单，主要是输入请求的数据</p> \n<pre><code>package com.olive.controller;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport com.alibaba.fastjson2.JSON;\nimport com.olive.vo.ArticleRequestVO;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class TestController {\n\n	@RequestMapping(\"/getArticle\")\n	public Map&lt;String, Object&gt; getArticle(@RequestBody ArticleRequestVO articleRequestVO){\n		Map&lt;String, Object&gt; result = new HashMap&lt;&gt;();\n		result.put(\"code\", 200);\n		result.put(\"msg\", \"success\");\n		System.out.println(JSON.toJSONString(articleRequestVO));\n		return result;\n	}\n\n}\n</code></pre> \n<p>Controller 参数接收VO</p> \n<pre><code>package com.olive.vo;\n\nimport lombok.Data;\n\nimport java.io.Serializable;\n\n@Data\npublic class ArticleRequestVO implements Serializable {\n\n    private Long id;\n\n    private String title;\n\n    private String content;\n\n}\n</code></pre> \n<h3 id=\"定义-springboot-引导类\">定义 Springboot 引导类</h3> \n<pre><code>package com.olive;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class);\n    }\n\n}\n</code></pre> \n<h3 id=\"测试\">测试</h3> \n<ul> \n <li>非压缩请求测试</li> \n</ul> \n<pre><code>curl -X POST \\\n  http://127.0.0.1:8080/getArticle \\\n  -H \'content-type: application/json\' \\\n  -d \'{\n	\"id\":1,\n	\"title\": \"java乐园\",\n	\"content\":\"xxxxxxxxxx\"\n}\'\n</code></pre> \n<ul> \n <li>压缩请求测试</li> \n</ul> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/d9af5e75-e978-4806-ac50-f9aba4a6df61.png\" alt=\"\" loading=\"lazy\"></p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/5156e36b-ae5c-48b8-a86d-dc770799e377.png\" alt=\"\" loading=\"lazy\"></p> \n<p>不要直接将压缩后的 byte[] 数组当作字符串进行传输，否则压缩后的请求数据比没压缩后的还要大得多！<br> 项目中一般采用以下两种传输压缩后的 byte[] 的方式：</p> \n<ul> \n <li>将压缩后的 byet[] 进行 Base64 编码再传输字符串，这种方式会损失掉一部分 GZIP 的压缩效果，适用于压缩结果要存储在 Redis 中的情况</li> \n <li>将压缩后的 byte[] 以二进制的形式写入到文件中，请求时直接在 body 中带上文件即可，用这种方式可以不损失压缩效果</li> \n</ul> \n<p>小编测试采用第二种方式，采用以下代码把原始数据进行压缩</p> \n<pre><code>public static void main(String[] args) {\n      ArticleRequestVO vo = new ArticleRequestVO();\n      vo.setId(1L);\n      vo.setTitle(\"bug弄潮儿\");\n      try {\n          byte[] bytes = FileUtils.readFileToByteArray(new File(\"C:\\\\Users\\\\2230\\\\Desktop\\\\凯平项目资料\\\\改装车项目\\\\CXSSBOOT_DB_DDL-1.0.9.sql\"));\n          vo.setContent(new String(bytes));\n          byte[] dataBytes = compress(JSON.toJSONString(vo));\n          saveFile(\"d:/vo.txt\", dataBytes);\n      } catch (Exception e) {\n          e.printStackTrace();\n      }\n  }\n</code></pre> \n<p>压缩后数据存储到<code>d:/vo.txt</code>，然后在 postman 中安装下图选择</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/aef5d231-08ac-45c0-8332-aff6c23177ac.png\" alt=\"\" loading=\"lazy\"></p>',100,NULL,0,'https://www.cnblogs.com/happyhuangjinjin/p/16759500.html','2022-10-07 15:01:52'),(31,'手把手教你做一个天猫精灵（五、尝试抓取智能家居数据）','之前的章节讲了利用fubuki-iot做了一个智能终端，但是苦于没有良好的开源生态所以只停留在DIY阶段。本章介绍一种获取智能家居数据的方式，有条件的可以尝试一下。硬件准备路由器（需要带镜像功能）RJ45（水晶头）数据线搭建环境首先在连接路由器WiFi的环境下登陆路由器控制端，一般是192.168开头的网页，','2022-10-07 19:15:33',0,0,'<blockquote><p>之前的章节讲了利用fubuki-iot做了一个智能终端，但是苦于没有良好的开源生态所以只停留在DIY阶段。本章介绍一种获取智能家居数据的方式，有条件的可以尝试一下。</p></blockquote><h1 id=\"硬件准备\">硬件准备</h1><ul class=\" list-paddingleft-2\"><li><p>路由器（需要带镜像功能）</p></li><li><p>RJ45（水晶头）数据线</p></li></ul><h1 id=\"搭建环境\">搭建环境</h1><p>首先在连接路由器WiFi的环境下登陆路由器控制端，一般是192.168开头的网页，选择高级配置，打开镜像开关。</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/6cd67422-1b40-4805-9976-679fe7996d6b.jpeg\" alt=\"路由器终端\" loading=\"lazy\"/></p><p>源端口默认，这样可以镜像所有接入设备的流量。输出端口选择LAN1，这样通过RJ45数据线将路由器的LAN1端口于电脑相连，就可以实现本地电脑网卡接收路由器的镜像数据了。</p><h1 id=\"抓包\">抓包</h1><p>既然要抓包，必不可少的工具就是Wireshark，点<a href=\"https://www.wireshark.org/download.html\" target=\"_blank\" rel=\"noopener\">这里</a>下载。按照步骤安装好以后选择抓取以太网的数据包，这时候应该可以看到抓取的结果了。</p><p>如果是TLS/SSL协议加密过的数据也可以通过以下步骤解密：</p><ul class=\" list-paddingleft-2\"><li><p>新建两个文件debug.log和key.txt</p></li><li><p>设置环境变量SSLKEYLOGFILE的值为debug.log的路径</p></li><li><p>配置Wireshark的TLS协议：点击“编辑”-“首选项”，选择“Protocols”-“TLS”，按下图填写对应的debug.log和key.txt的路径</p></li></ul><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/9012d673-1f2f-448f-8e5a-d229e90b7e1e.jpeg\" alt=\"tls编辑\" loading=\"lazy\"/></p><p>重启电脑，再打开Wireshark抓包就可以抓TLS/SSL加密之后的数据了。</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/e53a926f-45e1-44ca-b4df-c6d8a2fe68b4.jpeg\" alt=\"解密后数据\" loading=\"lazy\"/></p><p>Wireshark也能抓取MQTT协议的包，只要在过滤器中输入mqtt即可：</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/e78da6b8-b31a-4cc2-a860-27c7132c64ab.jpeg\" alt=\"mqtt\" loading=\"lazy\"/></p><p>然而并没有发现MQTT的数据包，然后登陆路由器终端，找到智能家居的IP，比如这个海尔洗衣机的IP是192.168.2.102：</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/6ee362f6-ee7e-4519-8500-62f19361d2b5.jpeg\" alt=\"海尔洗衣机\" loading=\"lazy\"/></p><p>然后在Wireshark过滤器中搜索对应的IP：</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/72060486-faf6-43c7-8b8a-6fdc7bff0f4f.jpeg\" alt=\"\" loading=\"lazy\"/></p><p>结果这个洗衣机是通过UDP协议传输的，而这个UDP协议的上层协议很有可能是厂家自己封装的协议。。</p><h1 id=\"思考\">思考</h1><p>目前物联网智能家居的生态还不是很开放。有能力的大厂家甚至都自己实现了智能语音功能，再加上市场竞争激烈，即使小厂家也不愿意将传输的数据分享给外部。所以当下环境真正实现万物联网还是很遥远的，赛博朋克的世界甚至更是遥不可及。我认为当前能够愿意联网的家居可能仅限于电灯、开关之类的小电器。因为它们本身没有科技创新点，而加入联网特性能成为它们的买点。因此以后可能会出一期有关蓝牙接入的文章。</p><blockquote><p>本章介绍了本地抓取智能家居数据包的一种方案，如果抓取到数据后也可以通过sniff等方法将流量复制给我们的MQTT服务器，从而实现我们对家居的智能控制。下一章将介绍一种软件接入MQTT的例子——将QQ接入物联网功能。</p></blockquote>',11,NULL,1,'https://www.cnblogs.com/littlebutt/p/16759111.html','2022-10-07 15:02:05'),(32,'.NET 开源项目推荐之 直播控制台解决方案 Macro Deck','流媒体是一个吸引数亿万玩家的严肃行业。 最受欢迎的游戏锦标赛的转播获得了数百万的观看次数，从商业角度来看，这也使游戏行业变得有趣。在直播圈有个很受欢迎的直播控制台程序Macro Deck， 它是基于Apache 2.0协议开源的.NET 应用。先给大家看几篇直播圈的非技术文章和视频：小爱触屏音箱实现 Stre','2022-10-07 19:05:48',0,0,'<p>流媒体是一个吸引数亿万玩家的严肃行业。 最受欢迎的游戏锦标赛的转播获得了数百万的观看次数，从商业角度来看，这也使游戏行业变得有趣。在直播圈有个很受欢迎的直播控制台程序Macro Deck， 它是基于Apache 2.0协议开源的.NET 应用。先给大家看几篇直播圈的非技术文章和视频：</p><ul class=\" list-paddingleft-2\"><li><p>小爱触屏音箱实现 Stream Deck 贫替： <a title=\"https://sspai.com/post/75789\" href=\"https://sspai.com/post/75789\" rel=\"noopener\">https://sspai.com/post/75789</a></p></li><li><p>Macro Deck 的正确使用教程方法： <a title=\"https://www.mrjeke.com/tutorials/367.html\" href=\"https://www.mrjeke.com/tutorials/367.html\" rel=\"noopener\">https://www.mrjeke.com/tutorials/367.html</a></p></li><li><p>“零”成本打造可视化直播、导播、可编程控制台—基于闲置机打造：<a title=\"https://www.bilibili.com/video/BV1ed4y1U7iF/\" href=\"https://www.bilibili.com/video/BV1ed4y1U7iF/\" rel=\"noopener\">https://www.bilibili.com/video/BV1ed4y1U7iF/</a>&nbsp;</p></li></ul><p><a href=\"https://img2022.cnblogs.com/blog/510/202210/510-20221007090650690-590997363.png\" rel=\"noopener\"><img width=\"612\" height=\"293\" title=\"image\" style=\"display: inline; background-image: none\" alt=\"image\" src=\"http://localhost:8080/static/blogImages/2022/10/07/b36cd6d2-4b6f-4466-8c72-073eebac981b.png\" border=\"0\"/></a></p><p>Macro Deck 允许您将任何 Android 手机或平板电脑变成 Stream Deck 的类似物。 在电脑上安装一个程序，连接到移动设备上，然后可以在上面显示各种热键组合。 Macro Deck 应用程序通过开发人员的官方网站免费分发。Macro Deck 的官方网站：<a title=\"https://macrodeck.org/\" href=\"https://macrodeck.org/\" rel=\"noopener\">https://macrodeck.org/</a> ，Github：<a title=\"https://github.com/Macro-Deck-org/Macro-Deck\" href=\"https://github.com/Macro-Deck-org/\" rel=\"noopener\">https://github.com/Macro-Deck-org/</a>。</p><p><a href=\"https://img2022.cnblogs.com/blog/510/202210/510-20221007090652167-570989146.png\" rel=\"noopener\"><img width=\"614\" height=\"279\" title=\"image\" style=\"display: inline; background-image: none\" alt=\"image\" src=\"http://localhost:8080/static/blogImages/2022/10/07/180359ef-4636-4eff-a5f9-a49bc2fe2b57.png\" border=\"0\"/></a></p><p>提供了Windows PC版本 和 Android 手机app，Windows PC版本采用的是.NET Core 3.1 下Winform + CefSharp ,项目地址是<a title=\"https://github.com/Macro-Deck-org/Macro-Deck/\" href=\"https://github.com/Macro-Deck-org/Macro-Deck/\" rel=\"noopener\">https://github.com/Macro-Deck-org/Macro-Deck/</a> , android 应用使用的是Xamarin.Android 开发的，项目地址：<a title=\"https://github.com/Macro-Deck-org/Macro-Deck-Client\" href=\"https://github.com/Macro-Deck-org/Macro-Deck-Client\" rel=\"noopener\">https://github.com/Macro-Deck-org/Macro-Deck-Client</a> 。同时它还提供了浏览器控制的Web版本 <a href=\"http://web.macrodeck.org/\" rel=\"noopener\">Macro Deck web client</a> ，项目地址： <a title=\"https://github.com/Macro-Deck-org/Macro-Deck-Web-Client\" href=\"https://github.com/Macro-Deck-org/Macro-Deck-Web-Client\" rel=\"noopener\">https://github.com/Macro-Deck-org/Macro-Deck-Web-Client</a>。</p><p>Macro Deck 采用了插件化的架构，插件商店项目地址：<a title=\"https://github.com/Macro-Deck-org/Macro-Deck-Extensions\" href=\"https://github.com/Macro-Deck-org/Macro-Deck-Extensions\" rel=\"noopener\">https://github.com/Macro-Deck-org/Macro-Deck-Extensions</a>，相关的插件代码都要合到这个仓库，采用了Sub Module方式组织：</p><p><a href=\"https://img2022.cnblogs.com/blog/510/202210/510-20221007090653380-970023970.png\" rel=\"noopener\"><img width=\"614\" height=\"452\" title=\"image\" style=\"display: inline; background-image: none\" alt=\"image\" src=\"http://localhost:8080/static/blogImages/2022/10/07/bd473e72-e96d-4744-b5a0-7b03e61903ab.png\" border=\"0\"/></a></p>',11,NULL,1,'https://www.cnblogs.com/shanyou/p/dotnet-oss-macro-deck.html','2022-10-07 15:02:12'),(34,'.NET下数据库的负载均衡(有趣实验)(续)',NULL,NULL,0,0,'<p><a href=\"https://www.cnblogs.com/dotnet-college/p/16724819.html\" target=\"_blank\" rel=\"noopener\">.NET下数据库的负载均衡(有趣实验)</a>这篇文章发表后，受到了众多读者的关注与好评，其中不乏元老级程序员。</p> \n<p>读者来信中询问最多的一个问题是：它是否能支持“异种数据库”的负载均衡？？</p> \n<p>&nbsp;</p> \n<p>今天就在此统一回复：能（暂时只能在.Net6版本下实现。.Net Framwork版本后续会再实现。）</p> \n<p>&nbsp;</p> \n<p>下面就举一例，给出实现“异种数据库”负载均衡的两种方法。</p> \n<p>首先，把配置负载均衡策略的ds.xml文件修改为多个异种数据库，如下：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">&lt;?</span><span style=\"color: rgba(255, 0, 255, 1)\">xml version=\"1.0\" encoding=\"utf-8\" </span><span style=\"color: rgba(0, 0, 255, 1)\">?&gt;</span>\n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">DeveloperSharp</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">DatabaseClusterList</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">DatabaseCluster </span><span style=\"color: rgba(255, 0, 0, 1)\">Id</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"StudentData\"</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">Database </span><span style=\"color: rgba(255, 0, 0, 1)\">Id</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"A1\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> Enable</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> Weight</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"100\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> DatabaseType</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"SqlServer\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> ConnectionString</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"Server=localhost;Database=YZZ;Uid=sa;Pwd=123\"</span><span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">Database </span><span style=\"color: rgba(255, 0, 0, 1)\">Id</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"A2\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> Enable</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> Weight</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"100\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> DatabaseType</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"MySql\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> ConnectionString</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"Host=localhost;Database=YZZ;User Id=root;password=123\"</span><span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n            <span style=\"color: rgba(0, 0, 255, 1)\">&lt;</span><span style=\"color: rgba(128, 0, 0, 1)\">Database </span><span style=\"color: rgba(255, 0, 0, 1)\">Id</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"A3\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> Enable</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"true\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> Weight</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"100\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> DatabaseType</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"PostgreSql\"</span><span style=\"color: rgba(255, 0, 0, 1)\"> ConnectionString</span><span style=\"color: rgba(0, 0, 255, 1)\">=\"Server=127.0.0.1;Database=YZZ;Port=5432;User Id=postgres;Password=123;\"</span><span style=\"color: rgba(0, 0, 255, 1)\">/&gt;</span>\n        <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">DatabaseCluster</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>\n    <span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">DatabaseClusterList</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span> \n<span style=\"color: rgba(0, 0, 255, 1)\">&lt;/</span><span style=\"color: rgba(128, 0, 0, 1)\">DeveloperSharp</span><span style=\"color: rgba(0, 0, 255, 1)\">&gt;</span>&nbsp;</pre> \n</div> \n<p>说明：以上配置了异种的Sql Server、MySql、PostgreSql三个数据库来做负载均衡。</p> \n<p>&nbsp;</p> \n<p>方法一：</p> \n<div class=\"cnblogs_code\"> \n <pre>SLB.IDA.ConnectionString <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">数据库链接字符串 </span>\nSLB.IDA.DatabaseType     <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">数据库类型</span></pre> \n</div> \n<p>无论你的数据库访问工具是Entity Framework、Dapper、SqlSugar、FreeSql、等等，只要有了如上两个参数，你就能自行实现相应的数据库操作。<br> <br>（注：看懂本文思路的前提，是你已经阅读过<a href=\"https://www.cnblogs.com/dotnet-college/p/16724819.html\" target=\"_blank\" rel=\"noopener\">.NET下数据库的负载均衡(有趣实验)</a>这篇文章）<br> </p> \n<p>&nbsp;</p> \n<p>方法二：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">var</span> IDA =<span style=\"color: rgba(0, 0, 0, 1)\"> SLB.IDA;\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">接下来，直接通过IDA进行各类数据库操作</span></pre> \n</div> \n<p>&nbsp;</p> \n<p>【示例1：查询】</p> \n<p>下面，首先直接给出一个“查询多数据+选出单数据+参数”的使用示例，代码如下：</p> \n<div class=\"cnblogs_code\"> \n <pre>   <span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">查询多数据</span>\n   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> Students1 = IDA.SqlExecute&lt;stu&gt;(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">select * from t_Student</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n\n   </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">查询多数据（带参数）</span>\n   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> IdMin = IDA.CreateParameterInput(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">IdMin</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>, DbType.Int32, <span style=\"color: rgba(128, 0, 128, 1)\">2</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n   </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> LikeName = IDA.CreateParameterInput(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">LikeName</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>, DbType.String, <span style=\"color: rgba(128, 0, 128, 1)\">50</span>, <span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">%周%</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n   </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> Students2 = IDA.SqlExecute&lt;stu&gt;(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">select * from t_Student where Id&gt;@IdMin and Name like @LikeName</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">, IdMin, LikeName);\n   </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">另一种写法</span>\n   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> Students3 = IDA.SqlExecute&lt;stu&gt;(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">select * from t_Student</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>).Where(t =&gt; t.Id &gt; <span style=\"color: rgba(128, 0, 128, 1)\">2</span> &amp;&amp; t.Name.Contains(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">周</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">));\n\n   </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">选出单数据</span>\n   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> OneStudent = Students2.FirstOrDefault();</pre> \n</div> \n<p>其中stu实体类代码如下形式：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">class</span><span style=\"color: rgba(0, 0, 0, 1)\"> stu\n{\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span> Id { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">string</span> Name { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n        </span><span style=\"color: rgba(0, 0, 255, 1)\">public</span> <span style=\"color: rgba(0, 0, 255, 1)\">int</span> Age { <span style=\"color: rgba(0, 0, 255, 1)\">get</span>; <span style=\"color: rgba(0, 0, 255, 1)\">set</span><span style=\"color: rgba(0, 0, 0, 1)\">; }\n}\n</span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">此实体类中的Id、Name、Age属性名，要与数据表中的Id、Name、Age字段名对应</span></pre> \n</div> \n<p>注意：创建参数时使用DbType类型，就是为了能在不同类型数据库（SqlServer、MySql、Oracle、等）之间透明切换！</p> \n<p>&nbsp;</p> \n<p>【示例2：分页】</p> \n<p>承接上面“示例1”的代码，若我们要对Students1、Students2进行分页操作（比如：每页20条，取出第5页），相关代码如下：</p> \n<div class=\"cnblogs_code\"> \n <pre><span style=\"color: rgba(0, 0, 255, 1)\">using</span> DeveloperSharp.Extension;<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">调用“分页功能”需要引用此命名空间</span>\n--------------------------\n\n   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> Page1 = Students1.PagePartition(<span style=\"color: rgba(128, 0, 128, 1)\">20</span>, <span style=\"color: rgba(128, 0, 128, 1)\">5</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n   </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> Page2 = Students2.PagePartition(<span style=\"color: rgba(128, 0, 128, 1)\">20</span>, <span style=\"color: rgba(128, 0, 128, 1)\">5</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n\n   </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">一气呵成的写法</span>\n   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> Page3 = IDA.SqlExecute&lt;stu&gt;(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">select * from t_Student</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>).PagePartition(<span style=\"color: rgba(128, 0, 128, 1)\">20</span>, <span style=\"color: rgba(128, 0, 128, 1)\">5</span>);</pre> \n</div> \n<p>&nbsp;</p> \n<p>【示例3：增/删/改】</p> \n<p>前面谈完“查询”，我们接下来谈谈“增/删/改”的使用方式，下面是一个“修改数据+参数+事务”的使用示例：</p> \n<div class=\"cnblogs_code\"> \n <pre>   <span style=\"color: rgba(0, 0, 255, 1)\">try</span><span style=\"color: rgba(0, 0, 0, 1)\">\n   {\n       </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">开启事务</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">       IDA.TransactionBegin();\n\n       </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">修改数据（多语句）</span>\n       <span style=\"color: rgba(0, 0, 255, 1)\">int</span> affectedRows1 = IDA.SqlExecute(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">insert into t_Student(Name,Age)values(\'ww\',\'96\');update t_Student set Age=100 where Id=1006</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n\n       </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">修改数据（带参数）</span>\n       <span style=\"color: rgba(0, 0, 255, 1)\">var</span> NewAge = IDA.CreateParameterInput(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">NewAge</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>, DbType.Int32, <span style=\"color: rgba(128, 0, 128, 1)\">200</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n       </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> NewName = IDA.CreateParameterInput(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">NewName</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>, DbType.String, <span style=\"color: rgba(128, 0, 128, 1)\">50</span>, <span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">孙悟空</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n       </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> affectedRows2 = IDA.SqlExecute(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">insert into t_Student(Name,Age)values(@NewName,@NewAge)</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">, NewName, NewAge);\n\n       </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">完成事务</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">       IDA.TransactionCommit();\n   }\n   </span><span style=\"color: rgba(0, 0, 255, 1)\">catch</span><span style=\"color: rgba(0, 0, 0, 1)\">\n   {\n       </span><span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">回滚事务</span>\n<span style=\"color: rgba(0, 0, 0, 1)\">       IDA.TransactionRollBack();\n   }</span></pre> \n</div> \n<p>&nbsp;</p> \n<p>【示例4：其它】</p> \n<p>最后，我们给出一个“聚合函数+输出参数”的使用示例，代码如下：</p> \n<div class=\"cnblogs_code\"> \n <pre>   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> IdMax = IDA.CreateParameterInput(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">IdMax</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>, DbType.Int32, <span style=\"color: rgba(128, 0, 128, 1)\">20</span><span style=\"color: rgba(0, 0, 0, 1)\">);\n   </span><span style=\"color: rgba(0, 0, 255, 1)\">var</span> TotalCount = IDA.CreateParameterOutput(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">TotalCount</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span>, DbType.Int32);<span style=\"color: rgba(0, 128, 0, 1)\">//</span><span style=\"color: rgba(0, 128, 0, 1)\">此项为输出参数</span>\n   <span style=\"color: rgba(0, 0, 255, 1)\">var</span> Students3 = IDA.SqlExecute&lt;stu&gt;(<span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(128, 0, 0, 1)\">select @TotalCount=count(*) from t_Student where Id&lt;@IdMax</span><span style=\"color: rgba(128, 0, 0, 1)\">\"</span><span style=\"color: rgba(0, 0, 0, 1)\">, TotalCount, IdMax);\n   </span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> tc = (<span style=\"color: rgba(0, 0, 255, 1)\">int</span>)TotalCount.Value;</pre> \n</div> \n<p><strong>灵活学习+使用以上4个示例，就能满足几乎所有的数据操作需求。</strong></p> \n<p>另外，你有没有发现，上述所有的数据操作几乎只用了一个方法来实现：SqlExecute/ SqlExecute&lt;T&gt;</p> \n<p>&nbsp;</p> \n<p>IDA内功能方法详细说明（辅助参考）：</p> \n<div class=\"cnblogs_code\"> \n <pre>SqlExecute&lt;T&gt;<span style=\"color: rgba(0, 0, 0, 1)\">\n声明：IEnumerable</span>&lt;T&gt; SqlExecute&lt;T&gt;(<span style=\"color: rgba(0, 0, 255, 1)\">string</span> cmdText, <span style=\"color: rgba(0, 0, 255, 1)\">params</span> IDataParameter[] Params) <span style=\"color: rgba(0, 0, 255, 1)\">where</span> T : <span style=\"color: rgba(0, 0, 255, 1)\">class</span>, <span style=\"color: rgba(0, 0, 255, 1)\">new</span><span style=\"color: rgba(0, 0, 0, 1)\">()\n用途：执行Sql语句(Select类)\n参数：（</span><span style=\"color: rgba(128, 0, 128, 1)\">1</span>）<span style=\"color: rgba(0, 0, 255, 1)\">string</span>  cmdText              --<span style=\"color: rgba(0, 0, 0, 1)\">  Sql语句\n     （</span><span style=\"color: rgba(128, 0, 128, 1)\">2</span>）<span style=\"color: rgba(0, 0, 255, 1)\">params</span> IDataParameter[] Params --<span style=\"color: rgba(0, 0, 0, 1)\">  参数组\n返回：IEnumerable</span>&lt;T&gt; --<span style=\"color: rgba(0, 0, 0, 1)\">  多数据结果集\n\n\nSqlExecute\n声明：</span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> SqlExecute(<span style=\"color: rgba(0, 0, 255, 1)\">string</span> cmdText, <span style=\"color: rgba(0, 0, 255, 1)\">params</span><span style=\"color: rgba(0, 0, 0, 1)\"> IDataParameter[] Params)\n用途：执行Sql语句(Insert</span>/Update/<span style=\"color: rgba(0, 0, 0, 1)\">Delete类)\n参数：（</span><span style=\"color: rgba(128, 0, 128, 1)\">1</span>）<span style=\"color: rgba(0, 0, 255, 1)\">string</span>  cmdText              --<span style=\"color: rgba(0, 0, 0, 1)\">  Sql语句\n     （</span><span style=\"color: rgba(128, 0, 128, 1)\">2</span>）<span style=\"color: rgba(0, 0, 255, 1)\">params</span> IDataParameter[] Params --<span style=\"color: rgba(0, 0, 0, 1)\">  参数组\n返回：</span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> --<span style=\"color: rgba(0, 0, 0, 1)\">  受影响的行数\n\nSpExecute</span>&lt;T&gt;<span style=\"color: rgba(0, 0, 0, 1)\">\n声明：IEnumerable</span>&lt;T&gt; SpExecute&lt;T&gt;(<span style=\"color: rgba(0, 0, 255, 1)\">string</span> cmdText, <span style=\"color: rgba(0, 0, 255, 1)\">params</span> IDataParameter[] Params) <span style=\"color: rgba(0, 0, 255, 1)\">where</span> T : <span style=\"color: rgba(0, 0, 255, 1)\">class</span>, <span style=\"color: rgba(0, 0, 255, 1)\">new</span><span style=\"color: rgba(0, 0, 0, 1)\">()\n用途：执行Sp存储过程(Select类)\n参数：（</span><span style=\"color: rgba(128, 0, 128, 1)\">1</span>）<span style=\"color: rgba(0, 0, 255, 1)\">string</span>  cmdText              --<span style=\"color: rgba(0, 0, 0, 1)\">  Sp存储过程名\n     （</span><span style=\"color: rgba(128, 0, 128, 1)\">2</span>）<span style=\"color: rgba(0, 0, 255, 1)\">params</span> IDataParameter[] Params --<span style=\"color: rgba(0, 0, 0, 1)\">  参数组\n返回：IEnumerable</span>&lt;T&gt; --<span style=\"color: rgba(0, 0, 0, 1)\">  多数据结果集\n\nSpExecute\n声明：</span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> SpExecute(<span style=\"color: rgba(0, 0, 255, 1)\">string</span> cmdText, <span style=\"color: rgba(0, 0, 255, 1)\">params</span><span style=\"color: rgba(0, 0, 0, 1)\"> IDataParameter[] Params)\n用途：执行Sp存储过程(Insert</span>/Update/<span style=\"color: rgba(0, 0, 0, 1)\">Delete类)\n参数：（</span><span style=\"color: rgba(128, 0, 128, 1)\">1</span>）<span style=\"color: rgba(0, 0, 255, 1)\">string</span>  cmdText              --<span style=\"color: rgba(0, 0, 0, 1)\">  Sp存储过程名\n     （</span><span style=\"color: rgba(128, 0, 128, 1)\">2</span>）<span style=\"color: rgba(0, 0, 255, 1)\">params</span> IDataParameter[] Params --<span style=\"color: rgba(0, 0, 0, 1)\">  参数组\n返回：</span><span style=\"color: rgba(0, 0, 255, 1)\">int</span> --  受影响的行数</pre> \n</div> \n<p>&nbsp;</p>',100,NULL,2,'https://www.cnblogs.com/dotnet-college/p/16759726.html','2022-10-07 16:00:02'),(35,'Linux命令系列之ls——原来最简单的ls这么复杂',NULL,NULL,0,0,'<h1 id=\"linux命令系列之ls原来最简单的ls这么复杂\">Linux命令系列之ls——原来最简单的ls这么复杂</h1> \n<p>ls命令应该是我们最常用的命令之一了，但是我们可能容易忽略那些看起来最简单的东西。</p> \n<h2 id=\"简介\">简介</h2> \n<p>ls命令的使用格式如下</p> \n<pre><code class=\"language-shell\">ls [选项] [具体的文件] # [] 表示可选\n</code></pre> \n<ul> \n <li>直接在命令行输入<code>ls</code>将当前目录下的列出当前目录下的文件和目录。</li> \n</ul> \n<pre><code class=\"language-shell\">$ls\nLICENSE  README.md  hello.c\n</code></pre> \n<ul> \n <li>也可以指定具体的目录和文件</li> \n</ul> \n<pre><code class=\"language-shell\">$ls /\nbin   dev  home  lib32  libx32  mnt  proc  run   srv  tmp  var\nboot  etc  lib   lib64  media   opt  root  sbin  sys  usr\n</code></pre> \n<ul> \n <li>展示隐藏文件（所谓隐藏文件就是以<code>.</code>开头的目录或者文件），增加<code>-a</code>选项。</li> \n</ul> \n<pre><code class=\"language-shell\">$ls -a\n.  ..  .git  LICENSE  README.md  hello.c # . 表示当前目录 .. 表示上一级目录\n</code></pre> \n<ul> \n <li>展示文件的详细信息。</li> \n</ul> \n<pre><code class=\"language-shell\">$ls -al\ntotal 44\ndrwxr-xr-x 3 root root  4096 Oct  6 04:20 .\ndrwx------ 1 root root  4096 Oct  7 03:16 ..\ndrwxr-xr-x 8 root root  4096 Aug 26 15:28 .git\n-rw-r--r-- 1 root root 18027 Aug 26 15:28 LICENSE\n-rw-r--r-- 1 root root   210 Aug 26 15:28 README.md\n-rw-r--r-- 1 root root    72 Aug 26 15:32 hello.c\n</code></pre> \n<h2 id=\"详细信息说明\">详细信息说明</h2> \n<p>我们现在来仔细分析一下<code>ls</code>输出结果：</p> \n<p>第一行 <code>total 44</code>，表示这个目录下面所有的文件的大小总和，单位是<code>KiB</code>。</p> \n<p>然后是接下来的每一行，每一行的开头都有10个字符，他们的含义具体如下：</p> \n<h3 id=\"文件类型说明\">文件类型说明</h3> \n<p>第一个字符，有的是<code>d</code>, 有的是<code>-</code>，在linux系统当中，这第一个字符表示文件的类型，他有如下几种类型：</p> \n<ul> \n <li><code>d</code>，表示目录，比如说上面的<code>.</code>当前目录，<code>..</code>上一级的目录。</li> \n <li><code>-</code>，表示一般的文件，比如说上面的<code>hello.c</code>.</li> \n <li><code>b</code>，表示块设备，比如我们的磁盘就是一种块设备，他们的这个位置都是<code>b</code>。</li> \n</ul> \n<pre><code class=\"language-shell\">$ls -al /dev/ | grep sda\nbrw-rw----  1 root disk      8,   0 Apr 30 23:16 sda\nbrw-rw----  1 root disk      8,   1 Apr 30 23:16 sda1\nbrw-rw----  1 root disk      8,   2 Apr 30 23:16 sda2\nbrw-rw----  1 root disk      8,   3 Apr 30 23:16 sda3\n</code></pre> \n<ul> \n <li><code>l</code>，表示一个符号链接文件，也叫做软链接。比如我们创建一个软链接文件，并且查看它，软链接就相当于windows中的快捷方式，它并不真正的去存储数据，简单说来只是存储来一个指向一个文件的链接。</li> \n</ul> \n<pre><code class=\"language-shell\">$ln -s hello.c softlink.c\n$ls -al\ntotal 52\ndrwxr-xr-x 3 root root  4096 Oct  7 03:39 .\ndrwx------ 1 root root  4096 Oct  7 03:33 ..\ndrwxr-xr-x 8 root root  4096 Aug 26 15:28 .git\n-rw-r--r-- 1 root root 18027 Aug 26 15:28 LICENSE\n-rw-r--r-- 1 root root   210 Aug 26 15:28 README.md\n-rw-r--r-- 3 root root    72 Aug 26 15:32 copy.c\n-rw-r--r-- 3 root root    72 Aug 26 15:32 dcopy.c\n-rw-r--r-- 3 root root    72 Aug 26 15:32 hello.c\nlrwxrwxrwx 1 root root     7 Oct  7 03:39 softlink.c -&gt; hello.c # 这里就表示是软链接\n</code></pre> \n<ul> \n <li><code>p</code>，表示一个管道，我们在进行多进程通信的时候可能需要使用到这个设备文件。比如我们创建一个具体的管道：</li> \n</ul> \n<pre><code class=\"language-shell\">$mkfifo test\n$ll\ntotal 52\ndrwxr-xr-x 3 root root  4096 Oct  7 05:06 ./\ndrwx------ 1 root root  4096 Oct  7 03:40 ../\ndrwxr-xr-x 8 root root  4096 Aug 26 15:28 .git/\n-rw-r--r-- 1 root root 18027 Aug 26 15:28 LICENSE\n-rw-r--r-- 1 root root   210 Aug 26 15:28 README.md\n-rw-r--r-- 3 root root    72 Aug 26 15:32 copy.c\n-rw-r--r-- 3 root root    72 Aug 26 15:32 dcopy.c\n-rw-r--r-- 3 root root    72 Aug 26 15:32 hello.c\nlrwxrwxrwx 1 root root     7 Oct  7 03:39 softlink.c -&gt; hello.c\nprw-r--r-- 1 root root     0 Oct  7 05:06 test # 这里就是我么你创建的管道\n</code></pre> \n<ul> \n <li><code>s</code>，这个表示一个套接字，用于网络通信。</li> \n</ul> \n<h3 id=\"权限说明\">权限说明</h3> \n<p>对于后面9个字符来说，是用于表示文件的相关权限的。对于每一种文件来说，它主要有三个权限，读、写和执行，我们很容易理解这三种权限，对于一个文件来说我们当然是想要读和写的，对于有的文件来说我们希望他是可执行的。我们稍后具体具一个例子，我们先来看这个9个位置分表表示的含义。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/1a996d79-f9f2-4991-8206-a834f074397a.png\" alt=\"\" loading=\"lazy\"></p> \n<p>在这9个位置的字符当中如果是用<code>-</code>表示，则说明没有对应的权限，如果是用对应的<code>r</code>,<code>w</code>,<code>x</code>表示，则说明有对应的权限。这9个字符每三个字符是一组，第一组表示文件的作者的权限，第二组表示作者所在组内的其他人的权限，第三组表示其他人的权限，也就是除了作者和作者所在的组之外的其他人的权限。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/685b5ad8-212e-4475-8653-db0878ea632f.png\" alt=\"\" loading=\"lazy\"></p> \n<p>比如在上图当中有一个可执行文件a.out，但是当我们使用chmod命令将他的所有的可执行权限都删掉的时候他就不可以被执行了，程序输出的结果表示没有权限。在没有修改之前，作者、组和其他人的权限为<code>-rwxr-xr-x</code>，所有的这些人都有可执行的权限。但是当执行命令<code>chmod -x a.out</code>之后去除了所有人的可执行权限之后，再想执行a.out就会报错了，表示权限不够，如果我们还想执行a.out的话就需要将权限重新加回去：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/a7f68477-5fd0-4e6c-ae0a-6ab198466d47.png\" alt=\"\" loading=\"lazy\"></p> \n<p>上面主要谈到了关于权限的问题，我们现在来好好谈一谈chmod命令，这条命令主要是用来修改文件的权限的，比如上面那样。在chmod当中我们可以有如下的几种方式去修改文件的权限：</p> \n<ul> \n <li> <p>直接通过<code>+r</code>，<code>+w</code>，<code>+x</code>和<code>-r</code>，<code>-w</code>，<code>-x</code>去修改三个不同的位置的权限，具体如下面这个例子所示。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/822e8660-6d0b-4e65-8ac6-1292e9178f7a.png\" alt=\"\" loading=\"lazy\"></p> </li> \n <li> <p>除此之外我们还可以指定特定的人或者组。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/cdfe64b4-c412-49f2-b578-43658efb77ba.png\" alt=\"\" loading=\"lazy\"></p> </li> \n <li> <p>在上面的例子当中我们还使用数组去表示权限，因为不管是那中类型的用户都有三种权限，每一种权限有具有两种状态，有这个权限和没有这个权限。那么每一个位置都可以使用一个二进制位进行表示，当二进制位为1的时候就说明有这个权限，为0的时候就没有这个权限。那么三个二进制位就表示一类用户（作者、组和其他），因此每一个用户的权限我们可以用三个二进制数进行表示，比如在上图当中的<code>chmod 746 hello.c</code>这条命令的输出结果和下图当中是相互对应的，打击可以仔细对照的思考一下。<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/103f90a8-525c-43c5-89fa-36b87b3d762a.png\" alt=\"\" loading=\"lazy\"></p> </li> \n</ul> \n<h3 id=\"其他说明\">其他说明</h3> \n<p>至此我们已经完成了<code>ls</code>输出的第一步分析，接下来我们来看第二行，第二行输出的数据是文件的链接的数目。对于目录来说这个链接的数目就是子目录的数目，对于文件来说就是硬链接的数量。对于一个新创建的文件来说硬链接的数目为1，我们可以是使用ln命令去增加一个文件的硬链接的数量，比如下图<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/439befe5-2ecc-4c7c-9ec6-2b3fbeb57089.png\" alt=\"\" loading=\"lazy\"></p> \n<p>硬链接和软链接的主要区别就是，软链接不会影响链接的数量，他只是指向一个文件，而硬链接不一样，他会增加一个文件链接的数量，当我们删除一个文件的时候事实上并不是直接将这个文件从磁盘当中删除，而是将这个文件的链接数减去一，当这个链接数等于0的时候才会删除这个文件，而删除一个软链接是不会影响链接的数量的，他只是在被发现是软链接的时候去读它指向的那个文件的内容。</p> \n<p>第三列和第四列主要是用户名和用户所在的组的组名。第五列是文件的大小，单位是Byte。后面三列是文件上一次修改时间分别对应月、日、分秒，最后一列则是文件名。</p> \n<h2 id=\"彩蛋\">彩蛋</h2> \n<ul> \n <li>我们可以使用stat命令去查看一个文件详细的元数据信息，这些信息是存储在文件的inode信息里面的。</li> \n</ul> \n<pre><code class=\"language-shell\">$stat hello.c \n  File: hello.c\n  Size: 72        	Blocks: 8          IO Block: 4096   regular file\nDevice: 91h/145d	Inode: 1577767     Links: 3\nAccess: (0644/-rw-r--r--)  Uid: (    0/    root)   Gid: (    0/    root)\nAccess: 2022-10-07 05:41:32.685021010 +0000\nModify: 2022-10-07 05:41:27.547021008 +0000\nChange: 2022-10-07 05:41:27.552021008 +0000\n Birth: 2022-08-26 15:32:43.726183003 +0000 \n</code></pre> \n<p>对应的信息如下：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/a12ee049-9a52-4c35-84e0-36975314ace5.png\" alt=\"\" loading=\"lazy\"></p> \n<ul> \n <li> <p>ls -R 递归列出子目录当中的文件。</p> </li> \n <li> <p>ls -S 根据文件大小排序</p> </li> \n <li> <p>ls - t 根据最后一次修改时间排序。</p> </li> \n <li> <p>ls -r 逆序排列。</p> </li> \n</ul> \n<hr> \n<p>以上就是本篇文章的所有内容了，我是<strong>LeHung</strong>，我们下期再见！！！更多精彩内容合集可访问项目：<a href=\"https://github.com/Chang-LeHung/CSCore\" target=\"_blank\" rel=\"noopener\">https://github.com/Chang-LeHung/CSCore</a></p> \n<p>关注公众号：<strong>一无是处的研究僧</strong>，了解更多计算机（Java、Python、计算机系统基础、算法与数据结构）知识。</p>',100,NULL,0,'https://www.cnblogs.com/Chang-LeHung/p/16759950.html','2022-10-07 16:30:10'),(36,'谣言检测（PLAN）——《Interpretable Rumor Detection in Microblogs by Attending to User Interactions》','论文信息论文标题：Interpretable Rumor Detection in Microblogs by Attending to User Interactions论文作者：Ling Min Serena Khoo, Hai Leong Chieu, Zhong Qian, Jing Jiang论文来','2022-10-07 19:12:20',0,0,'<h1><span style=\"font-size: 16px\">论文信息</span></h1><blockquote><p><span style=\"font-size: 16px\">论文标题：Interpretable Rumor Detection in Microblogs by Attending to User Interactions</span><br/><span style=\"font-size: 16px\">论文作者：Ling Min Serena Khoo, Hai Leong Chieu, Zhong Qian, Jing Jiang</span><br/><span style=\"font-size: 16px\">论文来源：2020,AAAI</span><br/><span style=\"font-size: 16px\">论文地址：<a href=\"https://arxiv.org/abs/2001.10667\" target=\"_blank\" rel=\"noopener\">download</a>&nbsp;</span><br/><span style=\"font-size: 16px\">论文代码：download </span></p></blockquote><h1><span style=\"font-size: 16px\">Background</span></h1><p><span style=\"font-size: 16px\">　　基于群体智能的谣言检测：Figure 1</span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/009c0e9d-c76b-41e8-8623-58e62f4811c4.png\" alt=\"\" loading=\"lazy\"/></span></p><p><span style=\"font-size: 16px\">　　本文观点：基于树结构的谣言检测模型，往往忽略了 Branch 之间的交互。</span></p><h1><span style=\"font-size: 16px\">1 Introduction</span></h1><p><span style=\"font-size: 16px\">　　<span style=\"color: rgba(255, 102, 0, 1)\">Motivation</span>：a user posting a reply might be replying to the entire thread rather than to a specific user.</span></p><p><span style=\"font-size: 16px\">　　<span style=\"color: rgba(255, 102, 0, 1)\">Mehtod</span>：We propose a post-level attention model (PLAN) to model long distance interactions between tweets with the multi-head attention mechanism in a transformer network.</span></p><p><span style=\"font-size: 16px\">　　We investigated variants of this model:</span></p><ul class=\" list-paddingleft-2\"><li><p><br/></p></li><ul class=\" list-paddingleft-2\" style=\"list-style-type: square;\"><li><p><span style=\"font-size: 16px\">a structure aware self-attention model (StA-PLAN) that incorporates tree structure information in the transformer network;　　</span></p></li><li><p><span style=\"font-size: 16px\">a hierarchical token and post-level attention model (StA-HiTPLAN) that learns a sentence representation with token-level self-attention.　　</span></p></li></ul></ul><p><span style=\"font-size: 16px\">　　<span style=\"color: rgba(255, 102, 0, 1)\">Contributions</span>：</span></p><ul class=\" list-paddingleft-2\"><li><p><br/></p></li><ul class=\" list-paddingleft-2\" style=\"list-style-type: square;\"><li><p><span style=\"font-size: 16px\">We utilize the attention weights from our model to provide both <span style=\"color: rgba(255, 102, 0, 1)\">token-level</span> and <span style=\"color: rgba(255, 102, 0, 1)\">post-level</span> explanations behind the model’s prediction. To the best of our knowledge, we are the first paper that has done this.　</span></p></li><li><p><span style=\"font-size: 16px\">We compare against previous works on two data sets - PHEME 5 events and Twitter15 and Twitter16 . Previous works only evaluated on one of the two data sets.&nbsp;</span></p></li><li><p><span style=\"font-size: 16px\">Our proposed models could outperform current state-ofthe-art models for both data sets.</span></p></li></ul></ul><p><span style=\"font-size: 16px\">　　目前谣言检测的类型：</span></p><p><span style=\"font-size: 16px\">　　　　(i) the content of the claim.</span></p><p><span style=\"font-size: 16px\">　　　　(ii) the bias and social network of the source of the claim.</span></p><p><span style=\"font-size: 16px\">　　　　(iii) fact checking with trustworthy sources.</span></p><p><span style=\"font-size: 16px\">　　　　(iv) community response to the claims.</span></p><h1><span style=\"font-size: 16px\">2&nbsp;Approaches</span></h1><h2><span style=\"font-size: 16px\">2.1 Recursive Neural Networks</span></h2><p><span style=\"font-size: 16px\">　　观点：谣言传播树通常是浅层的，一个用户通常只回复一次 source post ，而后进行早期对话。</span></p><table border=\"0\"><tbody><tr><td><p><span style=\"font-size: 16px\"><strong>Dataset</strong></span></p></td><td><p><span style=\"font-size: 16px\"><strong>Twitter15</strong></span></p></td><td><p><span style=\"font-size: 16px\"><strong>Twitter16</strong></span></p></td><td><p><span style=\"font-size: 16px\"><strong>PHEME</strong></span></p></td></tr><tr><td><p><span style=\"font-size: 16px\"><strong>Tree-depth</strong></span></p></td><td><p><span style=\"font-size: 16px\"><strong>2.80</strong></span></p></td><td><p><span style=\"font-size: 16px\"><strong>2.77</strong></span></p></td><td><p><span style=\"font-size: 16px\"><strong>3.12</strong></span></p></td></tr></tbody></table><h2><span style=\"font-size: 16px\">2.2 Transformer Networks</span></h2><p><span style=\"font-size: 16px\">　　Transformer 中的注意机制使有效的远程依赖关系建模成为可能。</span></p><p><span style=\"font-size: 16px\">　　Transformer 中的注意力机制：</span></p><p><span style=\"font-size: 16px\">　　　　$\\alpha_{i j}=\\operatorname{Compatibility}\\left(q_{i}, k_{j}\\right)=\\operatorname{softmax}\\left(\\frac{q_{i} k_{j}^{T}}{\\sqrt{d_{k}}}\\right)\\quad\\quad\\quad(1)$</span></p><p><span style=\"font-size: 16px\">　　　　$z_{i}=\\sum_{j=1}^{n} \\alpha_{i j} v_{j}\\quad\\quad\\quad(2)$</span></p><h2><span style=\"font-size: 16px\">2.3 Post-Level Attention Network (PLAN)</span></h2><p><span style=\"font-size: 16px\">　　框架如下：</span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/cea1dd57-5e3c-40be-a4a6-f8205150ad9e.png\" alt=\"\" loading=\"lazy\"/></span></p><p><span style=\"font-size: 16px\">　　首先：将 Post 按时间顺序排列；</span></p><p><span style=\"font-size: 16px\">　　其次：对每个 Post 使用 Max pool 得到 sentence embedding ；</span></p><p><span style=\"font-size: 16px\">　　然后：将 sentence embedding $X^{\\prime}=\\left(x_{1}^{\\prime}, x_{2}^{\\prime}, \\ldots, x_{n}^{\\prime}\\right)$ 通过 $s$ 个多头注意力模块 MHA 得到 $U=\\left(u_{1}, u_{2}, \\ldots, u_{n}\\right)$；</span></p><p><span style=\"font-size: 16px\">　　最后：通过 attention 机制聚合这些输出并使用全连接层进行预测 ：</span></p><p><span style=\"font-size: 16px\"> 　　　　$\\begin{array}{l}\\alpha_{k}=\\operatorname{softmax}\\left(\\gamma^{T} u_{k}\\right) &amp;\\quad\\quad\\quad(3)\\\\v=\\sum\\limits _{k=0}^{m} \\alpha_{k} u_{k} &amp;\\quad\\quad\\quad(4)\\\\p=\\operatorname{softmax}\\left(W_{p}^{T} v+b_{p}\\right) &amp;\\quad\\quad\\quad(5)\\end{array}$</span></p><p><span style=\"font-size: 16px\">&nbsp;　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/fe249331-28c8-4097-9a03-ec8a05afec0f.png\" alt=\"\" loading=\"lazy\"/></span></p><p><span style=\"font-size: 16px\">　　where $\\gamma \\in \\mathbb{R}^{d_{\\text {model }}}, \\alpha_{k} \\in \\mathbb{R}$，$W_{p} \\in \\mathbb{R}^{d_{\\text {model }}, K}$，$b \\in \\mathbb{R}^{d_{\\text {model }}}$，$u_{k}$&nbsp; is the output after passing through&nbsp; $s$&nbsp; number of MHA layers，$v$&nbsp; and&nbsp; $p$&nbsp; are the representation vector and prediction vector for&nbsp; $X$</span></p><p><span style=\"font-size: 16px\">　　回顾：</span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/123ed494-976b-4686-8840-d56e6f6b352d.png\" alt=\"\" loading=\"lazy\"/></span></p><h2><span style=\"font-size: 16px\">2.4 Structure Aware Post-Level Attention Network (StA-PLAN)</span></h2><p><span style=\"font-size: 16px\">　　上述模型的问题：线性结构组织的推文容易失去结构信息。</span></p><p><span style=\"font-size: 16px\">　　为了结合显示树结构的优势和自注意力机制，本文扩展了 PLAN 模型，来包含结构信息。</span></p><p><span style=\"font-size: 16px\">　　　　$\\begin{array}{l}\\alpha_{i j}=\\operatorname{softmax}\\left(\\frac{q_{i} k_{j}^{T}+a_{i j}^{K}}{\\sqrt{d_{k}}}\\right)\\\\z_{i}=\\sum\\limits _{j=1}^{n} \\alpha_{i j}\\left(v_{j}+a_{i j}^{V}\\right)\\end{array}$</span></p><p><span style=\"font-size: 16px\">　　其中， $a_{i j}^{V}$ 和 $a_{i j}^{K}$&nbsp; 是代表上述五种结构关系(i.e. parent, child, before, after and self) 的向量。</span></p><h2><span style=\"font-size: 16px\">2.5 Structure Aware Hierarchical Token and Post-Level Attention Network (StA-HiTPLAN)</span></h2><p><span style=\"font-size: 16px\">　　本文的PLAN 模型使用 max-pooling 来得到每条推文的句子表示，然而比较理想的方法是允许模型学习单词向量的重要性。因此，本文提出了一个层次注意模型—— attention at a token-level then at a post-level。层次结构模型的概述如 Figure 2b 所示。</span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/01f0e1c8-9ba7-4371-84b3-32ce89c92cc9.png\" alt=\"\" loading=\"lazy\"/></span></p><h2><span style=\"font-size: 16px\">2.6 Time Delay Embedding</span></h2><p><span style=\"font-size: 16px\">　　source post 创建的时候，reply 一般是抱持怀疑的状态，而当 source post 发布了一段时间后，reply 有着较高的趋势显示 post 是虚假的。因此，本文研究了 time delay information 对上述三种模型的影响。</span></p><p><span style=\"font-size: 16px; font-family: &quot;times new roman&quot;, times\">　　To include time delay information for each tweet, we bin the tweets based on their latency from the time the source tweet was created. We set the total number of time bins to be 100 and each bin represents a 10 minutes interval. Tweets with latency of more than 1,000 minutes would fall into the last time bin. We used the positional encoding formula introduced in the transformer network to encode each time bin. The time delay embedding would be added to the sentence embedding of tweet. The time delay embedding, TDE, for each tweet is:</span></p><p><span style=\"font-size: 16px\">　　　　$\\begin{array}{l}\\mathrm{TDE}_{\\text {pos }, 2 i} &amp;=&amp;\\sin \\frac{\\text { pos }}{10000^{2 i / d_{\\text {model }}}} \\\\\\mathrm{TDE}_{\\text {pos }, 2 i+1} &amp;=&amp;\\cos \\frac{\\text { pos }}{10000^{2 i / d_{\\text {model }}}}\\end{array}$</span></p><p><span style=\"font-size: 16px; font-family: &quot;times new roman&quot;, times\">　　where pos represents the time bin each tweet fall into and&nbsp; $p o s \\in[0,100)$, $i$&nbsp; refers to the dimension and&nbsp; $d_{\\text {model }}$&nbsp; refers to the total number of dimensions of the model.</span></p><h1><span style=\"font-size: 16px\">3&nbsp;Experiments and Results</span></h1><p><span style=\"font-size: 16px\"><strong>dataset</strong></span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/ceaf601d-9806-4390-8e69-90df1e365c10.png\" alt=\"\" loading=\"lazy\"/></span></p><p><span style=\"font-size: 16px\"><strong>Result&nbsp;</strong></span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/8f95a9d0-99b7-4c47-88f5-7b44c52fedf6.png\" alt=\"\" loading=\"lazy\"/></span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/45e5876c-bc47-44c7-ace6-3adce0454cd8.png\" alt=\"\" loading=\"lazy\"/></span></p><p><span style=\"font-size: 16px\"><strong>Explaining the predictions&nbsp;</strong></span></p><p><span style=\"font-size: 16px\"><strong>Post-Level Explanations</strong></span></p><p><span style=\"font-size: 16px\">　　首先通过最后的 attention 层获得最重要的推文 $tweet_{impt}$&nbsp; ，然后从第&nbsp; $i$&nbsp; 个MHA层获得该层的与 $tweet_{impt}$&nbsp; 最相关的推文 $tweet _{rel,i}$&nbsp; ，每篇推文可能被识别成最相关的推文多次，最后按照 被识别的次数排序，取前三名作为源推文的解释。举例如下:</span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/315b7605-6327-4bf7-ae2e-2b7fe730fb1c.png\" alt=\"\" loading=\"lazy\"/></span></p><p><span style=\"font-size: 16px\"><strong>Token-Level Explanation</strong></span></p><p><span style=\"font-size: 16px\">　　可以使用 token-level self-attention 的自注意力权重来进行 token-level 的解释。比如评论 “@inky mark @CP24 as part of a co-op criminal investigation one would URL doesn’t need facts to write stories it appears.”中短语“facts to write stories it appears”表达了对源推文的质疑，下图的自注意力权重图可以看出大量权重集中在这一部分，这说明这个短语就可以作为一个解释：</span></p><p><span style=\"font-size: 16px\">　　<img src=\"http://localhost:8080/static/blogImages/2022/10/07/54d1aef9-9b99-40c3-b182-d2a60ea08741.png\" alt=\"\" loading=\"lazy\"/></span></p>',11,NULL,1,'https://www.cnblogs.com/BlairGrowing/p/16759157.html','2022-10-07 16:30:23'),(37,'面试突击88：加入事务和嵌套事务有什么区别？','加入事务和嵌套事务是指在 Spring 事务传播机制中的加入事务（REQUIRED）和嵌套事务（NESTED）的区别，二者看似很像，实则截然不同，那么它们有什么区别呢？接下来我们一起来看。Spring 事务传播机制是指，包含多个事务的方法在相互调用时，事务是如何在这些方法间传播的，Spring 事务传播机制分','2022-10-07 18:56:50',0,0,'<p>加入事务和嵌套事务是指在 Spring 事务传播机制中的加入事务（REQUIRED）和嵌套事务（NESTED）的区别，二者看似很像，实则截然不同，那么它们有什么区别呢？接下来我们一起来看。</p><p>Spring 事务传播机制是指，包含多个事务的方法在相互调用时，事务是如何在这些方法间传播的，Spring 事务传播机制分为 3 大类，总共 7 种级别，如下图所示：<br/> <img src=\"https://cdn.nlark.com/yuque/0/2021/png/92791/1639661220728-ce263fda-1529-468d-9512-9b1967cd8609.png?x-oss-process=image%2Fresize%2Cw_1416%2Climit_0#crop=0&crop=0&crop=1&crop=1&from=url&id=ZXpsW&margin=%5Bobject%20Object%5D&originHeight=738&originWidth=1416&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title=\" alt=\"\" loading=\"lazy\"/><br/> 其中，<strong>支持当前事务的 REQUIRED 是加入（当前）事务，而 NESTED 是嵌套（当前）事务</strong>，本文要讨论的就是这二者的区别。</p><h2 id=\"1加入事务\">1.加入事务</h2><p>加入事务 REQUIRED 是 Spring 事务的默认传播级别。</p><p><strong>所谓的加入当前事务，是指如果当前存在事务，则加入该事务</strong>；如果当前没有事务，则创建一个新的事务。我们这里重点要讨论的是第一种情况，也就是当前存在事务的情况下，它和嵌套事务的区别，接下来我们通过一个示例来看加入事务的使用和执行特点。</p><p>我们要实现的是用户添加功能，只不过在添加用户时，我们需要给用户表和日志表中分别插入一条数据，UserController 实现代码如下：</p><pre>@Transactional(propagation&nbsp;=&nbsp;Propagation.REQUIRED)\n@RequestMapping(&quot;/add&quot;)\npublic&nbsp;int&nbsp;add(UserInfo&nbsp;userInfo)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;userResult&nbsp;=&nbsp;userService.add(userInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;用户添加结果：&quot;&nbsp;+&nbsp;userResult);\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(userResult&nbsp;&gt;&nbsp;0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LogInfo&nbsp;logInfo&nbsp;=&nbsp;new&nbsp;LogInfo();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logInfo.setName(&quot;添加用户&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logInfo.setDesc(&quot;添加用户结果：&quot;&nbsp;+&nbsp;userResult);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;logResult&nbsp;=&nbsp;logService.add(logInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;日志添加结果：&quot;&nbsp;+&nbsp;logResult);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p></p><p>从上述代码可以看出，添加用户使用了事务，并设置了事务传播机制为 REQUIRED（加入事务），此控制器调用的 UserService 实现代码如下：</p><pre>@Transactional(propagation&nbsp;=&nbsp;Propagation.REQUIRED)\npublic&nbsp;int&nbsp;add(UserInfo&nbsp;userInfo)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;userMapper.add(userInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p></p><p>从上述代码可以看出，它也是使用事务，并设置了事务的传播机制为 REQUIRED，而 LogService 也是类似的实现代码：</p><pre>@Transactional(propagation&nbsp;=&nbsp;Propagation.REQUIRED)\npublic&nbsp;int&nbsp;add(LogInfo&nbsp;logInfo)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;logMapper.add(logInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;number&nbsp;=&nbsp;10&nbsp;/&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;手动回滚事务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p></p><p>从上述代码我们可以看出，在设置事务传播机制的同时，我们也在程序中主动的设置了一个异常。</p><p>运行以上程序的执行结果如下图所示：<br/> <img src=\"https://cdn.nlark.com/yuque/0/2022/png/92791/1660640506495-b53e68e5-95a7-4a00-9971-8ed53fd5c006.png#clientId=u273cf478-09f1-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=278&id=u977a3f3a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=555&originWidth=1614&originalType=binary&ratio=1&rotation=0&showTitle=false&size=62362&status=error&style=none&taskId=u0d3e7c0e-8385-455a-992d-133272f39ee&title=&width=807\" alt=\"image.png\" loading=\"lazy\"/><br/> 从上述结果我们可以看出：<strong>当我们设置了加入事务的事务传播机制之后，程序的执行结果是将用户表和日志表的事务都回滚了</strong>。</p><h2 id=\"2嵌套事务\">2.嵌套事务</h2><p>嵌套事务指的是事务传播级别中的 NESTED，<strong>所谓的嵌套当前事务，是指如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行</strong>；如果当前没有事务，则该取值等价于 REQUIRED。当然，我们本文要研究的重点也是第一种情况，也就是当前存在事务的前提下，嵌套事务和加入事务的区别。</p><p>所以接下来我们将上面代码中的事务传播机制改为 NESTED，它的实现代码如下。<br/> UserController 实现代码如下：</p><pre>@Transactional(propagation&nbsp;=&nbsp;Propagation.NESTED)\n@RequestMapping(&quot;/add&quot;)\npublic&nbsp;int&nbsp;add(UserInfo&nbsp;userInfo)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;userResult&nbsp;=&nbsp;userService.add(userInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;用户添加结果：&quot;&nbsp;+&nbsp;userResult);\n&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(userResult&nbsp;&gt;&nbsp;0)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LogInfo&nbsp;logInfo&nbsp;=&nbsp;new&nbsp;LogInfo();\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logInfo.setName(&quot;添加用户&quot;);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;logInfo.setDesc(&quot;添加用户结果：&quot;&nbsp;+&nbsp;userResult);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;logResult&nbsp;=&nbsp;logService.add(logInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(&quot;日志添加结果：&quot;&nbsp;+&nbsp;logResult);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;1;\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p></p><p>UserService 实现代码如下：</p><pre>@Transactional(propagation&nbsp;=&nbsp;Propagation.NESTED)\npublic&nbsp;int&nbsp;add(UserInfo&nbsp;userInfo)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;userMapper.add(userInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p></p><p>LogService 实现代码如下：</p><pre>@Transactional(propagation&nbsp;=&nbsp;Propagation.NESTED)\npublic&nbsp;int&nbsp;add(LogInfo&nbsp;logInfo)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;result&nbsp;=&nbsp;logMapper.add(logInfo);\n&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;number&nbsp;=&nbsp;10&nbsp;/&nbsp;0;\n&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception&nbsp;e)&nbsp;{\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;手动回滚事务\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result;\n}</pre><p></p><p>运行以上程序的执行结果如下图所示：<br/> <img src=\"https://cdn.nlark.com/yuque/0/2022/png/92791/1660640351048-977c092b-0e57-4072-8b7a-9227eefb4fd5.png#clientId=u273cf478-09f1-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=385&id=uce1b2428&margin=%5Bobject%20Object%5D&name=image.png&originHeight=769&originWidth=2099&originalType=binary&ratio=1&rotation=0&showTitle=false&size=83368&status=error&style=none&taskId=udff5c545-df6f-415a-9fac-4a13da4faac&title=&width=1049.5\" alt=\"image.png\" loading=\"lazy\"/><br/> 从上述结果可以看出：<strong>当设置嵌套事务的事务传播级别之后，程序执行了部分事务的回滚</strong>，用户表添加的事务没有回滚，只是日志表的事务回滚了。</p><h2 id=\"3加入事务-vs-嵌套事务\">3.加入事务 VS 嵌套事务</h2><p><strong>加入事务（REQUIRED）和嵌套事务（NESTED）都是事务传播机制的两种传播级别，如果当前不存在事务，那么二者的行为是一样的；但如果当前存在事务，那么加入事务的事务传播级别在遇到异常之后，会将事务全部回滚；而嵌套事务在遇到异常时，只是执行了部分事务的回滚。</strong></p><h2 id=\"4嵌套事务实现原理\">4.嵌套事务实现原理</h2><p>事务全部回滚很好理解，这本来就是事务原子性的一种体现，而嵌套事务中的部分事务回滚是怎么实现的呢？</p><p><strong>嵌套事务只所以能实现部分事务的回滚，是因为在数据库中存在一个保存点（savepoint）的概念，以 MySQL 为例，嵌套事务相当于新建了一个保存点，而滚回时只回滚到当前保存点，因此之前的事务是不受影响的</strong>，这一点可以在 MySQL 的官方文档汇总找到相应的资料：<a href=\"https://dev.mysql.com/doc/refman/5.7/en/savepoint.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/5.7/en/savepoint.html</a><br/> <img src=\"https://cdn.nlark.com/yuque/0/2021/png/92791/1639623696956-8591905c-9b2f-4303-bbe7-cb13493e25bc.png#clientId=u684ca108-16ce-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=370&id=u1d899048&margin=%5Bobject%20Object%5D&name=image.png&originHeight=739&originWidth=1395&originalType=binary&ratio=1&rotation=0&showTitle=false&size=172883&status=error&style=none&taskId=ub2f8bd3c-e7a1-4d39-aae4-ac436acbf6c&title=&width=697.5\" alt=\"image.png\" loading=\"lazy\"/><br/> <strong>而 REQUIRED 是加入到当前事务中，并没有创建事务的保存点，因此出现了回滚就是整个事务回滚</strong>，这就是嵌套事务和加入事务的区别。</p><p>保存点就像玩通关游戏时的“游戏存档”一样，如果设置了游戏存档，那么即使当前关卡失败了，也能继续上一个存档点继续玩，而不是从头开始玩游戏。<br/> <img src=\"https://cdn.nlark.com/yuque/0/2022/png/92791/1660642264074-8aafc7cd-4729-49b6-ab1d-812b9e9bfc0c.png#clientId=u273cf478-09f1-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=722&id=ue06c16fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1443&originWidth=1096&originalType=binary&ratio=1&rotation=0&showTitle=false&size=1109383&status=error&style=none&taskId=u69f875c9-b661-45b9-adc0-0d62f5aafb3&title=&width=548\" alt=\"image.png\" loading=\"lazy\"/></p><h2 id=\"总结\">总结</h2><p>加入事务（REQUIRED）和嵌套事务（NESTED）都是事务传播机制中的两种传播级别，如果当前不存在事务，那么二者的行为是一致的；但如果当前存在事务，那么加入事务的事务传播级别当遇到异常时会回滚全部事务，而嵌套事务则是回滚部分事务。嵌套事务之所以能回滚部分事务，是因为数据库中存在一个保存点的概念，嵌套事务相对于新建了一个保存点，如果出现异常了，那么只需要回滚到保存点即可，这样就实现了部分事务的回滚。</p><blockquote><p>是非审之于己，毁誉听之于人，得失安之于数。</p><p>公众号：Java面试真题解析</p><p>面试合集：<a href=\"https://gitee.com/mydb/interview\" target=\"_blank\" rel=\"noopener\">https://gitee.com/mydb/interview</a></p></blockquote>',4,NULL,1,'https://www.cnblogs.com/vipstone/p/16760086.html','2022-10-07 17:30:39'),(38,'文件管理工具“三剑客” #Everything #SpaceSniffer #Clover','前言：本文收集了我日常使用的三个文件管理工具：文件搜索神器——Everything磁盘文件占用分析工具——SpaceSniffer文件资源管理器——Clover下面我从工具解决的痛点和使用技巧两个方面去介绍每个工具。1、文件搜索神器——Everything痛点：想要快速搜索到文件，只知道一个前缀或者后缀，希望','2022-10-07 19:07:30',0,0,'<h2>前言：</h2><p>本文收集了我日常使用的三个文件管理工具：</p><ul class=\" list-paddingleft-2\"><li><p>文件搜索神器——Everything</p></li><li><p>磁盘文件占用分析工具——SpaceSniffer</p></li><li><p>文件资源管理器——Clover</p></li></ul><p>下面我从工具解决的<strong>痛点</strong>和<strong>使用技巧</strong>两个方面去介绍每个工具。</p><h2>1、文件搜索神器——Everything</h2><p><strong>痛点：</strong></p><p>想要<strong>快速搜索到文件</strong>，只知道一个前缀或者后缀，希望模糊查找，但是就算知道文件名字的全称，windows自带的搜索功能巨慢。来一张图片感受一下。</p><p><img src=\"https://img2022.cnblogs.com/blog/564664/202210/564664-20221007154710950-1108880811.gif\" alt=\"\" width=\"790\" height=\"279\"/></p><p>再放一张使用everything的搜索效果图</p><p><img src=\"https://img2022.cnblogs.com/blog/564664/202210/564664-20221007155347744-330252789.gif\" alt=\"\" width=\"984\" height=\"272\"/></p><p>一个可能十几分钟出不了结果，一个结果秒出。</p><p><strong>使用技巧：</strong><br/>下面放出2张图包含大部分的搜索技巧</p><p><strong>场景1</strong></p><p>输入：C:\\Users\\Administrator\\Documents\\WeChat Files\\ *.jpg size:&gt;10kb</p><p>释义：搜索<strong>指定</strong>微信文件夹<strong>路径</strong>下的所有大于10kb的jpg格式图片</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/fecad3b9-4b4a-4c99-a9ee-94fa4abc9d03.png\" alt=\"\" width=\"762\" height=\"387\" loading=\"lazy\"/></p><p>&nbsp;<strong>场景2</strong></p><p>输入：C:\\Users\\Administrator\\ *.jpg|*.png dc:today size:&gt;40kb</p><p>释义：搜索指定路径下的，今天创建的，文件大于40kb大小的所有jpg或png格式图片</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a9a840b7-cad5-4097-8917-b0597cd51206.png\" alt=\"\" width=\"991\" height=\"289\" loading=\"lazy\"/></p><p>下面贴上这个工具的搜索语法，上面的命令可以从搜索语法里找到。</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_242000e1-a2c7-48e6-9d9e-968941015892\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_242000e1-a2c7-48e6-9d9e-968941015892\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>&nbsp;&nbsp;1&nbsp;操作符:&nbsp;\n&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;space&nbsp;&nbsp;&nbsp;&nbsp;与&nbsp;(AND)&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;或&nbsp;(OR)&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!&nbsp;&nbsp;&nbsp;&nbsp;非&nbsp;(NOT)&nbsp;&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;&nbsp;&gt;&nbsp;&nbsp;&nbsp;&nbsp;分组&nbsp;&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&nbsp;&quot;&nbsp;&nbsp;&nbsp;&nbsp;搜索引号内的词组.&nbsp;&nbsp;7&nbsp;&nbsp;&nbsp;8&nbsp;通配符:&nbsp;\n&nbsp;&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*&nbsp;&nbsp;&nbsp;&nbsp;匹配&nbsp;0&nbsp;个或多个字符.&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;?&nbsp;&nbsp;&nbsp;&nbsp;匹配&nbsp;1&nbsp;个字符.&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*.&nbsp;&nbsp;&nbsp;&nbsp;匹配不包含扩展的文件名.&nbsp;12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*.*&nbsp;&nbsp;&nbsp;&nbsp;与&nbsp;*&nbsp;相同&nbsp;13&nbsp;&nbsp;14&nbsp;宏:&nbsp;\n&nbsp;15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;quot:&nbsp;&nbsp;&nbsp;&nbsp;双引号&nbsp;(&quot;)&nbsp;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apos:&nbsp;&nbsp;&nbsp;&nbsp;单引号&nbsp;(&#39;)&nbsp;17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;amp:&nbsp;&nbsp;&nbsp;&nbsp;与号&nbsp;(&amp;)&nbsp;18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lt:&nbsp;&nbsp;&nbsp;&nbsp;小于&nbsp;(&lt;)&nbsp;19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gt:&nbsp;&nbsp;&nbsp;&nbsp;大于&nbsp;(&gt;)&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#x:&nbsp;&nbsp;&nbsp;&nbsp;Unicode字符代码&nbsp;x.&nbsp;21&nbsp;&nbsp;22&nbsp;修饰符:&nbsp;\n&nbsp;23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ascii:&nbsp;&nbsp;&nbsp;&nbsp;启用快速&nbsp;ASCII&nbsp;大小写对比.&nbsp;24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case:&nbsp;&nbsp;&nbsp;&nbsp;区分大小写.&nbsp;25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;diacritics:&nbsp;&nbsp;&nbsp;&nbsp;匹配变音标记.&nbsp;26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;file:&nbsp;&nbsp;&nbsp;&nbsp;仅匹配文件.&nbsp;27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;folder:&nbsp;&nbsp;&nbsp;&nbsp;仅匹配文件夹.&nbsp;28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noascii:&nbsp;&nbsp;&nbsp;&nbsp;禁用快速&nbsp;ASCII&nbsp;大小写对比.&nbsp;29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nocase:&nbsp;&nbsp;&nbsp;&nbsp;不区分大小写.&nbsp;30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nodiacritics:&nbsp;&nbsp;&nbsp;&nbsp;不匹配变音标记.&nbsp;31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nofileonly:&nbsp;&nbsp;&nbsp;&nbsp;仅不允许文件.&nbsp;32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nofolderonly:&nbsp;&nbsp;&nbsp;&nbsp;仅不允许文件夹.&nbsp;33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nopath:&nbsp;&nbsp;&nbsp;&nbsp;不匹配路径.&nbsp;34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noregex:&nbsp;&nbsp;&nbsp;&nbsp;禁用正则表达式.&nbsp;35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nowfn:&nbsp;&nbsp;&nbsp;&nbsp;不匹配完整文件名.&nbsp;36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nowholefilename:&nbsp;&nbsp;&nbsp;&nbsp;不匹配完整文件名.&nbsp;37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nowholeword:&nbsp;&nbsp;&nbsp;&nbsp;仅禁用全字匹配.&nbsp;38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nowildcards:&nbsp;&nbsp;&nbsp;&nbsp;禁用通配符.&nbsp;39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;noww:&nbsp;&nbsp;&nbsp;&nbsp;仅禁用全字匹配.&nbsp;40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path:&nbsp;&nbsp;&nbsp;&nbsp;匹配路径和文件名.&nbsp;41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;regex:&nbsp;&nbsp;&nbsp;&nbsp;启用正则表达式.&nbsp;42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;utf8:&nbsp;&nbsp;&nbsp;&nbsp;禁用快速&nbsp;ASCII&nbsp;大小写对比.&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wfn:&nbsp;&nbsp;&nbsp;&nbsp;匹配完整文件名.&nbsp;44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wholefilename:&nbsp;&nbsp;&nbsp;&nbsp;匹配完整文件名.&nbsp;45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wholeword:&nbsp;&nbsp;&nbsp;&nbsp;仅匹配全字符.&nbsp;46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wildcards:&nbsp;&nbsp;&nbsp;&nbsp;启用通配符.&nbsp;47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ww:&nbsp;&nbsp;&nbsp;&nbsp;仅全字匹配.&nbsp;48&nbsp;&nbsp;49&nbsp;函数:&nbsp;\n&nbsp;50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attrib:&lt;attributes&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定的文件属性的文件和文件夹.&nbsp;51&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;attributes:&lt;attributes&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定的文件属性的文件和文件夹.&nbsp;52&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;child:&lt;filename&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索包含匹配文件名文件的文件夹.&nbsp;53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childcount:&lt;count&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索包含有指定数目子文件夹或文件的文件夹.&nbsp;54&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childfilecount:&lt;count&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索包含有指定数目文件的文件夹.&nbsp;55&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;childfoldercount:&lt;cnt&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索包含有指定数目子文件的文件夹.&nbsp;56&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dateaccessed:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定访问时间的文件和文件夹.&nbsp;57&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datecreated:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定创建日期的文件和文件夹.&nbsp;58&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;datemodified:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定修改日期的文件和文件夹.&nbsp;59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;daterun:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定打开时间的文件和文件夹.&nbsp;60&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;da:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定访问时间的文件和文件夹.&nbsp;61&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dc:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定创建日期的文件和文件夹.&nbsp;62&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dm:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定修改日期的文件和文件夹.&nbsp;63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dr:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定打开时间的文件和文件夹.&nbsp;64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dupe:&nbsp;&nbsp;&nbsp;&nbsp;搜索重复的文件名.&nbsp;65&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty:&nbsp;&nbsp;&nbsp;&nbsp;搜索空文件夹.&nbsp;66&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;endwith:&lt;text&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索以指定文本结尾的文件&nbsp;(包含扩展名).&nbsp;67&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ext:&lt;list&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索和列表中指定的扩展名匹配的文件&nbsp;(扩展名以分号分隔).&nbsp;68&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filelist:&lt;fn1|fn2|...&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索文件名列表中的文件.&nbsp;69&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;filelistfilename:&lt;name&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索文件名列表中的文件和文件夹.&nbsp;70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fsi:&lt;index&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定盘符索引中文件或文件夹&nbsp;(索引&nbsp;0&nbsp;表示&nbsp;C&nbsp;盘,&nbsp;以此类推).&nbsp;71&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;infolder:&lt;path&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定路径下的文件和文件夹&nbsp;(不包含子文件夹).&nbsp;72&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;len:&lt;length&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索和指定的文件名长度相匹配的文件和文件夹.&nbsp;73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parent:&lt;path&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定路径下的文件和文件夹&nbsp;(不包含子文件夹).&nbsp;74&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;parents:&lt;count&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索有指定数目父文件夹的文件和文件夹.&nbsp;75&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;rc:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定最近修改日期的文件和文件夹.&nbsp;76&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;recentchange:&lt;date&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定最近修改日期的文件和文件夹.&nbsp;77&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;root:&nbsp;&nbsp;&nbsp;&nbsp;搜索没有父文件夹的文件和文件夹.&nbsp;78&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;runcount:&lt;count&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定打开次数的文件和文件夹.&nbsp;79&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size:&lt;size&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定大小的文件&nbsp;(以字节为单位).&nbsp;80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sizedupe:&nbsp;&nbsp;&nbsp;&nbsp;搜索大小重复的文件.&nbsp;81&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;startwith:&lt;text&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定文本开头的文件.&nbsp;82&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&lt;type&gt;&nbsp;&nbsp;&nbsp;&nbsp;搜索指定的文件类型的文件和文件夹.&nbsp;83&nbsp;&nbsp;84&nbsp;函数语法:&nbsp;\n&nbsp;85&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:value&nbsp;&nbsp;&nbsp;&nbsp;等于某设定值.&nbsp;86&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:&lt;=value&nbsp;&nbsp;&nbsp;&nbsp;小于等于某设定值.&nbsp;87&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:&lt;value&nbsp;&nbsp;&nbsp;&nbsp;小于某设定值.&nbsp;88&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:=value&nbsp;&nbsp;&nbsp;&nbsp;等于某设定值.&nbsp;89&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:&gt;value&nbsp;&nbsp;&nbsp;&nbsp;大于某设定值.&nbsp;90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:&gt;=value&nbsp;&nbsp;&nbsp;&nbsp;大于等于某设定值.&nbsp;91&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:start..end&nbsp;&nbsp;&nbsp;&nbsp;在起始值和终止值的范围内.&nbsp;92&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;function:start-end&nbsp;&nbsp;&nbsp;&nbsp;在起始值和终止值的范围内.&nbsp;93&nbsp;&nbsp;94&nbsp;大小语法:&nbsp;\n&nbsp;95&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size[kb|mb|gb]&nbsp;96&nbsp;&nbsp;97&nbsp;大小常数:&nbsp;\n&nbsp;98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empty&nbsp;99&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tiny&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;KB&nbsp;&lt;&nbsp;大小&nbsp;&lt;=&nbsp;10&nbsp;KB100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;small&nbsp;&nbsp;&nbsp;&nbsp;10&nbsp;KB&nbsp;&lt;&nbsp;大小&nbsp;&lt;=&nbsp;100&nbsp;KB101&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;medium&nbsp;&nbsp;&nbsp;&nbsp;100&nbsp;KB&nbsp;&lt;&nbsp;大小&nbsp;&lt;=&nbsp;1&nbsp;MB102&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;large&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;MB&nbsp;&lt;&nbsp;大小&nbsp;&lt;=&nbsp;16&nbsp;MB103&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;huge&nbsp;&nbsp;&nbsp;&nbsp;16&nbsp;MB&nbsp;&lt;&nbsp;大小&nbsp;&lt;=&nbsp;128&nbsp;MB104&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;gigantic&nbsp;&nbsp;&nbsp;&nbsp;大小&nbsp;&gt;&nbsp;128&nbsp;MB105&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unknown106&nbsp;107&nbsp;日期语法:&nbsp;\n108&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year109&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;month/year&nbsp;或者&nbsp;year/month&nbsp;取决于本地设置110&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;day/month/year,&nbsp;month/day/year&nbsp;或者&nbsp;year/month/day&nbsp;取决于本地设置111&nbsp;112&nbsp;日期常数:&nbsp;\n113&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;today114&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yesterday115&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tomorrow116&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;last|past|prev|current|this|coming|next&gt;&lt;year|month|week&gt;117&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;last|past|prev|coming|next&gt;&lt;x&gt;&lt;years|months|weeks|hours|minutes|mins|seconds|secs&gt;118&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;january|february|march|april|may|june|july|august|september|october|november|december119&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec120&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sunday|monday|tuesday|wednesday|thursday|friday|saturday121&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sun|mon|tue|wed|thu|fri|sat122&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unknown123&nbsp;124&nbsp;属性常数:&nbsp;\n125&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;存档126&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C&nbsp;&nbsp;&nbsp;&nbsp;压缩127&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;D&nbsp;&nbsp;&nbsp;&nbsp;目录128&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;E&nbsp;&nbsp;&nbsp;&nbsp;加密129&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;H&nbsp;&nbsp;&nbsp;&nbsp;隐藏130&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;&nbsp;未索引的内容131&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;L&nbsp;&nbsp;&nbsp;&nbsp;重解析点132&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;N&nbsp;&nbsp;&nbsp;&nbsp;一般133&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;O&nbsp;&nbsp;&nbsp;&nbsp;离线134&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P&nbsp;&nbsp;&nbsp;&nbsp;稀疏文件135&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R&nbsp;&nbsp;&nbsp;&nbsp;只读136&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S&nbsp;&nbsp;&nbsp;&nbsp;系统137&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;T&nbsp;&nbsp;&nbsp;&nbsp;临时138&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;V&nbsp;&nbsp;&nbsp;&nbsp;设备</pre><p></p><p><span class=\"cnblogs_code_collapse\">View Code</span></p><p>&nbsp;</p><h2>&nbsp;2、磁盘文件占用分析工具——SpaceSniffer</h2><p><strong>痛点：</strong></p><p>磁盘空间又满了，不知道什么文件占用了空间，想删文件都找不到目标。</p><p><strong>使用技巧：</strong></p><p>选择盘符，点击start即可分析磁盘文件所占用的空间，工具会以大大小小的方块来显示文件大小，文件占用空间越大，方块则显示越大，这样可以轻松找到占用空间比较大的文件，清理空间时，找到几个首要大的垃圾文件，就解决了80%的空间占用问题。</p><p><img src=\"https://img2022.cnblogs.com/blog/564664/202210/564664-20221007162428161-973489090.gif\" alt=\"\" width=\"1079\" height=\"558\"/></p><p>如下图，每个文件夹可以单击下钻</p><p><img src=\"https://img2022.cnblogs.com/blog/564664/202210/564664-20221007163106959-1857011381.gif\" alt=\"\" width=\"1079\" height=\"558\"/></p><p>下钻列出了每个文件，选中文件可以右键可以删除和剪切到空间足够的路径</p><p>&nbsp;</p><h2>3、文件资源管理器——Clover</h2><p><strong>痛点：</strong></p><p>打开多个文件夹后，本就拥挤的任务栏空间，更加雪上加霜。clover可以使多个打开的文件夹合并到tab标签，就像浏览器的标签页一样，从此任务栏就清爽多了，还带了一些快捷键和收藏夹的功能，找常用的文件也方便很多。</p><p><strong>使用技巧：</strong></p><p>安装Clover后，会给windows原有的资源管理器Explorer增强，以后打开资源管理器就会带上标签页。</p><p><strong><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a04a4b42-7369-4ad4-ae4c-63c41c0ab604.png\" alt=\"\" width=\"930\" height=\"428\" loading=\"lazy\"/></strong></p><p>&nbsp;</p><p>Clover的快捷键</p><p><strong><strong><img src=\"http://localhost:8080/static/blogImages/2022/10/07/8e138a1b-84d3-45d1-8ae3-9aa083504320.png\" alt=\"\" width=\"773\" height=\"446\" loading=\"lazy\"/></strong></strong></p><p>&nbsp;</p><p>&nbsp;Clover的设置</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/1d3f510d-7bb0-4983-be0c-c7cacd6e97cf.png\" alt=\"\" width=\"521\" height=\"465\" loading=\"lazy\"/></p><p>&nbsp;</p><p>&nbsp;</p><h2>最后</h2><p>贴上这三个工具的下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://www.voidtools.com/\" target=\"_blank\" rel=\"noopener\">文件搜索神器——Everything</a></p></li><li><p><a href=\"http://www.uderzo.it/main_products/space_sniffer/download_alt.html\" target=\"_blank\" rel=\"noopener\">磁盘文件占用分析工具——SpaceSniffer</a></p></li><li><p><a href=\"http://cn.ejie.me/\" target=\"_blank\" rel=\"noopener\">文件资源管理器——Clover</a></p></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;本文发表自：https://www.cnblogs.com/xiefengdaxia123/p/16759339.html，转载请注明出处。</p>',11,NULL,1,'https://www.cnblogs.com/xiefengdaxia123/p/16759339.html','2022-10-07 17:30:59'),(39,'STM32的SPI口的DMA读写[原创www.cnblogs.com/helesheng]','SPI是我最常用的接口之一，连接管脚仅为4根；在常见的芯片间通信方式中，速度远优于UART、I2C等其他接口。STM32的SPI口的同步时钟最快可到PCLK的二分之一，单个字节或字的通信时间都在us以下，因此大多数情况下我们会使用查询法控制SPI口的传输。但对于大量且连续的通信，再使用查询法就显得有些浪费CP','2022-10-07 19:03:20',0,0,'<p>SPI是我最常用的接口之一，连接管脚仅为4根；在常见的芯片间通信方式中，速度远优于UART、I2C等其他接口。STM32的SPI口的同步时钟最快可到PCLK的二分之一，单个字节或字的通信时间都在us以下，因此大多数情况下我们会使用查询法控制SPI口的传输。但对于大量且连续的通信，再使用查询法就显得有些浪费CPU的时间，DMA控制SPI的读写显然成为一种不错的选择。</p><p>为DMA控制SPI批量数据读写的功能，参照官方代码编写的DMA控制SPI口在主/从两种模式下，读写数据的的代码，供各位网友直接使用或批评指正。先直接上我得到结论：</p><p>1、运用STM32的SPI口的DMA的功能，能够提升STM32与外设之间通信的速率和实时性。</p><p>2、<span style=\"color: rgba(255, 0, 0, 1)\"><strong>但在STM32的SPI的主机模式下，DMA控制器无法自动产生片选CS信号</strong></span>，只能与无需同步CS信号的外设器件通信。为产生同步的CS信号，只能由软件控制SPI逐字发送，而DMA仅用于接收SPI数据，这样做的效率和不使用DMA时一样。</p><p>3、<span style=\"color: rgba(255, 0, 0, 1)\"><strong>主模式下，</strong></span><span style=\"color: rgba(255, 0, 0, 1)\"><strong>软件控制片选CS信号和SPI读写时，存在至少50%的时间空隙，降低了其SPI通信的效率</strong></span>。</p><p>4、<span style=\"color: rgba(255, 0, 0, 1)\"><strong>STM32的SPI主机模式下，无法只使用DMA接收，而不发送</strong></span>。原因是没有触发SPI的DMA接收的信号。但SPI的发送可以是软件控制的逐字发送，也可以是DMA控制的连续发送。</p><p>5、STM32的SPI若要<span style=\"color: rgba(255, 0, 0, 1)\"><strong>使用DMA方式，最合适的是让STM32工作在SPI的从模式</strong></span>，由外部主机（如FPGA）来控制通信的实时性和高速性。</p><p>以下原创内容欢迎网友转载，但请注明出处： <a href=\"https://www.cnblogs.com/helesheng\" rel=\"noopener\">https://www.cnblogs.com/helesheng</a></p><p><span style=\"font-size: 14pt\"><strong>一、STM32做SPI主机（Master）时的DMA传输</strong></span></p><p>STM32做SPI主机进行DMA通信时，尤其需要注意的是：<span style=\"color: rgba(255, 0, 0, 1)\"><strong>不能单独使用SPI接收数据DMA，一定要配合SPI发送数据，DMA接收数据通道才能收到数据</strong></span>。道理很简单：STM32做主机时，如果不主动发送数据将无法产生时钟和片选等信号，亦无法在传输完成后触发DMA接收数据。但在使用时，这一点非常容易被忽视，从而造成DMA接收SPI数据通道DMA1CH2和DMACH4“不工作”。</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/9961f0b2-c108-46df-b77f-b09ce68bd7cf.png\" alt=\"\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"/></p><p style=\"text-align:center;\">图1、STM32 DMA1各通道功能</p><p>&nbsp;</p><p>具体来说，使用SPI口的DMA接收功能有两种配置方法：</p><p><strong>1、</strong><strong>SPI</strong><strong>口的接收和发送各使用一个DMA通道</strong></p><p>这样做最符合DMA控制大量数据连续发送和接收的设计初衷，此种情况下的SPI口和两个DMA通道的配置分别如下：&nbsp;</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_a5ef2bb1-4efe-4b4c-b2cd-1a84206daa67\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_a5ef2bb1-4efe-4b4c-b2cd-1a84206daa67\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>&nbsp;1&nbsp;RCC_APB2PeriphClockCmd(&nbsp;&nbsp;&nbsp;&nbsp;RCC_APB2Periph_SPI1,&nbsp;ENABLE&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;2&nbsp;GPIO_InitStructure.GPIO_Pin&nbsp;=&nbsp;GPIO_Pin_5&nbsp;|&nbsp;GPIO_Pin_6&nbsp;|&nbsp;GPIO_Pin_7;//PA5&nbsp;6&nbsp;7是SPI1的SCK&nbsp;MIOS&nbsp;MOSI&nbsp;3&nbsp;GPIO_InitStructure.GPIO_Mode&nbsp;=&nbsp;GPIO_Mode_AF_PP;&nbsp;&nbsp;//复用推挽输出&nbsp;4&nbsp;GPIO_InitStructure.GPIO_Speed&nbsp;=&nbsp;GPIO_Speed_50MHz;&nbsp;5&nbsp;GPIO_Init(GPIOA,&nbsp;&amp;GPIO_InitStructure);&nbsp;6&nbsp;GPIO_SetBits(GPIOA&nbsp;,&nbsp;GPIO_Pin_5|GPIO_Pin_6|GPIO_Pin_7);&nbsp;&nbsp;&nbsp;&nbsp;//将其置位&nbsp;7&nbsp;SPI_InitStructure.SPI_Direction&nbsp;=&nbsp;SPI_Direction_2Lines_FullDuplex;&nbsp;&nbsp;//设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工&nbsp;8&nbsp;SPI_InitStructure.SPI_Mode&nbsp;=&nbsp;SPI_Mode_Master;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置SPI工作模式:设置为主SPI&nbsp;9&nbsp;SPI_InitStructure.SPI_DataSize&nbsp;=&nbsp;SPI_DataSize_16b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置SPI的数据大小:SPI发送接收8位帧结构10&nbsp;SPI_InitStructure.SPI_CPOL&nbsp;=&nbsp;SPI_CPOL_Low;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//空闲时时钟为低电平11&nbsp;SPI_InitStructure.SPI_CPHA&nbsp;=&nbsp;SPI_CPHA_1Edge;&nbsp;&nbsp;&nbsp;&nbsp;//数据捕获于第1个时钟沿12&nbsp;SPI_InitStructure.SPI_NSS&nbsp;=&nbsp;SPI_NSS_Soft;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//SPI_NSS_Hard;&nbsp;&nbsp;&nbsp;&nbsp;////NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制13&nbsp;SPI_InitStructure.SPI_BaudRatePrescaler&nbsp;=&nbsp;SPI_BaudRatePrescaler_2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//定义波特率预分频的值14&nbsp;SPI_InitStructure.SPI_FirstBit&nbsp;=&nbsp;SPI_FirstBit_MSB;&nbsp;&nbsp;&nbsp;&nbsp;//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始15&nbsp;SPI_InitStructure.SPI_CRCPolynomial&nbsp;=&nbsp;7;&nbsp;&nbsp;&nbsp;&nbsp;//CRC值计算的多项式16&nbsp;SPI_Init(SPI1,&nbsp;&amp;SPI_InitStructure);&nbsp;&nbsp;//根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器17&nbsp;SPI_Cmd(SPI1,&nbsp;ENABLE);&nbsp;//使能SPI1外设</pre><p></p><p><span class=\"cnblogs_code_collapse\">SPI的配置</span></p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_3ac40368-3d06-4345-811d-af640619c40c\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_3ac40368-3d06-4345-811d-af640619c40c\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>&nbsp;1&nbsp;RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,&nbsp;ENABLE);&nbsp;&nbsp;&nbsp;&nbsp;//使能DMA传输&nbsp;2&nbsp;///////以下配置DMA&nbsp;CH2用于接收SPI的DMA通道/////&nbsp;3&nbsp;DMA_DeInit(DMA1_Channel2);&nbsp;&nbsp;&nbsp;//将DMA的通道1寄存器重设为缺省值&nbsp;4&nbsp;DMA_InitStructure.DMA_PeripheralBaseAddr&nbsp;=&nbsp;(u32)&amp;(SPI1-&gt;DR);&nbsp;&nbsp;//DMA外设基地址&nbsp;5&nbsp;DMA_InitStructure.DMA_MemoryBaseAddr&nbsp;=&nbsp;(u32)spi_rx_buff;&nbsp;&nbsp;//DMA内存基地址&nbsp;6&nbsp;DMA_InitStructure.DMA_DIR&nbsp;=&nbsp;DMA_DIR_PeripheralSRC;&nbsp;&nbsp;//数据传输方向，从外设读取数据到内存&nbsp;7&nbsp;DMA_InitStructure.DMA_BufferSize&nbsp;=&nbsp;num;&nbsp;&nbsp;//DMA通道的DMA缓存的大小&nbsp;8&nbsp;DMA_InitStructure.DMA_PeripheralInc&nbsp;=&nbsp;DMA_PeripheralInc_Disable;&nbsp;&nbsp;//外设地址寄存器不变&nbsp;9&nbsp;DMA_InitStructure.DMA_MemoryInc&nbsp;=&nbsp;DMA_MemoryInc_Enable;&nbsp;&nbsp;//内存地址寄存器递增10&nbsp;DMA_InitStructure.DMA_PeripheralDataSize&nbsp;=&nbsp;DMA_PeripheralDataSize_HalfWord;&nbsp;&nbsp;//数据宽度为16位11&nbsp;DMA_InitStructure.DMA_MemoryDataSize&nbsp;=&nbsp;DMA_MemoryDataSize_HalfWord;&nbsp;//数据宽度为16位12&nbsp;DMA_InitStructure.DMA_Mode&nbsp;=&nbsp;DMA_Mode_Normal;&nbsp;&nbsp;//工作在正常模式13&nbsp;DMA_InitStructure.DMA_Priority&nbsp;=&nbsp;DMA_Priority_VeryHigh;&nbsp;//DMA通道&nbsp;x拥有中优先级&nbsp;14&nbsp;DMA_InitStructure.DMA_M2M&nbsp;=&nbsp;DMA_M2M_Disable;&nbsp;&nbsp;//DMA通道x没有设置为内存到内存传输15&nbsp;DMA_Init(DMA1_Channel2,&nbsp;&amp;DMA_InitStructure);&nbsp;&nbsp;//根据DMA_InitStruct中指定的参数初始化DMA的通道16&nbsp;///////以下配置DMA的SPI发送通道///////////17&nbsp;DMA_DeInit(DMA1_Channel3);&nbsp;&nbsp;\n18&nbsp;DMA_InitStructure.DMA_PeripheralBaseAddr&nbsp;=&nbsp;(u32)&amp;(SPI1-&gt;DR);&nbsp;//设置接收外设(0x4001300C)&nbsp;地址(源地址)19&nbsp;DMA_InitStructure.DMA_MemoryBaseAddr&nbsp;=&nbsp;(uint32_t)spi_tx_buff;&nbsp;&nbsp;&nbsp;//设置&nbsp;SRAM&nbsp;存储地址(源地址)20&nbsp;DMA_InitStructure.DMA_DIR&nbsp;=&nbsp;DMA_DIR_PeripheralDST;&nbsp;&nbsp;//传输方向&nbsp;内存-外设21&nbsp;DMA_InitStructure.DMA_BufferSize&nbsp;=&nbsp;num;&nbsp;&nbsp;//设置&nbsp;SPI1&nbsp;接收长度22&nbsp;DMA_InitStructure.DMA_PeripheralInc&nbsp;=&nbsp;DMA_PeripheralInc_Disable;&nbsp;//外设地址增量(不变)23&nbsp;DMA_InitStructure.DMA_MemoryInc&nbsp;=&nbsp;DMA_MemoryInc_Enable;&nbsp;&nbsp;//内存地址增量(变化)24&nbsp;DMA_InitStructure.DMA_PeripheralDataSize&nbsp;=&nbsp;DMA_MemoryDataSize_HalfWord;&nbsp;//外设传输宽度(字节)25&nbsp;DMA_InitStructure.DMA_MemoryDataSize&nbsp;=&nbsp;DMA_MemoryDataSize_HalfWord;&nbsp;//内存传输宽度(字节)26&nbsp;DMA_InitStructure.DMA_Mode&nbsp;=&nbsp;DMA_Mode_Normal;&nbsp;//传输方式,一次传输完停止,不重新加载27&nbsp;DMA_InitStructure.DMA_Priority&nbsp;=&nbsp;DMA_Priority_Medium;&nbsp;//DMA优先级28&nbsp;DMA_InitStructure.DMA_M2M&nbsp;=&nbsp;DMA_M2M_Disable;&nbsp;&nbsp;&nbsp;//内存到内存方式禁止29&nbsp;DMA_Init(DMA1_Channel3,&nbsp;&amp;DMA_InitStructure);</pre><p></p><p><span class=\"cnblogs_code_collapse\">收发两个DMA通道的配置</span></p><p>主程序中收发控制程序如下：</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_57fc6f7a-3165-4c9f-835e-c41f17c1c7c1\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_57fc6f7a-3165-4c9f-835e-c41f17c1c7c1\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>&nbsp;1&nbsp;SPIx_Init();//SPI初始化&nbsp;2&nbsp;DMA_Config(256);//配置DMA对应的两个通道，数据深度设为256&nbsp;3&nbsp;SPI_I2S_DMACmd(SPI1&nbsp;,&nbsp;SPI_I2S_DMAReq_Rx&nbsp;,&nbsp;ENABLE);&nbsp;4&nbsp;SPI_I2S_DMACmd(SPI1&nbsp;,&nbsp;SPI_I2S_DMAReq_Tx&nbsp;,&nbsp;ENABLE);&nbsp;5&nbsp;while(1)&nbsp;6&nbsp;{&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_SetCurrDataCounter(DMA1_Channel2,256);//必须在每次启动DMA之前设置&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_SetCurrDataCounter(DMA1_Channel3,256);//必须在每次启动DMA之前设置&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_Cmd(DMA1_Channel2,&nbsp;ENABLE);&nbsp;&nbsp;//使能DMA所指示的通道&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_Cmd(DMA1_Channel3,&nbsp;ENABLE);&nbsp;&nbsp;//使能DMA所指示的通道&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(1)12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(DMA_GetFlagStatus(DMA1_FLAG_TC2)&nbsp;!=&nbsp;RESET)&nbsp;&nbsp;&nbsp;&nbsp;//判断通道2传输完成14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_ClearFlag(DMA1_FLAG_TC2);//清除通道2传输完成标志16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;\n17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_Cmd(DMA1_Channel2,&nbsp;DISABLE);//禁止DMA&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_Cmd(DMA1_Channel3,&nbsp;DISABLE);//禁止DMA&nbsp;21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delay_ms(1);&nbsp;&nbsp;&nbsp;&nbsp;\n22&nbsp;}</pre><p></p><p><span class=\"cnblogs_code_collapse\">SPI主机DMA使用流程</span></p><p>这里我没有使用DMA中断，为的是验证代码的简单易懂；在实际使用时，建议读者使用中断以提高数据读写效率。另外，代码中值得注意的地方有：</p><p><span style=\"color: rgba(255, 0, 0, 1)\"><strong>1、&nbsp;&nbsp;&nbsp; </strong><strong>使用DMA传输之前，必须使能SPI发送和接收触发DAM传输请求，官方固件库中的函数分别为：SPI_I2S_DMACmd(SPI1 , SPI_I2S_DMAReq_Rx , ENABLE);和SPI_I2S_DMACmd(SPI1 , SPI_I2S_DMAReq_Tx , ENABLE);</strong></span></p><p><span style=\"color: rgba(255, 0, 0, 1)\"><strong>2、&nbsp;&nbsp;&nbsp; </strong><strong>每轮DMA传输完成后，需在次启动一轮DMA传输之前，需要重新设置传输数据计数器：DMA_SetCurrDataCounter(DMA1_Channel2,256);和DMA_SetCurrDataCounter(DMA1_Channel3,256);</strong></span></p><p>另外，我在使用上述方法的时候，忽然发现一个致命的问题：如果使用DMA控制STM32作为SPI主机输出数据，那么谁来产生片选信号CS呢？后来尝试过将NSS（PA4——SPI1或PB12——SPI2）管脚配置给SPI口，并改由硬件来控制该管脚：&nbsp; SPI_InitStructure.SPI_NSS = SPI_NSS_Hard;结果发现均不奏效，也就是说：<span style=\"color: rgba(255, 0, 0, 1)\"><strong>在SPI主模式下使用DMA发送，无法产生有效的片选CS信号！这无疑是致命的缺陷！</strong></span>——也许是我的理解不到位，请各位知道怎么解决这个问题的大神一定要高速我一下。（<span style=\"font-family: 仿宋\">当然这一缺陷，对于无需在单次发送字节/半字之后给出片选CS信号的应用——如大容量SPI接口存储器，并不成其为问题。</span>）</p><p>无法在用DMA控制SPI发送时控制CS信号，我只好退而求其次：<strong>改由软件控制SPI发送，并同步产生CS信号。但这样做已经失去了DMA接收SPI的意义，因为软件控制SPI发送后，通信的速度和使用查询法是一样的！</strong></p><p><strong>2、</strong><strong>SPI</strong><strong>接收使用DMA控制，发送使用软件控制</strong></p><p>尽管我认为发送使用软件控制后，DMA在接收中带来的好处已经基本丧失，但在这里仍然给出主程序中收发控制程序供读者参考。</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_d56ac623-da59-40fb-adf1-d65979274a11\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_d56ac623-da59-40fb-adf1-d65979274a11\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>&nbsp;1&nbsp;SPIx_Init();&nbsp;2&nbsp;DMA_Config(256);//配置DMA的SPI通道，数据深度设为256&nbsp;3&nbsp;SPI_I2S_DMACmd(SPI1&nbsp;,&nbsp;SPI_I2S_DMAReq_Rx&nbsp;,&nbsp;ENABLE);&nbsp;4&nbsp;delay_ms(300);&nbsp;5&nbsp;while(1)&nbsp;6&nbsp;{&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(n_interrupt&nbsp;!=&nbsp;0);//等到中断到来&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(n_interrupt&nbsp;==&nbsp;0);//等到中断结束&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_SetCurrDataCounter(DMA1_Channel2,256);//这部必须在每次启动DMA之前设置，10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_Cmd(DMA1_Channel2,&nbsp;ENABLE);&nbsp;&nbsp;//使能DMA所指示的通道&nbsp;11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(k&nbsp;=&nbsp;0&nbsp;;&nbsp;k&nbsp;&lt;&nbsp;256&nbsp;;&nbsp;k++)12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CS&nbsp;=&nbsp;0;14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SPIx_ReadWrite16bit(0xaa55);//只使用了DMA接收SPI数据，但接收要由软件启动发送数据才能接收，此处只是随便发送了一个数据15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CS&nbsp;=&nbsp;1;16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(DMA_GetFlagStatus(DMA1_FLAG_TC2)!=RESET)&nbsp;&nbsp;&nbsp;&nbsp;//判断通道2传输完成18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_ClearFlag(DMA1_FLAG_TC2);//清除通道2传输完成标志19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DMA_Cmd(DMA1_Channel2,&nbsp;DISABLE);//禁止DMA&nbsp;20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//////////以下可以把数据传输走//////////21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</pre><p></p><p><span class=\"cnblogs_code_collapse\">SPI主机，软件控制逐字发送，接收用DMA控制</span></p><p>可以看到，当由软件控制SPI发送后，就可以由软件产生和发送同步的片选CS了。但这样做与收发都采用查询法的效率几乎一样了。</p><p>特别的，当采用查询法直接控制SPI口的接收和发送时，硬件的读写和软件的指令总是存在较大时间空隙：向SPI数据寄存器SPI_DR写入数据到SPI实际发出数据之间存在至少200ns间隔；检测SPI状态寄存器SPI_SR中的TXE（发送缓冲区空位）时，TXE位的变化总是比实际发送完成晚至少200ns。例如上面的代码，函数SPIx_ReadWrite16bit();通过软件控制片选CS信号和SPI硬件的方式通信，下图是它所产生的CS信号（蓝）和SCK（黄），可以发现该函数用于发送的时间只占了实际耗费时间的一半以下，特别是当发送字长仅为8bits时，时间利用率真的是非常感人。</p><p style=\"text-align: center\"><img src=\"http://localhost:8080/static/blogImages/2022/10/07/6b9c3a8f-000f-48d4-bc63-25782a416a03.png\" alt=\"\" loading=\"lazy\"/></p><p>&nbsp;</p><p style=\"text-align: center\">查询法实现片选CS信号（蓝色）和SPI硬件产生的时序</p><p>&nbsp;对于这样的实时性，我实在是不明白意法半导体的STM32设计师的初衷是什么。当然，也有可能是笔者才疏学浅，如果有大神知道，烦请转告，多谢！</p><p><span style=\"font-size: 16px\"><strong>二、STM32做SPI从机（Slave）时的DMA传输</strong></span></p><p>当然用DMA读写SPI，更合理的方式是让STM32的SPI工作在从机模式，只要主机给出合理的片选CS、时钟SCK和数据MOSI/MISO信号，作为从机的STM32就能在DMA的支持下，实现高效、实时的数据接收。下面的代码中，我将SPI1配置为从机模式，用DMA1CH2接收数据。</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_50ed6877-66fd-4fd6-90bc-dd7481baf635\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_50ed6877-66fd-4fd6-90bc-dd7481baf635\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///////&nbsp;DMA&nbsp;CH2配置代码/////////&nbsp;2&nbsp;RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1,&nbsp;ENABLE);&nbsp;&nbsp;&nbsp;&nbsp;//使能DMA传输&nbsp;3&nbsp;DMA_DeInit(DMA1_Channel2);&nbsp;&nbsp;&nbsp;//将DMA的通道1寄存器重设为缺省值&nbsp;4&nbsp;DMA_InitStructure.DMA_PeripheralBaseAddr&nbsp;=&nbsp;(u32)&amp;(SPI1-&gt;DR);&nbsp;&nbsp;//DMA外设基地址&nbsp;5&nbsp;DMA_InitStructure.DMA_MemoryBaseAddr&nbsp;=&nbsp;(u32)spi_rx_buff;&nbsp;&nbsp;//DMA内存基地址&nbsp;6&nbsp;DMA_InitStructure.DMA_DIR&nbsp;=&nbsp;DMA_DIR_PeripheralSRC;&nbsp;&nbsp;//数据传输方向，从外设读取数据到内存&nbsp;7&nbsp;DMA_InitStructure.DMA_BufferSize&nbsp;=&nbsp;num;&nbsp;&nbsp;//DMA通道的DMA缓存的大小&nbsp;8&nbsp;DMA_InitStructure.DMA_PeripheralInc&nbsp;=&nbsp;DMA_PeripheralInc_Disable;&nbsp;&nbsp;//外设地址寄存器不变&nbsp;9&nbsp;DMA_InitStructure.DMA_MemoryInc&nbsp;=&nbsp;DMA_MemoryInc_Enable;&nbsp;&nbsp;//内存地址寄存器递增10&nbsp;DMA_InitStructure.DMA_PeripheralDataSize&nbsp;=&nbsp;DMA_PeripheralDataSize_HalfWord;&nbsp;&nbsp;//数据宽度为16位11&nbsp;DMA_InitStructure.DMA_MemoryDataSize&nbsp;=&nbsp;DMA_MemoryDataSize_HalfWord;&nbsp;//数据宽度为16位12&nbsp;DMA_InitStructure.DMA_Mode&nbsp;=&nbsp;DMA_Mode_Normal;&nbsp;&nbsp;//工作在正常模式13&nbsp;DMA_InitStructure.DMA_Priority&nbsp;=&nbsp;DMA_Priority_VeryHigh;&nbsp;//DMA通道&nbsp;x拥有中优先级&nbsp;14&nbsp;DMA_InitStructure.DMA_M2M&nbsp;=&nbsp;DMA_M2M_Disable;&nbsp;&nbsp;//DMA通道x没有设置为内存到内存传输15&nbsp;DMA_Init(DMA1_Channel2,&nbsp;&amp;DMA_InitStructure);&nbsp;&nbsp;//根据DMA_InitStruct中指定的参数初始化DMA的通道16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;///////&nbsp;SPI1配置代码/////////17&nbsp;RCC_APB2PeriphClockCmd(&nbsp;&nbsp;&nbsp;&nbsp;RCC_APB2Periph_SPI1,&nbsp;ENABLE&nbsp;);&nbsp;&nbsp;&nbsp;&nbsp;\n18&nbsp;GPIO_InitStructure.GPIO_Pin&nbsp;=&nbsp;GPIO_Pin_4&nbsp;|&nbsp;GPIO_Pin_5&nbsp;|&nbsp;GPIO_Pin_6&nbsp;|&nbsp;GPIO_Pin_7;//PA4&nbsp;PA5&nbsp;6&nbsp;7是SPI1的CS&nbsp;SCK&nbsp;MIOS&nbsp;MOSI19&nbsp;GPIO_InitStructure.GPIO_Mode&nbsp;=&nbsp;GPIO_Mode_AF_PP;&nbsp;&nbsp;//复用推挽输出20&nbsp;GPIO_InitStructure.GPIO_Speed&nbsp;=&nbsp;GPIO_Speed_50MHz;21&nbsp;GPIO_Init(GPIOA,&nbsp;&amp;GPIO_InitStructure);22&nbsp;SPI_InitStructure.SPI_Direction&nbsp;=&nbsp;SPI_Direction_2Lines_FullDuplex;&nbsp;&nbsp;//设置SPI单向或者双向的数据模式:SPI设置为双线双向全双工23&nbsp;SPI_InitStructure.SPI_Mode&nbsp;=&nbsp;SPI_Mode_Slave;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置SPI工作模式:设置为SPI从机24&nbsp;SPI_InitStructure.SPI_DataSize&nbsp;=&nbsp;SPI_DataSize_16b;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//设置SPI的数据大小:SPI发送接收8位帧结构25&nbsp;SPI_InitStructure.SPI_CPOL&nbsp;=&nbsp;SPI_CPOL_Low;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//空闲时时钟为低电平26&nbsp;SPI_InitStructure.SPI_CPHA&nbsp;=&nbsp;SPI_CPHA_1Edge;&nbsp;&nbsp;&nbsp;&nbsp;//数据捕获于第1个时钟沿27&nbsp;SPI_InitStructure.SPI_NSS&nbsp;=&nbsp;SPI_NSS_Soft;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//SPI_NSS_Hard;&nbsp;&nbsp;&nbsp;&nbsp;////NSS信号由硬件（NSS管脚）还是软件（使用SSI位）管理:内部NSS信号有SSI位控制28&nbsp;SPI_InitStructure.SPI_BaudRatePrescaler&nbsp;=&nbsp;SPI_BaudRatePrescaler_2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//定义波特率预分频的值29&nbsp;SPI_InitStructure.SPI_FirstBit&nbsp;=&nbsp;SPI_FirstBit_MSB;&nbsp;&nbsp;&nbsp;&nbsp;//指定数据传输从MSB位还是LSB位开始:数据传输从MSB位开始30&nbsp;SPI_InitStructure.SPI_CRCPolynomial&nbsp;=&nbsp;7;&nbsp;&nbsp;&nbsp;&nbsp;//CRC值计算的多项式31&nbsp;SPI_Init(SPI1,&nbsp;&amp;SPI_InitStructure);&nbsp;&nbsp;//根据SPI_InitStruct中指定的参数初始化外设SPIx寄存器</pre><p></p><p><span class=\"cnblogs_code_collapse\">SPI从机DMA使用流程</span></p><p>主程序中，控制DMA和读取缓冲中的程序如下所示。这里为了代码的简单易懂，同样没有使用DMA中断，在实际使用时，建议读者使用中断以提高数据读写效率。</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_b0adcb6d-c4b8-424b-91e9-f8aa7ae30967\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_b0adcb6d-c4b8-424b-91e9-f8aa7ae30967\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>&nbsp;1&nbsp;SPI_Cmd(SPI1,&nbsp;ENABLE);&nbsp;//使能SPI1外设&nbsp;2&nbsp;DMA_SetCurrDataCounter(DMA1_Channel2,256);//这部必须在每次启动DMA之前设置，&nbsp;3&nbsp;DMA_Cmd(DMA1_Channel2,&nbsp;ENABLE);&nbsp;&nbsp;//使能DMA所指示的通道&nbsp;&nbsp;4&nbsp;while(DMA_GetFlagStatus(DMA1_FLAG_TC2)==RESET);&nbsp;&nbsp;&nbsp;&nbsp;//判断通道2传输完成&nbsp;5&nbsp;DMA_ClearFlag(DMA1_FLAG_TC2);//清除通道2传输完成标志&nbsp;6&nbsp;DMA_Cmd(DMA1_Channel2,&nbsp;DISABLE);//禁止DMA&nbsp;&nbsp;7&nbsp;SPI_Cmd(SPI1,&nbsp;DISABLE);&nbsp;//禁止SPI，只在开启SPI时接收数据，防止主机不断发送&nbsp;8&nbsp;//////////以下可以把数据传输走//////////&nbsp;9&nbsp;for(i=0;i&lt;256;i++)10&nbsp;data_repo_short[i]&nbsp;=&nbsp;spi_rx_buff[i];</pre><p></p><p><span class=\"cnblogs_code_collapse\">SPI从机配置代码</span></p><p>下图是我用FPGA作为SPI主机产生的读写时序，可以看到此时SPI可以达到很高的通信效率。提高SCK的主频后，通信速度上限10Mbytes/S左右（主要受限于STM32的接收SCK频率）。</p><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/a8ca7e97-bf2d-4f24-b7c7-b7339dcdbcfc.png\" alt=\"\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"/></p><p style=\"text-align:center;\">FPGA产生的SPI主机时序,STM32做从机</p><p>&nbsp;<strong>三、总结</strong></p><p>STM32的SPI接口并不完美，仍然存在各种小问题，尤其是在SPI作为主机受DMA控制传输大量数据时，效率并不能得到很大提升。但当STM32的SPI作为从机时，DMA控制的数据传输，能够较大的提升数据常数效率。</p><p>&nbsp;</p>',1,NULL,1,'https://www.cnblogs.com/helesheng/p/16757245.html','2022-10-07 17:31:30'),(41,'MySQL用户也可以是个角色','前言角色（Role），可以认为是一些权限的集合，一直是存在各个数据库中，比如Oracle、SQL Server、OceanBase等，MySQL 自从 8.0 release 才引入角色这个概念。为用户赋予统一的角色，即把一个带有某些权限集合的角色分配给一个用户，那该用户就拥有了该角色所包含的所有权限，权限的','2022-10-07 18:20:52',0,0,'<h1 id=\"cvLy-1665134728397\">前言</h1><p><span style=\"font-size: 16px\">角色（Role），可以认为是一些权限的集合，一直是存在各个数据库中，比如Oracle、SQL Server、OceanBase等，MySQL 自从 8.0 release 才引入角色这个概念。</span></p><p><span style=\"font-size: 16px\">为用户赋予统一的角色，即把一个带有某些权限集合的角色分配给一个用户，那该用户就拥有了该角色所包含的所有权限，权限的修改直接通过角色来进行，无需为每个用户单独授权，大大的方便了权限管理。</span></p><h1 id=\"cvLy-1665134728397\">一、回顾MySQL 8.0之前的用户管理</h1><h2>1、创建用户(默认缺省)</h2><p><span style=\"font-size: 16px\">从 CREATE USER 的 help 语法解释中发现，其不仅可以创建新的 MySQL 帐户，还支持为新帐户建立身份验证、SSL/TLS、资源限制和密码管理属性，并控制帐户最初是锁定还是解锁。</span></p><p><span style=\"font-size: 16px\">那么，缺省选项默认创建的用户是怎么样的呢？</span></p><pre>mysql&gt;&nbsp;CREATE&nbsp;USER&nbsp;kuzma&nbsp;IDENTIFIED&nbsp;BY&nbsp;&#39;iamkuzma&#39;;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.07&nbsp;sec)&nbsp;mysql&gt;&nbsp;select&nbsp;*&nbsp;from&nbsp;mysql.user&nbsp;where&nbsp;User=&quot;kuzma&quot;\\G&nbsp;***************************&nbsp;1.&nbsp;row&nbsp;***************************&nbsp;Host:&nbsp;%\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;User:&nbsp;kuzma&nbsp;Select_priv:&nbsp;N&nbsp;Insert_priv:&nbsp;N&nbsp;Update_priv:&nbsp;N&nbsp;Delete_priv:&nbsp;N&nbsp;Create_priv:&nbsp;N&nbsp;Drop_priv:&nbsp;N&nbsp;Reload_priv:&nbsp;N&nbsp;Shutdown_priv:&nbsp;N&nbsp;Process_priv:&nbsp;N&nbsp;File_priv:&nbsp;N&nbsp;Grant_priv:&nbsp;N&nbsp;References_priv:&nbsp;N&nbsp;Index_priv:&nbsp;N&nbsp;Alter_priv:&nbsp;N&nbsp;Show_db_priv:&nbsp;N&nbsp;Super_priv:&nbsp;N&nbsp;Create_tmp_table_priv:&nbsp;N&nbsp;Lock_tables_priv:&nbsp;N&nbsp;Execute_priv:&nbsp;N&nbsp;Repl_slave_priv:&nbsp;N&nbsp;Repl_client_priv:&nbsp;N&nbsp;Create_view_priv:&nbsp;N&nbsp;Show_view_priv:&nbsp;N&nbsp;Create_routine_priv:&nbsp;N&nbsp;Alter_routine_priv:&nbsp;N&nbsp;Create_user_priv:&nbsp;N&nbsp;Event_priv:&nbsp;N&nbsp;Trigger_priv:&nbsp;N&nbsp;Create_tablespace_priv:&nbsp;N&nbsp;ssl_type:&nbsp;ssl_cipher:&nbsp;0x&nbsp;x509_issuer:&nbsp;0x&nbsp;x509_subject:&nbsp;0x&nbsp;max_questions:&nbsp;0&nbsp;max_updates:&nbsp;0&nbsp;max_connections:&nbsp;0&nbsp;max_user_connections:&nbsp;0&nbsp;plugin:&nbsp;mysql_native_password&nbsp;authentication_string:&nbsp;*E2D9547BC3A2AD2EEC6BE9636489AC973656EEB9&nbsp;password_expired:&nbsp;N&nbsp;password_last_changed:&nbsp;2022-10-05&nbsp;17:41:06&nbsp;password_lifetime:&nbsp;NULL&nbsp;account_locked:&nbsp;N&nbsp;1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.06&nbsp;sec)</pre><p></p><p><span style=\"font-size: 16px\">如上，在 CREATE USER&nbsp;后会在 mysql.user 系统表中注册相关用户信息，未指定的属性设置为其默认值：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">帐户名的主机名部分，如果省略，则默认为&#39;%&#39;，即 &#39;kuzma&#39;@&#39;%&#39;，表示不限主机连接</span></p></li><li><p><span style=\"font-size: 16px\">Authentication：系统变量定义的认证插件 default_authentication_plugin&nbsp;= mysql_native_password ，空凭证</span></p></li><li><p><span style=\"font-size: 16px\">SSL/TLS：NONE</span></p></li><li><p><span style=\"font-size: 16px\">资源限制：无限制，max_questions最大查询数、max_updates最大更新数等都为0（默认值），即未做限制</span></p></li><li><p><span style=\"font-size: 16px\">密码管理：PASSWORD EXPIRE DEFAULT</span></p></li><li><p><span style=\"font-size: 16px\">密码过期：NONE，未设定，即永不过期</span></p></li><li><p><span style=\"font-size: 16px\">账户锁定：ACCOUNT UNLOCK，未锁定</span></p></li></ul><p><span style=\"font-size: 16px\">首次创建的帐户没有权限，xxx_priv都为NONE，默认未设置用户权限，若需要分配权限，另外的通过 GRANT 语句为用户授权。</span></p><p><span style=\"font-size: 16px\">若要删除用户，DROP USER &#39;kuzma&#39;@&#39;%&#39;; 注意指定用户名和主机名。</span></p><h2 id=\"vs1c-1665134728529\">2、带选项创建用户</h2><h3 id=\"DqVn-1665134728531\">2.1、设置密码过期</h3><pre>#&nbsp;将密码标记为过期，用户在第一次连接到服务器时必须选择一个新密码&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;PASSWORD&nbsp;EXPIRE;&nbsp;#&nbsp;默认过期时间，应用&nbsp;default_password_lifetime&nbsp;系统变量指定的全局过期策略&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;DEFAULT;&nbsp;#&nbsp;禁用密码过期，永不过期&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;NEVER;&nbsp;#&nbsp;设定过期时间，每&nbsp;180&nbsp;天选择一个新密码&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;PASSWORD&nbsp;EXPIRE&nbsp;INTERVAL&nbsp;180&nbsp;DAY;</pre><p></p><h3>2.2、身份验证及SSL/TLS</h3><pre>#&nbsp;指定身份验证插件，及明文密码值&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;IDENTIFIED&nbsp;WITH&nbsp;mysql_native_password&nbsp;BY&nbsp;&#39;iamkuzma&#39;;&nbsp;#&nbsp;CREATE&nbsp;USER&nbsp;时指定&nbsp;tls_option&nbsp;值&nbsp;#&nbsp;注：生产数据库通常不会做加密连接，减少不必要的连接限制&nbsp;tls_option:&nbsp;{&nbsp;SSL&nbsp;|&nbsp;X509&nbsp;|&nbsp;CIPHER&nbsp;&#39;cipher&#39;\n&nbsp;|&nbsp;ISSUER&nbsp;&#39;issuer&#39;\n&nbsp;|&nbsp;SUBJECT&nbsp;&#39;subject&#39;&nbsp;}&nbsp;#&nbsp;默认缺省为REQUIRE&nbsp;NONE，即没有&nbsp;SSL&nbsp;或&nbsp;X.509&nbsp;要求，如果用户名和密码有效，则允许未加密的连接&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;REQUIRE&nbsp;NONE;&nbsp;#&nbsp;加密连接限制，如果客户端无法建立安全连接，则连接尝试失败&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;REQUIRE&nbsp;SSL;</pre><p></p><h3>2.3、资源限制</h3><pre>resource_option:&nbsp;{&nbsp;MAX_QUERIES_PER_HOUR&nbsp;count&nbsp;#&nbsp;允许该用户每小时多少查询&nbsp;|&nbsp;MAX_UPDATES_PER_HOUR&nbsp;count&nbsp;#&nbsp;允许该用户每小时多少更新&nbsp;|&nbsp;MAX_CONNECTIONS_PER_HOUR&nbsp;count&nbsp;#&nbsp;允许该用户每小时多少连接到服务器&nbsp;|&nbsp;MAX_USER_CONNECTIONS&nbsp;count&nbsp;#&nbsp;限制该用户同时连接到服务器的最大数量&nbsp;}&nbsp;#&nbsp;限制用户每小时的查询和更新数&nbsp;CREATE&nbsp;USER&nbsp;&#39;kuzma&#39;@&#39;localhost&#39;&nbsp;WITH&nbsp;MAX_QUERIES_PER_HOUR&nbsp;500&nbsp;MAX_UPDATES_PER_HOUR&nbsp;100;</pre><p></p><p><span style=\"font-size: 16px\">如果count为0（默认值），表示该用户没有限制。通常生产用户不会在数据库层做资源限制，但某些特殊用户特殊场景下，可通过进行资源限制实现限流。</span></p><h3 id=\"C38F-1665134728608\">2.4、账户锁定</h3><p><span style=\"font-size: 16px\">CREATE USER 和 ALTER USER 中使用 ACCOUNT LOCK 和 ACCOUNT UNLOCK 选项支持用户的锁定和解锁；</span></p><p><span style=\"font-size: 16px\">常见场景：数据库、业务迁移，用户切新改造等，通过对用户的锁定和解锁，实现对业务连接控制。</span></p><h2 id=\"NrHZ-1665134728615\">3、授权用户</h2><p><span style=\"font-size: 16px\">使用 GRANT 给用户授权，REVOKE 给用户撤权（需要操作者拥有&nbsp;GRANT OPTION 权限）。支持用户对库、表、列、存储过程、代理用户</span></p><pre>#&nbsp;授权[kuzma_write]用户{查询、插入、更新、删除}所有库表(*表示所有，db1.*表示db1库下的所有表)&nbsp;GRANT&nbsp;SELECT,&nbsp;INSERT,&nbsp;UPDATE,&nbsp;DELETE&nbsp;ON&nbsp;*.*&nbsp;TO&nbsp;kuzma_write;&nbsp;#&nbsp;撤销[kuzma_write]用户的删除权限&nbsp;REVOKE&nbsp;DELETE&nbsp;ON&nbsp;*.*&nbsp;FROM&nbsp;&#39;kuzma_write&#39;@&#39;%&#39;;&nbsp;#&nbsp;设置列权限-----虽然但是有时业务还就是有这样的需求#&nbsp;1.列权限类型有且仅包括INSERT、REFERENCES(创建外键约束)、SELECT&nbsp;和&nbsp;UPDATE，权限后括号内给定表中的一个或多个列&nbsp;#&nbsp;2.列权限存储在&nbsp;mysql.columns_priv，其中的Column_priv列是一个枚举列，亦可说明为什么列权限&quot;有且仅&quot;4种权限&nbsp;GRANT&nbsp;SELECT&nbsp;(col1),&nbsp;INSERT&nbsp;(col1,&nbsp;col2)&nbsp;ON&nbsp;db1.tbl2&nbsp;TO&nbsp;&#39;xxx_user&#39;@&#39;xxx_host&#39;;&nbsp;#&nbsp;授权存储过程的创建和执行&nbsp;GRANT&nbsp;CREATE&nbsp;ROUTINE&nbsp;ON&nbsp;db1.*&nbsp;TO&nbsp;&#39;xxx_user&#39;@&#39;xxx_host&#39;;&nbsp;GRANT&nbsp;EXECUTE&nbsp;ON&nbsp;PROCEDURE&nbsp;db1.proc2&nbsp;TO&nbsp;&#39;xxx_user&#39;@&#39;xxx_host&#39;;&nbsp;#&nbsp;代理用户&nbsp;#&nbsp;该PROXY权限使一个用户可以成为另一个用户的代理，代理用户冒充或冒用被代理用户的身份，实现权限的复制&nbsp;GRANT&nbsp;PROXY&nbsp;ON&nbsp;&#39;localuser&#39;@&#39;localhost&#39;&nbsp;TO&nbsp;&#39;xxx_user&#39;@&#39;xxx_host&#39;;</pre><p></p><p><span style=\"font-size: 16px\">权限元数据存储位置：</span></p><table><colgroup><col/><col/></colgroup><tbody><tr><td data-cell-id=\"58RE-1665134728657\"><p><span style=\"font-size: 16px\">权限类型</span>\n &nbsp; &nbsp;</p></td><td data-cell-id=\"hiRT-1665134728660\"><p><span style=\"font-size: 16px\">元数据存储-系统表</span>\n &nbsp; &nbsp;</p></td></tr><tr><td data-cell-id=\"3f3R-1665134728664\"><p><span style=\"font-size: 16px\">用户全局权限</span>\n &nbsp; &nbsp;</p></td><td data-cell-id=\"PHZj-1665134728667\"><p><span style=\"font-size: 16px\">mysql.user</span>\n &nbsp; &nbsp;</p></td></tr><tr><td data-cell-id=\"EzoN-1665134728671\"><p><span style=\"font-size: 16px\">数据库（DB）权限</span>\n &nbsp; &nbsp;</p></td><td data-cell-id=\"rMYd-1665134728674\"><p><span style=\"font-size: 16px\">mysql.db</span>\n &nbsp; &nbsp;</p></td></tr><tr><td data-cell-id=\"SaGX-1665134728678\"><p><span style=\"font-size: 16px\">表（table）权限</span>\n &nbsp; &nbsp;</p></td><td data-cell-id=\"SGVz-1665134728681\"><p><span style=\"font-size: 16px\">mysql.tables_priv</span>\n &nbsp; &nbsp;</p></td></tr><tr><td data-cell-id=\"Iyob-1665134728685\"><p><span style=\"font-size: 16px\">列（columns）权限</span>\n &nbsp; &nbsp;</p></td><td data-cell-id=\"f4e7-1665134728688\"><p><span style=\"font-size: 16px\">mysql.columns_priv</span>\n &nbsp; &nbsp;</p></td></tr><tr><td data-cell-id=\"lWM8-1665134728692\"><p><span style=\"font-size: 16px\">routine-level（procedures and functions）权限</span>\n &nbsp; &nbsp;</p></td><td data-cell-id=\"USgX-1665134728695\"><p><span style=\"font-size: 16px\">mysql.procs_priv</span>\n &nbsp; &nbsp;</p></td></tr><tr><td data-cell-id=\"RiU3-1665134728699\"><p><span style=\"font-size: 16px\">代理（proxy）用户权限</span>\n &nbsp; &nbsp;</p></td><td data-cell-id=\"8fMG-1665134728702\"><p><span style=\"font-size: 16px\">mysql.proxies_priv</span>\n &nbsp; &nbsp;</p></td></tr></tbody></table><p><span style=\"font-size: 16px\">Tips：值得注意的是，在某些情况下，无论是 CREATE|ALTER USER 还是 GRANT 都可能会记录在服务器日志中或客户端的历史文件中，例如&nbsp;~/.mysql_history，这就意味着任何有权读取该信息的人都可以读取明文密码，这不就暴露了吗。</span></p><p>&nbsp;</p><h1 id=\"JrD8-1665134728710\">二、瞅瞅其他数据库的用户角色管理</h1><h2 id=\"5dRM-1665134728712\">1、SQL Server的用户角色</h2><p><span style=\"font-size: 16px\">服务器级别角色：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">全局权限，只登入名（如超级管理员的登录名是sa）拥有；</span></p></li><li><p><span style=\"font-size: 16px\">服务器角色是固定的（包括：sysadmin、setupadmin、serveradmin等），用户无法创建服务器角色，一般也不建议给用户直接分配服务器角色。</span></p></li></ul><p><span style=\"font-size: 16px\">数据库级别角色：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">作用域为数据库，拥有者可以是用户也可以是数据库角色本身，可以理解数据库角色就是一组相同权限的用户；</span></p></li><li><p><span style=\"font-size: 16px\">两种类型的数据库级角色：数据库中预定义的“固定数据库角色（fixed-database roles）”（包括：db_owner、db_ddladmin、db_datawriter等）和可以创建的“用户定义数据库角色（user-defined database roles）”。</span></p></li><li><p><span style=\"font-size: 16px\">请不要将用户定义的数据库角色添加为固定角色的成员，否则会导致意外的权限升级。</span></p></li></ul><p><span style=\"font-size: 16px\">应用程序角色：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">一个数据库级主体，使应用程序能够用其自身的、类似用户的权限来运行，可以只允许通过特定应用程序连接的用户访问特定数据；</span></p></li><li><p><span style=\"font-size: 16px\">与数据库角色不同的是，应用程序角色默认情况下不包含任何成员，而且是非活动的；</span></p></li><li><p><span style=\"font-size: 16px\">默认应用程序角色无法访问服务器级元数据，因为它们不与服务器级主体关联，通过设置全局标志 4616 可放开限制。</span></p></li></ul><p><span style=\"font-size: 16px\">用户：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">数据库用户必须绑定具体的登入名，也可以在新建登入名的时候绑定此登入名拥有的数据库，默认就创建了此登入名同名的数据库用户，登入名与数据库用户之间就存在关联关系；</span></p></li><li><p><span style=\"font-size: 16px\">数据库用户是架构和数据库角色的拥有者，即可以将某个架构分配给用户，那么该用户就拥有了该架构所包含的对象；也可以将某个数据库角色分配给用户，此用户就拥有该数据库角色的权限。</span></p></li></ul><pre>#&nbsp;创建登录名[stu]，并为登录名指定用户[student_user]create&nbsp;user&nbsp;student_user&nbsp;for&nbsp;login&nbsp;stu;&nbsp;#&nbsp;创建角色[student_role]并为角色授权&nbsp;create&nbsp;role&nbsp;student_role;&nbsp;grant&nbsp;select,&nbsp;update,&nbsp;insert&nbsp;on&nbsp;db_book&nbsp;to&nbsp;student_role;&nbsp;#&nbsp;将角色授予用户:student_role授予student_user&nbsp;exec&nbsp;sp_addrolemember&nbsp;@rolename=&#39;student_role&#39;,&nbsp;@membername=&#39;student_user&#39;;</pre><p></p><h2 id=\"Wt6w-1665134728762\">2、OceanBase的用户角色</h2><p><span style=\"font-size: 16px\">角色管理：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">角色是为用户赋予各种权限的一种对象，为多种权限的集合，使用角色可将一组具有相同权限的用户组织在一起；</span></p></li><li><p><span style=\"font-size: 16px\">内置角色：ODC（OceanBase Developer Center，OB开发者中心） 中内置了管理员角色&nbsp;system_admin&nbsp;，该角色被自动赋予给管理员用户&nbsp;admin&nbsp;，该角色可进行系统有关的所有操作且默认可访问所有的公共资源和个人资源&nbsp;，&nbsp;该角色不支持被编辑、删除和停用；</span></p></li><li><p><span style=\"font-size: 16px\">自定义新建角色：通过 ODC 新建角色，可支持设置&nbsp;公共资源权限&nbsp;和&nbsp;个人资源权限。</span></p></li></ul><p><span style=\"font-size: 16px\">用户管理：</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">内置用户：ODC 中已内置一个管理员账户&nbsp;admin&nbsp;，该账户被自动设置为了管理员角色&nbsp;system_admin&nbsp;，所以该账户可进行系统有关的所有操作且默认可访问所有的公共资源，该账户不支持被编辑、删除和停用；</span></p></li><li><p><span style=\"font-size: 16px\">自定义新建用户：新建用户操作包括指定用户信息、为新建用户指定角色等，同时可在 ODC 中对用户进行查看、编辑等相关管理操作。</span></p></li></ul><p>&nbsp;</p><h1 id=\"M26W-1665134728780\">三、再看MySQL 8.0的用户角色管理</h1><h2 id=\"BieJ-1665134728782\">1、创建角色并授权</h2><pre>#&nbsp;1.创建角色：创建三个角色，分别作为[app_db]的owner、read、write角色&nbsp;CREATE&nbsp;ROLE&nbsp;&#39;app_owner&#39;,&nbsp;&#39;app_read&#39;,&nbsp;&#39;app_write&#39;;&nbsp;#&nbsp;2.角色授权：按功能分别给不同角色授权&nbsp;GRANT&nbsp;ALL&nbsp;ON&nbsp;app_db.*&nbsp;TO&nbsp;&#39;app_owner&#39;;&nbsp;GRANT&nbsp;SELECT&nbsp;ON&nbsp;app_db.*&nbsp;TO&nbsp;&#39;app_read&#39;;&nbsp;GRANT&nbsp;INSERT,&nbsp;UPDATE,&nbsp;DELETE&nbsp;ON&nbsp;app_db.*&nbsp;TO&nbsp;&#39;app_write&#39;;&nbsp;#&nbsp;3.创建用户：根据业务需求创建三个用户&nbsp;CREATE&nbsp;USER&nbsp;admin_user&nbsp;IDENTIFIED&nbsp;BY&nbsp;&#39;xxx_pass1&#39;;&nbsp;CREATE&nbsp;USER&nbsp;read_user1&nbsp;IDENTIFIED&nbsp;BY&nbsp;&#39;xxx_pass2&#39;;&nbsp;CREATE&nbsp;USER&nbsp;read_user2&nbsp;IDENTIFIED&nbsp;BY&nbsp;&#39;xxx_pass3&#39;;&nbsp;CREATE&nbsp;USER&nbsp;rw_user1&nbsp;IDENTIFIED&nbsp;BY&nbsp;&#39;xxx_pass4&#39;;&nbsp;#&nbsp;4.用户分配角色：对应的为用户授予角色&nbsp;GRANT&nbsp;&#39;app_owner&#39;&nbsp;TO&nbsp;admin_user;&nbsp;GRANT&nbsp;&#39;app_read&#39;&nbsp;TO&nbsp;read_user1,&nbsp;read_user2;&nbsp;#&nbsp;授权读和写角色，即授权rw_user1用户读写权限&nbsp;---&gt;&nbsp;一个用户可以拥有多个角色，也就拥有这多个角色的权限集合GRANT&nbsp;&#39;app_read&#39;,&nbsp;&#39;app_write&#39;&nbsp;TO&nbsp;rw_user1;&nbsp;#&nbsp;&#39;app_owner&#39;,&nbsp;&#39;app_read&#39;,&nbsp;&#39;app_write&#39;&nbsp;三个角色在&nbsp;mysql.user&nbsp;中&nbsp;password_expired、account_locked&nbsp;都是&nbsp;Y&nbsp;，说明角色在&nbsp;user&nbsp;表作为&quot;角色&quot;的存在；&nbsp;#&nbsp;mysql.db&nbsp;中&nbsp;Db:&nbsp;app_db&nbsp;的权限划分，是按照三个角色来的(即角色授权)，并没有因为用户分配了角色之后又给到用户&nbsp;mysql&gt;&nbsp;show&nbsp;grants&nbsp;for&nbsp;app_read;&nbsp;+----------------------------------------------+|&nbsp;Grants&nbsp;for&nbsp;app_read@%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+----------------------------------------------+|&nbsp;GRANT&nbsp;USAGE&nbsp;ON&nbsp;*.*&nbsp;TO&nbsp;`app_read`@`%`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;GRANT&nbsp;SELECT&nbsp;ON&nbsp;`app_db`.*&nbsp;TO&nbsp;`app_read`@`%`&nbsp;|+----------------------------------------------+2&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.07&nbsp;sec)&nbsp;mysql&gt;&nbsp;show&nbsp;grants&nbsp;for&nbsp;rw_user1;&nbsp;+--------------------------------------------------------+|&nbsp;Grants&nbsp;for&nbsp;rw_user1@%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+--------------------------------------------------------+|&nbsp;GRANT&nbsp;USAGE&nbsp;ON&nbsp;*.*&nbsp;TO&nbsp;`rw_user1`@`%`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;GRANT&nbsp;`app_read`@`%`,`app_write`@`%`&nbsp;TO&nbsp;`rw_user1`@`%`&nbsp;|+--------------------------------------------------------+2&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.06&nbsp;sec)</pre><p></p><p><span style=\"font-size: 16px\">这就结束了？</span></p><pre>#&nbsp;使用&nbsp;[read_user1]&nbsp;用户登录&nbsp;$&nbsp;mysql&nbsp;-u&nbsp;read_user1&nbsp;-p&nbsp;#&nbsp;并没有已授权的[app_db]&nbsp;mysql&gt;&nbsp;show&nbsp;databases;&nbsp;+--------------------+|&nbsp;Database&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+--------------------+|&nbsp;information_schema&nbsp;|+--------------------+1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)&nbsp;#&nbsp;当前也没有任何角色生效&nbsp;mysql&gt;&nbsp;SELECT&nbsp;CURRENT_ROLE();&nbsp;+----------------+|&nbsp;CURRENT_ROLE()&nbsp;|+----------------+|&nbsp;NONE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+----------------+1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.00&nbsp;sec)</pre><p></p><p><span style=\"font-size: 16px\">当然，没有结束，默认情况前面创建的角色并未被激活，最后一步是还需要“激活角色”：</span></p><pre>#&nbsp;5.激活角色：即设置用户的默认角色，前提是用户有分配角色(前第4步)&nbsp;#&nbsp;设置用户&nbsp;[admin_user]&nbsp;登录的默认角色是&nbsp;{app_owner}&nbsp;SET&nbsp;DEFAULT&nbsp;ROLE&nbsp;&#39;app_owner&#39;&nbsp;TO&nbsp;admin_user;&nbsp;#&nbsp;一步到位：SET&nbsp;DEFAULT&nbsp;ROLE&nbsp;ALL，指的是将用户所有的角色都设置为默认角色&nbsp;SET&nbsp;DEFAULT&nbsp;ROLE&nbsp;ALL&nbsp;TO&nbsp;admin_user,&nbsp;read_user1,&nbsp;read_user2,&nbsp;rw_user1;&nbsp;#&nbsp;查看默认角色设置&nbsp;mysql&gt;&nbsp;select&nbsp;*&nbsp;from&nbsp;mysql.default_roles;&nbsp;+------+------------+-------------------+-------------------+|&nbsp;HOST&nbsp;|&nbsp;USER&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;DEFAULT_ROLE_HOST&nbsp;|&nbsp;DEFAULT_ROLE_USER&nbsp;|+------+------------+-------------------+-------------------+|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;admin_user&nbsp;|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;app_owner&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;read_user1&nbsp;|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;app_read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;read_user2&nbsp;|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;app_read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;rw_user1&nbsp;&nbsp;&nbsp;|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;app_read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;rw_user1&nbsp;&nbsp;&nbsp;|&nbsp;%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;app_write&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+------+------------+-------------------+-------------------+5&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.06&nbsp;sec)&nbsp;#&nbsp;若要删除默认角色设置：SET&nbsp;DEFAULT&nbsp;ROLE&nbsp;none&nbsp;TO&nbsp;user_name;&nbsp;#&nbsp;另一种激活角色方式：通过设置&nbsp;activate_all_roles_on_login&nbsp;=&nbsp;ON，实现用户登录时自动激活角色</pre><p></p><h2 id=\"et6Y-1665134728949\">2、会话间的角色互换</h2><p><span style=\"font-size: 16px\">拥有多角色的用户，在当前会话里可以进行角色互换：SET ROLE role_name;</span></p><pre>$&nbsp;mysql-u&nbsp;rw_user1&nbsp;-p&nbsp;#&nbsp;如前设置，激活默认是全部角色&nbsp;mysql&gt;&nbsp;select&nbsp;current_role();&nbsp;+--------------------------------+|&nbsp;current_role()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+--------------------------------+|&nbsp;`app_read`@`%`,`app_write`@`%`&nbsp;|+--------------------------------+1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.05&nbsp;sec)&nbsp;#&nbsp;切换到角色&nbsp;{app_read}&nbsp;mysql&gt;&nbsp;set&nbsp;role&nbsp;app_read;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.05&nbsp;sec)&nbsp;mysql&gt;&nbsp;select&nbsp;current_role();&nbsp;+----------------+|&nbsp;current_role()&nbsp;|+----------------+|&nbsp;`app_read`@`%`&nbsp;|+----------------+1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.06&nbsp;sec)&nbsp;#&nbsp;app_read&nbsp;角色是只读权限，insert操作是被拒绝的&nbsp;mysql&gt;&nbsp;insert&nbsp;into&nbsp;app_db.t1(id)&nbsp;values(1);&nbsp;ERROR&nbsp;1142&nbsp;(42000):&nbsp;INSERT&nbsp;command&nbsp;denied&nbsp;to&nbsp;user&nbsp;&#39;rw_user1&#39;@&#39;10.99.17.133&#39;&nbsp;for&nbsp;table&nbsp;&#39;t1&#39;&nbsp;#&nbsp;切换到角色&nbsp;{app_write}&nbsp;mysql&gt;&nbsp;set&nbsp;role&nbsp;app_write;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.05&nbsp;sec)&nbsp;mysql&gt;&nbsp;select&nbsp;current_role();&nbsp;+-----------------+|&nbsp;current_role()&nbsp;&nbsp;|+-----------------+|&nbsp;`app_write`@`%`&nbsp;|+-----------------+1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.05&nbsp;sec)&nbsp;#&nbsp;切换到&nbsp;app_write&nbsp;角色是有插入权限，insert成功&nbsp;mysql&gt;&nbsp;insert&nbsp;into&nbsp;app_db.t1(id)&nbsp;values(1);&nbsp;Query&nbsp;OK,&nbsp;1&nbsp;row&nbsp;affected&nbsp;(0.10&nbsp;sec)</pre><p></p><h2 id=\"eoB9-1665134729028\">3、何为强制角色</h2><p><span style=\"font-size: 16px\">mandatory_roles：强制所有用户默认角色，可以通过在 mandatory_roles 系统变量的值中命名角色，可以将角色指定为强制角色 ，服务器将强制角色视为授予所有用户，因此无需明确授予任何帐户。</span></p><pre>#&nbsp;设置强制给所有用户赋予角色{app_read}&nbsp;mysql&gt;&nbsp;set&nbsp;global&nbsp;mandatory_roles&nbsp;=&nbsp;&#39;app_read&#39;;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.06&nbsp;sec)&nbsp;#&nbsp;顺便设置默认激活角色&nbsp;mysql&gt;&nbsp;set&nbsp;global&nbsp;activate_all_roles_on_login&nbsp;=&nbsp;on;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.06&nbsp;sec)&nbsp;#&nbsp;创建新用户[kuzma]&nbsp;mysql&gt;&nbsp;CREATE&nbsp;USER&nbsp;kuzma&nbsp;IDENTIFIED&nbsp;BY&nbsp;&#39;xxx&#39;;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.06&nbsp;sec)&nbsp;#&nbsp;用户[kuzma]登录&nbsp;$&nbsp;mysql&nbsp;-u&nbsp;kuzma&nbsp;-p&nbsp;#&nbsp;查看用户权限，是被挂上了&quot;强制角色&quot;{app_read}的&nbsp;&gt;&nbsp;show&nbsp;grants;&nbsp;+-------------------------------------------+|&nbsp;Grants&nbsp;for&nbsp;kuzma@%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+-------------------------------------------+|&nbsp;GRANT&nbsp;USAGE&nbsp;ON&nbsp;*.*&nbsp;TO&nbsp;`kuzma`@`%`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;GRANT&nbsp;SELECT&nbsp;ON&nbsp;`app_db`.*&nbsp;TO&nbsp;`kuzma`@`%`&nbsp;||&nbsp;GRANT&nbsp;`app_read`@`%`&nbsp;TO&nbsp;`kuzma`@`%`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+-------------------------------------------+3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.05&nbsp;sec)</pre><p></p><h2 id=\"c5Xe-1665134729078\">4、撤销/删除角色</h2><pre>#&nbsp;撤销角色，从用户上拿掉某一角色，即同时的撤销该角色拥有的权限集合&nbsp;REVOKE&nbsp;role_name&nbsp;FROM&nbsp;user_name;&nbsp;#&nbsp;回收角色上的授权(和旧时的用户回收权限类似)&nbsp;REVOKE&nbsp;DELETE&nbsp;ON&nbsp;db_name.*&nbsp;FROM&nbsp;role_name;&nbsp;#&nbsp;删除角色&nbsp;DROP&nbsp;ROLE&nbsp;role_name1,&nbsp;role_name2;</pre><p></p><p><span style=\"font-size: 16px\">注意：无论是撤销，还是删除，都不能动 mandatory_roles 系统变量值中的强制角色。</span></p><h2>5、用户也可以是个角色</h2><p><span style=\"font-size: 16px\">没错，用户也可以是个角儿 ^_~，这是怎么回事儿呢？其实，就用户也可以当角色来用的：</span></p><pre>#&nbsp;8.0以前的MySQL&nbsp;GRANT语法中，用户权限授予到另一个用户上是违法的&nbsp;mysql&gt;&nbsp;select&nbsp;@@version;&nbsp;+------------+|&nbsp;@@version&nbsp;&nbsp;|+------------+|&nbsp;5.7.26-log&nbsp;|+------------+1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.06&nbsp;sec)&nbsp;mysql&gt;&nbsp;CREATE&nbsp;USER&nbsp;user1,&nbsp;user2;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.05&nbsp;sec)&nbsp;mysql&gt;&nbsp;GRANT&nbsp;user1&nbsp;TO&nbsp;user2;&nbsp;ERROR&nbsp;1064&nbsp;(42000):&nbsp;You&nbsp;have&nbsp;an&nbsp;error&nbsp;in&nbsp;your&nbsp;SQL&nbsp;syntax;&nbsp;check&nbsp;the&nbsp;manual&nbsp;that&nbsp;corresponds&nbsp;to&nbsp;your&nbsp;MySQL&nbsp;server&nbsp;version&nbsp;for&nbsp;the&nbsp;right&nbsp;syntax&nbsp;to&nbsp;use&nbsp;near&nbsp;&#39;user1&nbsp;TO&nbsp;user2&#39;&nbsp;at&nbsp;line&nbsp;1&nbsp;#&nbsp;8.0之后是实现了用户和角色可互换性&nbsp;mysql&gt;&nbsp;select&nbsp;@@version;&nbsp;+-----------+|&nbsp;@@version&nbsp;|+-----------+|&nbsp;8.0.23&nbsp;&nbsp;&nbsp;&nbsp;|+-----------+1&nbsp;row&nbsp;in&nbsp;set&nbsp;(0.05&nbsp;sec)&nbsp;mysql&gt;&nbsp;CREATE&nbsp;USER&nbsp;user1,&nbsp;user2;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.07&nbsp;sec)&nbsp;#&nbsp;给用户[user1]授权&nbsp;mysql&gt;&nbsp;GRANT&nbsp;SELECT&nbsp;ON&nbsp;app_db.*&nbsp;TO&nbsp;user1;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.06&nbsp;sec)&nbsp;#&nbsp;把[user1]的权限授予给[user2]&nbsp;---&gt;&nbsp;未报错，语法通过的mysql&gt;&nbsp;GRANT&nbsp;user1&nbsp;TO&nbsp;user2;&nbsp;Query&nbsp;OK,&nbsp;0&nbsp;rows&nbsp;affected&nbsp;(0.06&nbsp;sec)&nbsp;#&nbsp;查看[user2]的权限，可以看到是把[user1]用户作为一个角色来授予&nbsp;mysql&gt;&nbsp;SHOW&nbsp;GTANTS&nbsp;FOR&nbsp;user2;&nbsp;+-----------------------------------+|&nbsp;Grants&nbsp;for&nbsp;user2@%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+-----------------------------------+|&nbsp;GRANT&nbsp;USAGE&nbsp;ON&nbsp;*.*&nbsp;TO&nbsp;`user2`@`%`&nbsp;||&nbsp;GRANT&nbsp;`user1`@`%`&nbsp;TO&nbsp;`user2`@`%`&nbsp;&nbsp;|+-----------------------------------+2&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.05&nbsp;sec)&nbsp;#&nbsp;查看[user2]的详细权限&nbsp;mysql&gt;&nbsp;SHOW&nbsp;GTANTS&nbsp;FOR&nbsp;user2&nbsp;USING&nbsp;user1;&nbsp;+-------------------------------------------+|&nbsp;Grants&nbsp;for&nbsp;user2@%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+-------------------------------------------+|&nbsp;GRANT&nbsp;USAGE&nbsp;ON&nbsp;*.*&nbsp;TO&nbsp;`user2`@`%`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;||&nbsp;GRANT&nbsp;SELECT&nbsp;ON&nbsp;`app_db`.*&nbsp;TO&nbsp;`user2`@`%`&nbsp;||&nbsp;GRANT&nbsp;`user1`@`%`&nbsp;TO&nbsp;`user2`@`%`&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|+-------------------------------------------+3&nbsp;rows&nbsp;in&nbsp;set&nbsp;(0.05&nbsp;sec)</pre><p>&nbsp;</p><p><span style=\"font-size: 16px\">由此可见，用户和角色是可以互换使用的。</span></p><ul class=\" list-paddingleft-2\"><li><p><span style=\"font-size: 16px\">角色和用户之间的一个区别是，CREATE ROLE 创建的授权标识符默认是锁定的（mysql.user 可查看），而 CREATE USER 创建的授权标识符默认是解锁的。但是，区别并不是不可变的，因为可以在创建角色或用户后锁定或解锁角色或用户。</span></p></li><li><p><span style=\"font-size: 16px\">权限角度来看，CREATE USER 是包含了 CREATE ROLE，也就是说，CREATE USER 即可以创建用户，也可以创建角色。</span></p></li></ul><h1 id=\"9J8m-1665134729207\">总结</h1><p><span style=\"font-size: 16px\">本文简单介绍了数据库用户和角色的权限管理应用，包括 MySQL 8.0 对角色的引入，虽然目前生产数据库暂未对角色进行更多的应用，当其实现了权限管理的多样化和精细化，可以更好地权限分离，能够满足某些特殊场景下对权限管理的需求，还是很值得期待的。</span></p>',2,NULL,1,'https://www.cnblogs.com/geaozhang/p/16760173.html','2022-10-07 18:00:01'),(42,'微软出品自动化神器Playwright（Playwright+Java）系列（四） 之 浏览器操作',NULL,NULL,0,0,'<h2 id=\"写在前面\">写在前面</h2> \n<p>今天是国庆节的最后一天，明天又要上班了，真的是感觉好像才开始放假一样，还是因为<strong>失恋</strong>没缓过来吗？</p> \n<h2 id=\"我的国庆七天\">我的国庆七天</h2> \n<p>第1天，当了近半天的司机，陪家人去各大超市去购物，下午在家躺·····</p> \n<p>第2-5天，重感冒，鼻涕不止，浑身酸痛乏力，两卷卫生纸下去，鼻子已经废了，真的是躺平了······</p> \n<p>第6天，打嗝不止，干咳、嗓子发炎肿了、鼻子烧了、嗓子基本说不出话了······</p> \n<p>综上，真的这个假期过的好累，算是大病一场吗？</p> \n<h2 id=\"该做点什么\">该做点什么</h2> \n<p>早上6点20醒了，刷了一集《请君》，觉得状态还不错，还是写点东西吧，也算找找状态吧。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/5daaf23e-6114-49c8-903f-12355486ca3b.png\" alt=\"\" loading=\"lazy\"></p> \n<p>不管经历过什么，孰对孰错，生活还是要继续的，和自己和解，要学习的还有很多，充实过好每一天即可。</p> \n<h2 id=\"playwright之浏览器操作\">Playwright之浏览器操作</h2> \n<h3 id=\"基础参数\">基础参数</h3> \n<p>这系列的文章还要继续下去的，那么接下来要进行浏览器部分的操作了。</p> \n<h4 id=\"1创建浏览器对象\">1、创建浏览器对象</h4> \n<p>示例代码如下：</p> \n<pre><code class=\"language-java\">//默认为无头浏览器方式启动\nbrowser = playwright.chromium().launch();\n//参数设定方式启动\nbrowser = playwright.chromium().launch(new BrowserType.LaunchOptions().setHeadless(true).setSlowMo(5000));\n</code></pre> \n<h4 id=\"2创建浏览器上下文\">2、创建浏览器上下文</h4> \n<pre><code class=\"language-java\">context = browser.newContext();\n</code></pre> \n<h4 id=\"3创建page对象\">3、创建Page对象</h4> \n<p>一般来说，一个page对应一个浏览器选项卡，这点和selenium有点像，也可以说是比selenium分的更细致？<br> 示例如下：</p> \n<pre><code class=\"language-java\">page = context.newPage();\n</code></pre> \n<h3 id=\"浏览操作\">浏览操作</h3> \n<h4 id=\"1浏览器最大化\">1、浏览器最大化</h4> \n<p>这里以chrome浏览器为例，示例代码如下：</p> \n<pre><code class=\"language-java\"> Playwright playwright = Playwright.create();\n        //看到某博主写的python版的加--start-maximized这个参数，本人尝试后发现无效(Mac系统)\n        //Browser browser = playwright.chromium().launch(new BrowserType.LaunchOptions()\n        //        .setArgs(Collections.singletonList(\"--start-maximized\"))\n        //        .setHeadless(false));\n        Browser browser = playwright.chromium().launch(new BrowserType.LaunchOptions().setHeadless(false));\n        browser.newContext(new Browser.NewContextOptions()\n                .setIgnoreHTTPSErrors(true)\n                .setJavaScriptEnabled(true)\n                .setViewportSize(2880, 1800));\n        Page page = browser.newPage();\n        page.navigate(\"https://www.cnblogs.com/longronglang\");\n        System.out.println(page.title());\n        browser.close();\n        playwright.close();\n</code></pre> \n<h4 id=\"2多个浏览器启动\">2、多个浏览器启动</h4> \n<p>就是个浏览器的封装，没啥技术含量，示例代码如下：</p> \n<pre><code class=\"language-java\">import com.microsoft.playwright.*;\nimport org.testng.annotations.Test;\n\n/**\n * @author rongrong\n * @version 1.0\n * @description 浏览器窗口操作\n * @date 2022/10/7 2:21 PM\n */\npublic class TestBrowser {\n\n\n    /**\n     * 创建浏览器上下文\n     *\n     * @param browser\n     * @return\n     */\n    public BrowserContext createContext(Browser browser) {\n        BrowserContext context = browser.newContext(new Browser.NewContextOptions()\n                .setIgnoreHTTPSErrors(true)\n                .setJavaScriptEnabled(true)\n                //此处可以理解为设定指定窗口启动\n                .setViewportSize(1980, 1080));\n        return context;\n    }\n\n\n    /**\n     * 创建浏览器\n     *\n     * @param name\n     * @param playwright\n     * @return\n     */\n    public Browser createBrowser(String name, Playwright playwright) {\n        try {\n            switch (name) {\n                case \"firefox\":\n                    return playwright.firefox().launch(new BrowserType.LaunchOptions().setHeadless(false).setTimeout(120 * 1000));\n                case \"chromium\":\n                    return playwright.chromium().launch(new BrowserType.LaunchOptions().setHeadless(false).setTimeout(120 * 1000));\n                case \"webkit\":\n                    return playwright.webkit().launch();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n\n    @Test\n    public void testBrowser() {\n        //火狐浏览器\n        startBrowser(\"firefox\");\n        //谷歌浏览器\n        startBrowser(\"chromium\");\n        //这个浏览器不好使\n        //startBrowser(\"webkit\");\n    }\n\n    /**\n     * 根据浏览器类型，启动浏览器\n     *\n     * @param browserName\n     */\n    private void startBrowser(String browserName) {\n        //创建Playwright\n        Playwright playwright = Playwright.create();\n        //创建Browser（使用谷歌浏览器）\n        Browser browser = createBrowser(browserName, playwright);\n        //创建浏览器上下文\n        BrowserContext browserContext = createContext(browser);\n        Page page = browserContext.newPage();\n        page.navigate(\"https://www.cnblogs.com/longronglang\");\n        System.out.println(\"page.title :\" + page.title());\n        System.out.println(browserName + \" 浏览器启动了！\");\n        browser.close();\n        browserContext.close();\n        playwright.close();\n    }\n}\n\n</code></pre> \n<p>效果如下：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/31586ef3-a4e1-42d7-a98d-cd5c57d014bb.png\" alt=\"\" loading=\"lazy\"></p> \n<h4 id=\"3前进后退刷新操作\">3、前进/后退/刷新操作</h4> \n<p>示例代码如下：</p> \n<pre><code class=\"language-java\">        Playwright playwright = Playwright.create();\n        Browser browser = playwright.chromium().launch(new BrowserType.LaunchOptions().setHeadless(false));\n        browser.newContext(new Browser.NewContextOptions()\n                .setIgnoreHTTPSErrors(true)\n                .setJavaScriptEnabled(true)\n                .setViewportSize(2880, 1800));\n        Page page = browser.newPage();\n        page.navigate(\"https://www.cnblogs.com/longronglang\");\n        //输出：久曲健 - 博客园\n        System.out.println(\"page title:\"+page.title());\n        //这里是运行时打断点使用，方便调试（适用于喜欢用录制回放生成脚本的同学）\n        //page.pause();\n        pause(3);\n        //打开百度页面\n        page.navigate(\"https://www.baidu.com/\");\n        //输出：百度一下，你就知道\n        System.out.println(\"page title:\"+page.title());\n        //后退操作\n        page.goBack();\n        pause(3);\n        //输出：久曲健 - 博客园\n        System.out.println(\"page title:\"+page.title());\n        //前进操作\n        page.goForward();\n        pause(3);\n        System.out.println(\"page title:\"+page.title());\n        //刷新操作\n        page.reload();\n        pause(3);\n        //输出当前url\n        System.out.println(\"page url:\"+page.url());\n        browser.close();\n        playwright.close();\n</code></pre> \n<p>效果如下：<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/3ad39bfa-f00a-459a-bc8f-ad6eaa797860.png\" alt=\"\" loading=\"lazy\"></p> \n<p>到此，关于浏览器的操作部分已分享完毕，有兴趣的同学可以自行尝试，更多请参考官方文档。</p> \n<h2 id=\"写在最后\">写在最后</h2> \n<p>这个博客从上午九点多写到现在，表示很惭愧，大部分时间还是在刷手机，懒散坏了，想收收心，怕是真的很难！</p> \n<p>整个人还是不太好，因为打嗝不止，震的我脖子都疼，果然病痛确实很折磨人!</p> \n<p>看到很好的一句话分享给大家，也送给每个恋爱过程中朋友：</p> \n<p>分享如下：</p> \n<blockquote> \n <blockquote> \n  <blockquote> \n   <p>连回音都没有的山谷，不值得纵身一跃;<br> 。<strong>——知乎</strong></p> \n  </blockquote> \n </blockquote> \n</blockquote>',100,NULL,2,'https://www.cnblogs.com/longronglang/p/16760234.html','2022-10-07 18:30:35'),(43,'求最长回文子序列长度问题',NULL,NULL,0,0,'<h1 id=\"求最长回文子序列长度问题\">求最长回文子序列长度问题</h1> \n<p>作者：<a href=\"https://www.cnblogs.com/greyzeng/\" target=\"_blank\" rel=\"noopener\">Grey</a></p> \n<p>原文地址：</p> \n<p><a href=\"https://www.cnblogs.com/greyzeng/p/16760224.html\" target=\"_blank\" rel=\"noopener\">博客园：求最长回文子序列长度问题</a></p> \n<p><a href=\"https://blog.csdn.net/hotonyhui/article/details/127197172\" target=\"_blank\" rel=\"noopener\">CSDN：求最长回文子序列长度问题</a></p> \n<h2 id=\"题目描述\">题目描述</h2> \n<p>给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度。题目链接见:<a href=\"https://leetcode.cn/problems/longest-palindromic-subsequence/\" target=\"_blank\" rel=\"noopener\">LeetCode 516. Longest Palindromic Subsequence</a></p> \n<h2 id=\"暴力解\">暴力解</h2> \n<p>定义递归函数</p> \n<pre><code class=\"language-java\">int process(int i, int j, char[] str) \n</code></pre> \n<p>递归含义是：str 这个字符串从 i 到 j，最长回文子序列长度是多少。</p> \n<p>主函数只需要调用</p> \n<pre><code class=\"language-java\">return process(0, str.length - 1, str);\n</code></pre> \n<p>即为要求的答案。</p> \n<p>接下来看递归函数的实现</p> \n<p>首先是 base case，显然有如下两个结论：</p> \n<p>结论1：当<code>i == j</code>的时候，说明只有一个字符，最长回文子序列长度就是 1；</p> \n<p>结论2：当<code>i == j - 1</code>的时候，如果<code>str[i] == str[j]</code>，则最长回文子序列的长度就是 2， 否则就是 1；</p> \n<p>接下来就是普遍情况：</p> \n<p>要求<code>i……j</code>之间的最长回文子序列的长度，有如下三种情况</p> \n<p>情况1，不考虑 i 位置的字符，则<code>i……j</code>之间的最长回文子序列的长度就是<code>i+1……j</code>之间的最长回文子序列长度。</p> \n<p>情况2，不考虑 j 位置的字符，则<code>i……j</code>之间的最长回文子序列的长度就是<code>i……j-1</code>之间的最长回文子序列的长度。</p> \n<p>情况3，当<code>str[i] == str[j]</code>的时候，<code>i……j</code>之间的最长回文子序列的长度就是<code>i+1……j-1</code>之间的最长回文子序列的长度加 2。</p> \n<p>以上三种情况求最大值，就是<code>i……j</code>之间的最长回文子序列的长度。</p> \n<p>暴力解法的完整代码如下</p> \n<pre><code class=\"language-java\">class Solution {\n     public static int longestPalindromeSubseq(String s) {\n        if (s == null || s.length() &lt; 1) {\n            return 0;\n        }\n        char[] str = s.toCharArray();\n        return process(0, str.length - 1, str);\n    }\n\n    // i...j的最长回文子序列是多少\n    public static int process(int i, int j, char[] str) {\n        if (i == j) {\n            return 1;\n        }\n        if (i == j - 1) {\n            return str[i] == str[j] ? 2 : 1;\n        }\n        int p1 = process(i + 1, j, str);\n        int p2 = process(i, j - 1, str);\n        int p3 = (str[i] == str[j] ? 2 : 0) + process(i + 1, j - 1, str);\n        return Math.max(p1, Math.max(p2, p3));\n    }\n}\n</code></pre> \n<p>LeetCode 上这个解法会直接超时</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/ff4adf9d-8040-4696-8262-5361bda79d55.png\" alt=\"image\" loading=\"lazy\"></p> \n<h2 id=\"动态规划\">动态规划</h2> \n<p>通过暴力递归方法</p> \n<pre><code class=\"language-java\">    public static int process(int i, int j, char[] str) {\n        ...\n        int p1 = process(i + 1, j, str);\n        int p2 = process(i, j - 1, str);\n        ... process(i + 1, j - 1, str);\n        ....\n    }\n</code></pre> \n<p>我们可以得到一个结论，原问题是一个二维数组规模的问题，使用一个二维数组就可以把整个递归中的解保存下来，二维数组定义如下</p> \n<pre><code class=\"language-java\">int[][] dp = new int[s.length()][s.length()];\n</code></pre> \n<p><code>dp[i][j]</code>就是递归函数<code>process(i,j,str)</code>的含义，即：str 这个字符串从 i 到 j，最长回文子序列长度是多少。</p> \n<p>且任何一个<code>(i,j)</code>位置依赖三个位置的值，即：<code>(i,j-1)</code>,<code>(i+1,j)</code>,<code>(i+1,j-1)</code></p> \n<p>二维数组的对角线位置的值都是 1，因为对角线<code>i == j</code>，只有一个字符，最大回文子序列就是 1，</p> \n<p>接下来按照递归含义依次填好每个二维数组格子的值，说明见注释</p> \n<pre><code class=\"language-java\">      for (int i = 0; i &lt; s.length(); i++) {\n        // 对角线都是1\n            dp[i][i] = 1;\n            if (i != s.length() - 1) {\n                // 对角线上一条线 不是 1 就是 2 \n                dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;\n            }\n        }\n\n        // 普遍位置\n        for (int index = 2; index &lt; s.length(); index++) {\n            int i = 0;\n            int j = index;\n            while (j &lt; s.length()) {\n                int p1 = dp[i + 1][j];\n                int p2 = dp[i][j - 1];\n                int p3 = (str[i] == str[j] ? 2 : 0) + dp[i + 1][j - 1];\n                dp[i][j] = Math.max(p1, Math.max(p2, p3));\n                i++;\n                j++;\n            }\n        }\n        // 返回dp[0][s.length() - 1]： 即 整个字符串的最长回文子序列的长度\n        return dp[0][s.length() - 1];\n</code></pre> \n<p>完整代码如下</p> \n<pre><code class=\"language-java\">class Solution {\n    public static int longestPalindromeSubseq(String s) {\n        if (s == null || s.length() &lt; 1) {\n            return 0;\n        }\n        char[] str = s.toCharArray();\n        int[][] dp = new int[s.length()][s.length()];\n        for (int i = 0; i &lt; s.length(); i++) {\n            dp[i][i] = 1;\n            if (i != s.length() - 1) {\n                dp[i][i + 1] = str[i] == str[i + 1] ? 2 : 1;\n            }\n        }\n\n        for (int index = 2; index &lt; s.length(); index++) {\n            int i = 0;\n            int j = index;\n            while (j &lt; s.length()) {\n                int p1 = dp[i + 1][j];\n                int p2 = dp[i][j - 1];\n                int p3 = (str[i] == str[j] ? 2 : 0) + dp[i + 1][j - 1];\n                dp[i][j] = Math.max(p1, Math.max(p2, p3));\n                i++;\n                j++;\n            }\n        }\n\n        return dp[0][s.length() - 1];\n    }\n}\n</code></pre> \n<h2 id=\"使用最大公共子序列来解\">使用最大公共子序列来解</h2> \n<p>还有更多的思路可以解这个题目，比如：<strong>一个字符串和它的逆序串的最大公共子序列就是这个串的最长回文子序列</strong>，不赘述，直接看代码</p> \n<pre><code class=\"language-java\">class Solution {\n    public int longestPalindromeSubseq(String s) {\n        char[] str1 = s.toCharArray();\n        int n = str1.length;\n        char[] str2 = new char[n];\n        for (char str : str1) {\n            str2[--n] = str;\n        }\n        return longestCommonSubsequence2(str1, str2);\n    }\n\n    // 最长公共子序列\n    public int longestCommonSubsequence2(char[] str1, char[] str2) {\n        if ((null == str1 || str1.length == 0) || str2 == null || str2.length == 0) {\n            return 0;\n        }\n        int m = str1.length;\n        int n = str2.length;\n        int[][] dp = new int[m][n];\n        dp[0][0] = str1[0] == str2[0] ? 1 : 0;\n        for (int i = 1; i &lt; n; i++) {\n            dp[0][i] = str1[0] == str2[i] ? 1 : dp[0][i - 1];\n        }\n        for (int i = 1; i &lt; m; i++) {\n            dp[i][0] = str1[i] == str2[0] ? 1 : dp[i - 1][0];\n        }\n        for (int i = 1; i &lt; m; i++) {\n            for (int j = 1; j &lt; n; j++) {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n                if (str1[i] == str2[j]) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1] + 1);\n                } else {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1]);\n                }\n            }\n        }\n        return dp[m - 1][n - 1];\n    }\n}\n</code></pre> \n<p>其中<code>int longestCommonSubsequence2(char[] str1, char[] str2)</code>方法就是求两个字符串的最长公共子序列的动态规划解法。</p> \n<h2 id=\"更多\">更多</h2> \n<p><a href=\"https://github.com/GreyZeng/algorithm\" target=\"_blank\" rel=\"noopener\">算法和数据结构笔记</a></p>',100,NULL,0,'https://www.cnblogs.com/greyzeng/p/16760224.html','2022-10-07 18:30:38'),(44,'语音和噪声相关数据集(持续更新)','博客地址：https://www.cnblogs.com/LXP-Never/p/15474948.html（转载请注明出处）博客作者：凌逆战语音数据集TIMIT官方提供的下载地址：https://catalog.ldc.upenn.edu/LDC93S1免费下载地址：https://goo.gl/l0sPw','2022-10-07 18:53:51',0,0,'<p>博客地址：<a class=\"ng-star-inserted\" href=\"https://www.cnblogs.com/LXP-Never/p/15474948.html\" rel=\"noopener\" target=\"_blank\">https://www.cnblogs.com/LXP-Never/p/15474948.html</a>（转载请注明出处）</p><p>博客作者：<a href=\"https://home.cnblogs.com/u/LXP-Never/\" target=\"_blank\" rel=\"noopener\">凌逆战</a></p><h1>语音数据集</h1><h2><strong>TIMIT</strong></h2><blockquote><p>官方提供的下载地址：<a href=\"https://catalog.ldc.upenn.edu/LDC93S1\" target=\"_blank\" rel=\"noopener\">https://catalog.ldc.upenn.edu/LDC93S1</a></p><p>免费下载地址：<a href=\"https://goo.gl/l0sPwz\" rel=\"noopener\">https://goo.gl/l0sPwz</a>(420M)</p></blockquote><p>　　TIMIT 共包含 6300 个句子，10 个句子由来自美国 8 个主要方言区的 630 位说话人。</p><p>Timit原始数据虽然是以wav结尾的但是格式却不是wav，而是sphere格式，用<a class=\"hl hl-1\" href=\"https://so.csdn.net/so/search?from=pc_blog_highlight&q=python\" target=\"_blank\" rel=\"noopener\">python</a>中的sphfile库把他转换成wav：</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_f8abc33b-0371-4a43-b824-47530279bf4a\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_f8abc33b-0371-4a43-b824-47530279bf4a\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>from&nbsp;sphfile&nbsp;import&nbsp;SPHFileimport&nbsp;globimport&nbsp;os&nbsp;\nif&nbsp;__name__&nbsp;==&nbsp;&quot;__main__&quot;:\n&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;&#39;D:/pycharm_proj/corpus/data/lisa/data/timit/raw/TIMIT/TRAIN/*/*/*.WAV&#39;\n&nbsp;&nbsp;&nbsp;&nbsp;sph_files&nbsp;=&nbsp;glob.glob(path)&nbsp;&nbsp;&nbsp;&nbsp;print(len(sph_files),&quot;train&nbsp;utterences&quot;)&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;sph_files:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sph&nbsp;=&nbsp;SPHFile(i)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sph.write_wav(filename=i.replace(&quot;.WAV&quot;,&quot;_.wav&quot;))\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.remove(i)\n&nbsp;&nbsp;&nbsp;&nbsp;path&nbsp;=&nbsp;&#39;D:/pycharm_proj/corpus/data/lisa/data/timit/raw/TIMIT/TEST/*/*/*.WAV&#39;\n&nbsp;&nbsp;&nbsp;&nbsp;sph_files_test&nbsp;=&nbsp;glob.glob(path)&nbsp;&nbsp;&nbsp;&nbsp;print(len(sph_files_test),&quot;test&nbsp;utterences&quot;)&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;i&nbsp;in&nbsp;sph_files_test:\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sph&nbsp;=&nbsp;SPHFile(i)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sph.write_wav(filename=i.replace(&quot;.WAV&quot;,&quot;_.wav&quot;))\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.remove(i)&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;Completed&quot;)</pre><p></p><p><span class=\"cnblogs_code_collapse\">View Code</span></p><h2><strong>VCTK</strong></h2><blockquote><p>下载地址：<a href=\"https://datashare.ed.ac.uk/handle/10283/3443\" target=\"_blank\" rel=\"noopener\">传送门</a>（10.94Gb）</p></blockquote><p>　　CSTR VCTK 语料库包括 110 位具有各种口音的英语使用者的语音数据。每个发言者读出大约 400 个句子，所有语音数据都是使用相同的录音设置录制的：全向麦克风 (DPA 4035)和一个小振膜电容麦克风，具有非常宽的带宽（Sennheiser MKH 800），96kHz 采样频率，24 位，在爱丁堡大学的半消声室中。所有录音都转换为 16 位，下采样到 48 kHz，并手动设置终点。</p><h2><strong>AISHELL-ASR0009-OS1 开源中文语音数据库</strong></h2><blockquote><p>下载地址：<a href=\"http://www.aishelltech.com/kysjcp\" target=\"_blank\" rel=\"noopener\">传送门</a>（14.51Gb）</p></blockquote><p>　　时长<strong>178</strong>小时，录音文本涉及智能家居、无人驾驶、工业生产等11个领域。录制过程在安静室内环境中， 同时使用3种不同设备： 高保真麦克风（44.1kHz，16-bit）；Android系统手机（16kHz，16-bit）；iOS系统手机（16kHz，16-bit）。高保真麦克风录制的音频降采样为16kHz。400名来自中国不同口音区域的发言人参与录制。</p><p><strong>AISHELL-2 中文语音数据库<br/></strong></p><p>　　时长为<strong>1000</strong>小时，其中718小时来自AISHELL-ASR0009，282小时来自AISHELL-ASR0010。录音文本涉及唤醒词、语音控制词、智能家居、无人驾驶、工业生产等12个领域。录制过程在安静室内环境中， 同时使用3种不同设备： 高保真麦克风（44.1kHz，16bit）；Android系统手机（16kHz，16bit）；iOS系统手机（16kHz，16bit）。AISHELL-2采用iOS系统手机录制的语音数据。1991名来自中国不同口音区域的发言人参与录制。</p><p><strong>AISHELL-3 高保真中文语音数据库</strong></p><p>　　时长为85小时<strong>88035句</strong>，可做为多说话人合成系统。录制过程在安静室内环境中， 使用高保真麦克风（44.1kHz，16bit）。218名来自中国不同口音区域的发言人参与录制。</p><p><strong>AISHELL-WakeUp-1 中英文唤醒词语音数据库</strong></p><p><strong>AISHELL-DMASH 中文普通话麦克风阵列家居场景语音数据库</strong></p><p><strong>AISHELL-4 多通道中文会议语音数据库</strong></p><h2>Mozilla Common Voice</h2><blockquote><p>下载地址：<a href=\"https://commonvoice.mozilla.org/zh-CN\" target=\"_blank\" rel=\"noopener\">https://commonvoice.mozilla.org/zh-CN</a></p><p>时长：1965小时（目前为止）</p></blockquote><p>最早2017年发布，持续更新，该基金会表示，通过 Common Voice 网站和移动应用，他们正在积极开展 70 种语言的数据收集工作。</p><p>Mozilla 宣称其拥有可供使用的最大的人类语音数据集，当前数据集有包括 29 种不同的语言,其中包括汉语，从 4万多名贡献者那里收集了近 2454 小时（其中1965小时已验证）的录音语音数据。并且做出了开放的承诺：向初创公司、研究人员以及对语音技术感兴趣的任何人公开我们收集到的高质量语音数据。</p><h2>Tatoeba</h2><p>下载地址：<a href=\"https://tatoeba.org/zh-cn/downloads\" target=\"_blank\" rel=\"noopener\">传送门</a></p><p>　　项目始于2006年tatoeba是一个用于语言学习的句子、翻译和口语音频的大型数据库。收集面向外语学习者的例句的网站，用户无须注册便可以搜索任何单词的例句。如果例句含有对应的真人发音，也可以点击收听。注册用户可以添加、翻译、接管、改进、讨论句子。还可以在留言板上和其他注册用户讨论。在留言板上，所有的语言都是平等的，注册用户可以使用自己喜欢的语言与其他用户交流。</p><h1>噪声数据集</h1><h2><strong>noise-92</strong></h2><blockquote><p>下载地址：<a href=\"http://spib.linse.ufsc.br/noise.html\" target=\"_blank\" rel=\"noopener\">传送门</a>（250M）</p><p>音频参数：19980Hz；单通道，16位深</p></blockquote><p>以mat格式存储，可以通过下面的脚本转换到wav格式，所有噪声的持续时间为 235 秒，19.98 KHz 的采样率、具有 16 位的模数转换器 (A/D)、抗混叠滤波器和无预加重级获得。包含15种噪声类型：White Noise、Pink Noise、Speech Babble、Factory Floor Noise 1、Factory Floor Noise 2、Cockpit Noise 1 (Buccaneer Jet Traveling at 190 knots)、Cockpit Noise 2 (Buccaneer Jet Traveling at 450 knots)、Cockpit Noise 3 (F-16)、Engine Room Noise (Destroyer)、Operations Room Background Noise (Destroyer)、Military Vehicle Noise (Leopard)、Military Vehicle Noise (M109)、Machine Gun Noise、Vehicle Interior Noise (Volvo 340)、HF Channel Noise</p><p>&nbsp;将mat格式的音频转成wav</p><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_94b70e11-7788-4285-bd7c-d074c106d571\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_94b70e11-7788-4285-bd7c-d074c106d571\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>mat_file=dir(&#39;./*.mat&#39;);\nsr=19980;for&nbsp;n=1:length(mat_file)\n&nbsp;&nbsp;&nbsp;&nbsp;disp(mat_file(n).name);\n&nbsp;&nbsp;&nbsp;&nbsp;load(mat_file(n).name);\n&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;eval(mat_file(n).name(1:end-4));&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;为了避免写入被截断，需要归一化到(-1,1)&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;方法1%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;max_val&nbsp;=&nbsp;max(name);%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_val&nbsp;=&nbsp;min(name);%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;((name-min_val)./(max_val-min_val)&nbsp;-&nbsp;0.5&nbsp;)&nbsp;*2;&nbsp;&nbsp;&nbsp;&nbsp;%&nbsp;方法2\n&nbsp;&nbsp;&nbsp;&nbsp;name&nbsp;=&nbsp;rescale(name,&nbsp;-1,&nbsp;1);\n&nbsp;&nbsp;&nbsp;&nbsp;\n&nbsp;&nbsp;&nbsp;&nbsp;audiowrite(strrep(mat_file(n).name,&#39;mat&#39;,&#39;wav&#39;),name,sr);\nend</pre><p></p><p><span class=\"cnblogs_code_collapse\">View Code</span></p><h2>NOIZEUS数据集</h2><blockquote><p><strong>下载地址</strong>：<a href=\"https://ecs.utdallas.edu/loizou/speech/noizeus/\" target=\"_blank\" rel=\"noopener\">NOIZEUS：用于评估语音增强算法的嘈杂语音语料库</a>（噪声和纯净语音对）</p></blockquote><p>包含30个IEEE 句子（由三名男性和三名女性发言者产生），被不同 SNR 下的八种不同的真实世界噪声破坏。噪音包括郊区火车噪音、杂音、汽车、展览厅、餐厅、街道、机场和火车站噪音。</p><h2>DEMAND</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/1227121#.YXtsyPlBxjU\" target=\"_blank\" rel=\"noopener\">传送门</a>（7.4Gb）</p><p>音频参数：48 kHz 和 16 kHz 采样率在一个目录中以 16 个单通道 WAV 文件的形式提供</p></blockquote><p>16 通道环境噪声记录数据库</p><p>　　麦克风阵列是几个麦克风的（通常规则的）排列，允许使用许多有趣的信号处理技术。例如，来自彼此相距很近的麦克风的音频信号的相关性可以用于确定声源相对于阵列的空间位置，或基于声音到达阵列的方向隔离或增强信号。</p><p>　　通常，考虑声学背景噪声的麦克风阵列实验使用受控环境或模拟环境。这种人工设置在噪声源方面通常是稀疏的。其他已经存在的真实世界噪声数据库(例如<a href=\"http://catalog.elra.info/product_info.php?products_id=693\" target=\"_blank\" rel=\"noopener\">AURORA-2语料库</a>、<a href=\"http://spandh.dcs.shef.ac.uk/projects/chime/PCC/datasets.html\" target=\"_blank\" rel=\"noopener\">CHiME背景噪声数据</a>或<a href=\"http://www.speech.cs.cmu.edu/comp.speech/Section1/Data/noisex.html\" target=\"_blank\" rel=\"noopener\">NOISEX-92数据库</a>)往往只提供非常有限的环境多样性，最多只能提供2个通道。</p><p>　　这里介绍的DEMAND(多元环境多通道声学噪声数据库)提供了一组录音，允许在各种设置下使用真实环境的噪声测试算法。这个版本提供了<span style=\"color: rgba(0, 128, 128, 1)\"><strong>15个录音。所有录音都使用16通道阵列，麦克风之间的最小距离为5厘米，最大距离为21.8厘米</strong></span>。<span style=\"color: rgba(0, 128, 128, 1)\"><strong><br/></strong></span></p><h2>PNL 100 Nonspeech Sounds</h2><blockquote><p>下载地址：<a href=\"http://web.cse.ohio-state.edu/pnl/corpus/HuNonspeech/HuCorpus.html\" target=\"_blank\" rel=\"noopener\">传送门</a>（~10M）</p><p>音频格式：20kHz采样率，单声道，16位深</p></blockquote><p>这些非语音、环境声音可以用作评估语音分离系统等的非语音噪声</p><pre>Crowd&nbsp;人群噪音：N1-N17\nMachine&nbsp;机器噪音：N18-N29\nAlarms&nbsp;警报和警报器：N30-N43\nTraffic&nbsp;交通和汽车噪音:&nbsp;N44-N46&nbsp;\nAnimal&nbsp;动物声音：N47-N55\nwater&nbsp;水声：N56-N69\nWind&nbsp;风：N70-N78\nBell&nbsp;铃：N79-N82\nCough&nbsp;咳嗽：N83-N85\nclap&nbsp;hands&nbsp;拍手：N86\nSnoring&nbsp;打鼾：N87\nClick&nbsp;点击：N88\nlol&nbsp;笑：N88-N90\nYawn&nbsp;打哈欠：N91-N92\ncry&nbsp;哭：N93\nShower&nbsp;淋浴：N94\nBrush&nbsp;your&nbsp;teeth&nbsp;刷牙：N95\nFootsteps&nbsp;脚步声：N96-N97\nDoor&nbsp;Movement&nbsp;门移动：N98\nTelephone&nbsp;dialing&nbsp;电话拨号：N99-N100</pre><p></p><h2>rnnoise_ontributions</h2><p>RNNoise提供的捐赠数据集，大部分是一些办公室噪声，下载地址：<a href=\"https://media.xiph.org/rnnoise/rnnoise_contributions.tar.gz\" target=\"_blank\" rel=\"noopener\">传送门</a>（6.41G）。</p><h2>ESC-50：环境声音分类数据集</h2><blockquote><p>下载地址：<a href=\"https://github.com/karolpiczak/ESC-50\" target=\"_blank\" rel=\"noopener\">https://github.com/karolpiczak/ESC-50</a>（~600MB）</p><p>国内镜像：<a href=\"https://www.heywhale.com/mw/dataset/5ea9337c366f4d002d731d83\" target=\"_blank\" rel=\"noopener\">https://www.heywhale.com/mw/dataset/5ea9337c366f4d002d731d83</a></p><p>音频参数：44.1kHz；单通道，16位深</p></blockquote><p>　　ESC-50数据集是从<a href=\"https://freesound.org/\" target=\"_blank\" rel=\"noopener\">Freesound.org</a>中剪辑得到的2000份环境音频的标记集合，适用于环境声音分类。该数据集由<span style=\"color: rgba(0, 128, 128, 1)\"><strong>5秒长</strong></span>的录音组成，组织成5大类，每个大类有10小类(每个小·类有40个示例)，</p><ol class=\" list-paddingleft-2\"><li><p><strong>动物</strong>：狗、公鸡、猪、奶牛、青蛙、猫、母鸡、昆虫（飞行）、羊、乌鸦</p></li><li><p><strong>自然声音和水声</strong>：雨、海浪、噼啪作响的火、蟋蟀、鸟鸣、水滴、风、倒水、冲水马桶、雷雨</p></li><li><p><strong>人类的非语音声音</strong>：婴儿啼哭、打喷嚏、鼓掌、呼吸、咳嗽、脚步声、笑、刷牙、打鼾、喝酒，啜饮</p></li><li><p><strong>室内/家庭声音</strong>：敲门声、鼠标点击、键盘打字、门，木头吱吱作响、开罐头、洗衣机、吸尘器、时钟闹钟、时钟滴答声、玻璃破碎</p></li><li><p><strong>外部/城市噪声</strong>：直升机、电锯、警笛、汽车喇叭、引擎、火车、教堂的钟声、飞机、烟花、手锯</p></li></ol><p><img src=\"https://images.cnblogs.com/OutliningIndicators/ContractedBlock.gif\" id=\"code_img_closed_5329e698-eb96-4684-8e48-8665378fa498\" class=\"code_img_closed\"/>\n <img src=\"https://images.cnblogs.com/OutliningIndicators/ExpandedBlockStart.gif\" id=\"code_img_opened_5329e698-eb96-4684-8e48-8665378fa498\" class=\"code_img_opened\" style=\"display: none\"/> \n </p><pre>#&nbsp;-*-&nbsp;coding:utf-8&nbsp;-*-#&nbsp;Author:凌逆战&nbsp;|&nbsp;Never.Ling#&nbsp;Date:&nbsp;2022/8/8&quot;&quot;&quot;对ESC-50数据集，根据噪声类别分类&quot;&quot;&quot;import&nbsp;osimport&nbsp;librosaimport&nbsp;pandas&nbsp;as&nbsp;pdimport&nbsp;soundfile\n\ncsv_path&nbsp;=&nbsp;&quot;./esc50.csv&quot;dataset_path&nbsp;=&nbsp;&quot;G:/dataset/noise_dataset/ESC-50&quot;class_basepath&nbsp;=&nbsp;&quot;G:/dataset/noise_dataset/ESC-50/class&quot;sr&nbsp;=&nbsp;16000trainData&nbsp;=&nbsp;pd.read_csv(csv_path)for&nbsp;filename,&nbsp;category&nbsp;in&nbsp;zip(trainData[&quot;filename&quot;],&nbsp;trainData[&quot;category&quot;]):\n&nbsp;&nbsp;&nbsp;&nbsp;noise_path&nbsp;=&nbsp;os.path.join(dataset_path,&nbsp;&quot;audio&quot;,&nbsp;filename)\n&nbsp;&nbsp;&nbsp;&nbsp;class_path&nbsp;=&nbsp;os.path.join(class_basepath,&nbsp;category)&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;not&nbsp;os.path.exists(class_path):\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;os.makedirs(class_path)\n\n&nbsp;&nbsp;&nbsp;&nbsp;new_path&nbsp;=&nbsp;os.path.join(class_path,&nbsp;&quot;ESC50_&quot;&nbsp;+&nbsp;filename)&nbsp;&nbsp;&nbsp;&nbsp;print(&quot;new_path&quot;,&nbsp;new_path)\n&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;=&nbsp;librosa.load(noise_path,&nbsp;sr,&nbsp;mono=True)[0]\n&nbsp;&nbsp;&nbsp;&nbsp;soundfile.write(new_path,&nbsp;data=y,&nbsp;samplerate=sr)</pre><p></p><p><span class=\"cnblogs_code_collapse\">分类脚本</span></p><h2>ESC环境噪音分类数据集</h2><blockquote><p>下载地址：<a href=\"http://shujujishi.com/dataset/69b2bf03-d855-4f8b-ab96-1ec80e285863.html\" target=\"_blank\" rel=\"noopener\">传送门</a>（26.8GB）</p><p>音频参数：44.1kHz，单通道，5 秒长剪辑</p></blockquote><p>ESC 数据集是一组以统一格式提供的短期环境记录。所有剪辑都从通过项目项目获得的公共<a href=\"http://freesound.org/\" rel=\"noopener\">Freesound.org中提取</a>。</p><p>数据集由三部分组成：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://github.com/karoldvl/ESC-50\" target=\"_blank\" rel=\"noopener\">ESC-50</a>：一组有 2000 个环境记录（50 个类，每类 40 个剪辑），</p></li><li><p><a href=\"https://github.com/karoldvl/ESC-10\" rel=\"noopener\">ESC-10</a>：一组有 400 个环境记录（每类 10 个类，40 个剪辑）（这是 ESC-50 的子集 - 创建初始化，作为概念验证/简单录制的标准化选择），</p></li><li><p>ESC-US：一个未标记的数据集，包含 25 万个环境记录（5 秒长的剪辑），适合无监督的预培训。</p></li></ul><h2>婴儿啼哭数据集</h2><p><a href=\"https://github.com/giulbia/baby_cry_detection\" target=\"_blank\" rel=\"noopener\">https://github.com/giulbia/baby_cry_detection</a>（310M）</p><p><a href=\"https://github.com/gveres/donateacry-corpus\" target=\"_blank\" rel=\"noopener\">https://github.com/gveres/donateacry-corpus</a>（48.2M）</p><p><a href=\"http://challenge.xfyun.cn/topic/info?type=baby-crying\" target=\"_blank\" rel=\"noopener\">科大讯飞婴儿啼哭声识别挑战赛</a>（810M）</p><ul class=\" list-paddingleft-2\"><li><p>链接：<a href=\"https://pan.baidu.com/s/1qP-9sd0v31zKnpD5w2kvwQ\" target=\"_blank\" rel=\"noopener\">https://pan.baidu.com/s/1qP-9sd0v31zKnpD5w2kvwQ </a></p></li><li><p>提取码：wh47&nbsp;</p></li></ul><h2>MS-SNSD</h2><blockquote><p>下载地址：<a href=\"https://github.com/microsoft/MS-SNSD\" target=\"_blank\" rel=\"noopener\">传送门</a></p><p>音频格式：16kHz，单声道，16位深</p></blockquote><p>冷气机、机场公告、Babble、复印机、咀嚼、邻居、关门、打字、吸尘器</p><h2>QUT-NOISE</h2><blockquote><p>下载地址：<a href=\"https://research.qut.edu.au/saivt/databases/qut-noise-databases-and-protocols/\" target=\"_blank\" rel=\"noopener\">传送门</a>（7.70Gb）</p><p>音频格式：采样率48kHz；双声道；16位深</p></blockquote><p>音频参数：街道、咖啡厅、汽车、家庭、混响、</p><h2>freesound-datasets</h2><blockquote><p>下载地址：<a href=\"https://github.com/MTG/freesound-datasets\" target=\"_blank\" rel=\"noopener\">传送门</a></p></blockquote><h2>STARSS22：Sony-TAu Realistic Spatial Soundscapes 2022</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/6600531#.YzVNhnZBxjU\" target=\"_blank\" rel=\"noopener\">传送门</a></p></blockquote><h2>VOICe Dataset</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/3514950#.YzVOnnZBxjU\" target=\"_blank\" rel=\"noopener\">传送门</a>（3.23GB）</p><p>音频格式：44.1kHz；单声道；32位(浮点)位深</p></blockquote><p>用于开发和评估通用声音事件检测域适应方法的新数据集！</p><pre>婴儿哭声\n玻璃破碎\n枪声</pre><p></p><p>VOICe 由三种不同声音事件的 1449 种不同混合组成：</p><ul data-mark=\"-\" class=\" list-paddingleft-2\"><li><p>1242 个混合了三种不同类别的声学场景（“车辆”、“户外”和“室内”）的背景噪声，在 2 个 SNR 值（-3，-9 dB）下混合，即 207 个混合 x 3 个声学场景 x 2 个信噪比 = 1242</p></li><li><p>207 种没有任何背景噪音的混合物。</p></li></ul><h2>In-Vehicle Noise Dataset</h2><blockquote><p>下载地址：<a href=\"https://magichub.com/datasets/in-vehicle-noise-dataset/\" target=\"_blank\" rel=\"noopener\">传送门</a>（~2.47GB）</p><p>音频参数：44.1 kHz，16 位，2通道</p></blockquote><p>　　这个开源数据集包含来自多个来源的 5.08 小时车内噪声，其中包含 7 条噪声。噪声源可能包括</p><pre>轮胎噪声\n发动机噪声\n收音机\n人声</pre><p></p><h2>Vehicle Interior Sound Dataset</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/5606504#.Yz_dfHZBxjU\" target=\"_blank\" rel=\"noopener\">传送门VISC Dataset SON</a>（1.2GB）</p><p>音频参数：44.1kHz；双声道；16位深</p></blockquote><p>　　使用的数据集是从 YouTube 的不同车辆类型的驾驶视点 (PoV) 收集的。<span style=\"color: rgba(0, 128, 128, 1)\"><strong>这些只是车内声音。没有司机，也没有人声</strong></span>。5980个声音被记录了8个类。<strong>这些车辆在露天的柏油路上行驶。我们不喜欢在雨天在未铺砌的道路上收集车内声音</strong>。</p><p>这些数据的文件格式是 wav。使用声音的长度在 3-5 秒的范围内，频率为 48 kHz。选择的车辆类型是<strong>公共汽车、小巴、皮卡、跑车、吉普车、卡车、跨界车和轿车（汽车）</strong>。收集的车辆内部声音 (VIS) 数据集的属性总结在表中。</p><pre><span style=\"color: rgba(0, 0, 0, 1)\">Bus（公交车）：850个样本\nMinibus（面包车）：850个样本\nPickup（小卡车）：850个样本\nSports Car（跑车）：850个样本\nJeep（吉普车）：850个样本\nTruck（卡车）：850个样本\nCrossover（转线路）：850个样本\nCar (C级 – 4K)：850个样本<br/>total:5980</span></pre><p></p><h2>MAVD交通数据集</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/3338727#.YY4qevlBxjV\" target=\"_blank\" rel=\"noopener\">传送门</a>（~1.3G）</p><p>音频参数：44.1kHz，单声道，32位浮点&nbsp;</p></blockquote><p>　　MAVD：城市环境中声音事件检测的数据集，该版本主要关注<span style=\"color: rgba(0, 128, 128, 1)\"><strong>马路边收集交通噪声</strong></span>，因此得名MAVD-traffic，除了音频记录，它还包括同步视频文件。声音事件注释遵循一个交通声音本体，该本体是一组两种分类的组合：车辆类型(如汽车、公共汽车)和车辆组件(如发动机、刹车)，以及一组与之相关的动作(如空转、加速)。</p><h2>Dataset-AOB：城市声音事件分类</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/4319802#.YY4s8PlBxjU\" target=\"_blank\" rel=\"noopener\">https://zenodo.org/record/4319802#.YY4s8PlBxjU</a>（~2G）</p><p>音频参数：采样率：22KHz - 44KHz，&lt; 4 秒</p></blockquote><p>数据集 Dataset-AOB 是使用卷积神经网络为硕士论文收集和手动编辑的城市声音事件分类的音频数据集：</p><pre>警报器\n儿童玩耍\n狗吠\n引擎\n脚步声\n玻璃破碎\n枪声\n地铁列车\n下雨和尖叫声</pre><p></p><h2>CHiME-Home</h2><blockquote><p>任务描述：<a href=\"https://dcase.community/challenge2016/task-audio-tagging\" target=\"_blank\" rel=\"noopener\">DCASE 2016&nbsp;Domestic audio tagging</a></p><p>下载地址：<a href=\"http://dcase.community/challenge2016/task-audio-tagging\" target=\"_blank\" rel=\"noopener\">传送门</a>（3.9GB）</p><p>音频格式：音频数据以两个采样率（48kHz 和 16kHz）的 4 秒块提供，其中 48kHz 数据为立体声，16kHz 数据为单声道。16kHz 录音是通过对 48kHz 录音的右手通道进行下采样获得的。</p></blockquote><p>　　声学环境中的主要声源是<span style=\"color: rgba(0, 128, 128, 1)\"><strong>两个成人和两个儿童、电视和电子产品、厨房用具、人类活动产生的脚步声和敲击声，以及来自屋外的声音</strong></span>[<a href=\"https://dcase.community/challenge2016/task-audio-tagging#Christensen2010\" target=\"_blank\" rel=\"noopener\">Christensen2010</a>]。音频数据以两个采样率（48kHz 和 16kHz）的 4 秒块提供，其中 48kHz 数据为立体声，16kHz 数据为单声道。16kHz 录音是通过对 48kHz 录音的右手通道进行下采样获得的。每个音频文件对应一个块。</p><p>所有可用的音频数据都可用于系统开发，但将使用以 16kHz 采样的单声道音频数据进行评估，目的是接近商用硬件的典型录音能力。</p><h2>UrbanSound</h2><blockquote><p>下载地址：<a href=\"https://urbansounddataset.weebly.com/urbansound.html\" target=\"_blank\" rel=\"noopener\">传送门</a>（17.9 GB）</p><p>音频格式：44.1kHz；双声道；16位深</p></blockquote><p>该数据集包含 1302 条带标签的录音。每个录音都标有 10 个类别的声音事件的开始和结束时间。每个录音可能包含多个声音事件，但对于每个文件，仅标记来自单个类的事件。这些类来自<a href=\"https://urbansounddataset.weebly.com/taxonomy.html\" rel=\"noopener\">城市声音分类</a>。</p><pre>空调设备&nbsp;air_conditioner\n汽车喇叭&nbsp;car_horn\n小孩玩耍&nbsp;children_playing\n狗吠&nbsp;dog_bark\n钻孔&nbsp;drilling\n发动机&nbsp;enginge_idling\n枪射击&nbsp;gun_shot\n手提&nbsp;jackhammer\n汽笛，警报器&nbsp;siren\n街头音乐&nbsp;street_music</pre><p></p><h2>UrbanSound8K</h2><blockquote><p>下载地址：<a href=\"https://urbansounddataset.weebly.com/urbansound8k.html\" target=\"_blank\" rel=\"noopener\">传送门</a>（6.60GB）</p><p>音频格式：44.1kHz；双声道；16位深</p></blockquote><p>该数据集包含来自 10 个类别的城市声音的 8732 个标记声音摘录 (&lt;=4s)。这些类来自<a href=\"https://urbansounddataset.weebly.com/taxonomy.html\" rel=\"noopener\">城市声音分类</a>。</p><pre>空调设备&nbsp;air_conditioner\n汽车喇叭&nbsp;car_horn\n小孩玩耍&nbsp;children_playing\n狗吠&nbsp;dog_bark\n钻孔&nbsp;drilling\n发动机&nbsp;enginge_idling\n枪射击&nbsp;gun_shot\n手提&nbsp;jackhammer\n汽笛，警报器&nbsp;siren\n街头音乐&nbsp;street_music</pre><p></p><h2>Isolated urban sound database</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/1213793#.Yz_cenZBxjU\" target=\"_blank\" rel=\"noopener\">传送门</a>（2.3G）</p><p>音频格式：44.1kHz；双声道；16位深</p></blockquote><p>数据集包含两个文件夹：</p><ul class=\" list-paddingleft-2\"><li><p><strong>事件</strong>：包括 231 个被视为突出的简短声音样本，持续时间为 1 到 20 秒，分为 21 个声音类别（铃声、哨声、汽车喇叭、过往汽车、锤子、吠狗、警笛、脚步声、金属噪音、声音……）</p></li><li><p><strong>背景</strong>：包括 162 个持续时间较长的声音（~1mn30），其声学特性不会随时间变化。此类别包括鸣叫的鸟鸣、人群噪音、下雨、在校园里玩耍的孩子、持续的交通噪音......</p></li></ul><h2>Acoustic Event Dataset</h2><p>下载地址：<a href=\"https://data.vision.ee.ethz.ch/cvl/ae_dataset/\" target=\"_blank\" rel=\"noopener\">传送门</a>（1.2GB）</p><pre>acoustic&nbsp;guitar：原声吉他\nairplane：飞机\napplause：掌声\nbird：鸟\ncar：车\ncat：猫\nchild：小孩\nchurch&nbsp;bell：教堂钟声\ncrowd：人群\ndog_barking：狗吠\nengine：发送机\nfireworks：烟火\nfootstep：脚步\nglass_breaking：玻璃破碎\nhammer：敲击\nhelicopter：直升机\nknock：敲，击；碰撞\nlaughter：笑\nmouse&nbsp;click：鼠标点击\nocean&nbsp;surf：海浪\nrustle：沙沙声\nscream：尖叫\nspeech：演说，发言，谈话\nsqueak：吱吱叫，嘎吱作响\ntone：声调，音调\nviolin：小提琴\nwater&nbsp;tap：水龙头\nwhistle：口哨声</pre><p></p><p>&nbsp;</p><h2>BBC音效</h2><p>下载地址：<a href=\"https://sound-effects.bbcrewind.co.uk/\" target=\"_blank\" rel=\"noopener\">https://sound-effects.bbcrewind.co.uk/</a></p><p>可能需要爬虫才能把数据下载下来</p><p>飞机、动物、掌声、气氛、钟声、鸟类、时钟、喜剧、人群、日常生活、破坏、电子产品、活动、火、脚步声、工业、机器、医疗、军事、自然、运动、玩具、交通、</p><h2>NAR 数据集</h2><p>下载地址：<a href=\"https://team.inria.fr/perception/nard/\" target=\"_blank\" rel=\"noopener\">传送门</a>（35MB）</p><p>在 多个真实的家庭环境中录制</p><p>厨房：吃东西、窒息、餐具、装满杯子、打开水龙头、打开/关闭抽屉、移动椅子、打开微波炉、关闭微波炉、微波炉、冰箱、烤面包机<br/>办公室：关门、开门、钥匙、敲门、撕纸、拉链、（另一个）拉链<br/>非语言：拍手、拍手、拍舌<br/>语音：1,2,3,4,5,6,7,8,9,10, Hello, Left, Right, Turn, Move, Stop, Nao, Yes, No, What</p><h2>asr-noises</h2><p>下载地址：<a href=\"https://github.com/speechio/asr-noises\" target=\"_blank\" rel=\"noopener\">传送门</a>（4.7GB）</p><p>这个数据集下载不来了，不知道咋回事</p><h2>DCASE</h2><p><strong>dataset、mobile dataset、openset</strong> 的区别：</p><p>使用四个同时捕获音频的设备进行录音。</p><p>主要录音设备包括<a href=\"http://www.soundman.de/en/products/\" target=\"_blank\" rel=\"noopener\">Soundman OKM II Klassik/studio A3</a>、驻极体双耳麦克风和使用 48kHz 采样率和 24 位分辨率的<a href=\"https://www.zoom.co.jp/products/handy-recorder/zoom-f8-multitrack-field-recorder\" target=\"_blank\" rel=\"noopener\">Zoom F8录音机</a>。麦克风经过专门设计，看起来像耳机，戴在耳朵里。因此，录制的音频与到达佩戴设备的人的人类听觉系统的声音非常相似。该设备进一步称为设备 A。</p><p>其他设备是常见的客户设备：设备 B 是三星 Galaxy S7，设备 C 是 iPhone SE，设备 D 是 GoPro Hero5 Session。所有同时录制的内容都是时间同步的。</p><p>TAU Urban Acoustic Scenes 2019 <strong>开发数据集</strong>：仅包含使用设备 A 录制的材料，包含 40 小时的音频，在课程之间保持平衡。数据来自12个城市中的10个。TAU Urban Acoustic Scenes 2019 评估数据集包含来自所有 12 个城市的数据。</p><p>TAU Urban Acoustic Scenes 2019 <strong>移动开发数据集</strong>：包含使用设备 A、B 和 C 录制的材料。它由使用设备 A 录制的 TAU Urban Acoustic Scenes 2019 数据和使用设备 B 和 C 录制的一些并行音频组成。来自设备的数据A 被重新采样并平均到单个通道中，以与设备 B 和 C 记录的数据的属性保持一致。数据集总共包含 46 小时的音频（40h + 3h + 3h）。TAU Urban Acoustic Scenes 2019 移动评估数据集还包含来自设备 D 的数据。</p><p>TAU Urban Acoustic Scenes 2019 <strong>开放集开发数据集</strong>：仅包含使用设备 A 记录的材料，由 TAU Urban Acoustic Scenes 2019 和开放分类问题的其他音频示例组成。“开放”数据由<a href=\"https://zenodo.org/record/400515\" target=\"_blank\" rel=\"noopener\">TUT Acoustic Scenes 2017 数据集</a>的“海滩”和“办公室”类以及 2019 年记录的其他材料组成。数据集总共包含 46 小时的音频（40 小时 + 6 小时）。TAU Urban Acoustic Scenes 2019 开放集评估数据集包含来自 10 个已知类别和其他未知类别的数据。</p><h2>TUT Sound events 2016</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/45759#.YzVN23ZBxjU\" target=\"_blank\" rel=\"noopener\">Development dataset</a>（1.0GB）</p></li><li><p><a href=\"https://zenodo.org/record/996424#.YzVO03ZBxjU\" target=\"_blank\" rel=\"noopener\">Evaluation dataset</a>（471.2MB）</p></li></ul><p>音频参数：44.1kHz，双声道，24位深</p></blockquote><p>包含来自两个声学场景的 22 段录音：</p><pre>家庭（室内），10&nbsp;个录音，共&nbsp;36:16住宅区（室外），12个录音，共42:00</pre><p></p><h2>TUT Acoustic scenes 2016</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/45739#.Yza4RXZBxjU\" rel=\"noopener\">Development dataset</a>&nbsp;(8.0 GB)</p></li><li><p><a href=\"https://zenodo.org/record/165995#.Yza4a3ZBxjU\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(2.7 GB)</p></li></ul><p>音频参数：44.1kHz，双声道，24位深</p></blockquote><p>由来自 15 个声学场景的 30 秒音频片段组成，每个声学场景有 78 个片段，总共 39 分钟的音频。</p><pre>Bus&nbsp;公共汽车-在城市乘坐公共汽车（车辆）\nCafe&nbsp;/&nbsp;Restaurant&nbsp;咖啡厅/餐厅&nbsp;-&nbsp;小咖啡厅/餐厅（室内）\nCar&nbsp;汽车&nbsp;-&nbsp;在城市中驾驶或作为乘客旅行（车辆）\nCity&nbsp;center&nbsp;市中心（室外）\nForest&nbsp;path&nbsp;林间小径（室外）\nGrocery&nbsp;store&nbsp;杂货店&nbsp;-&nbsp;中型杂货店（室内）\nHome&nbsp;&nbsp;家（室内）\nLakeside&nbsp;beach&nbsp;湖滨海滩（室外）\nLibrary&nbsp;&nbsp;图书馆（室内）\nMetro&nbsp;station&nbsp;地铁站（室内）\nOffice&nbsp;办公室&nbsp;-&nbsp;多人，典型工作日（室内）\nResidential&nbsp;area&nbsp;住宅区（室外）\nTrain&nbsp;火车里面（旅行，车辆）\nTram&nbsp;有轨电车（旅行，车辆）\nUrban&nbsp;park&nbsp;城市公园（室外）</pre><p></p><h2>smart cars 2017 test4</h2><blockquote><p>任务描述：<a href=\"https://dcase.community/challenge2017/task-large-scale-sound-event-detection\" target=\"_blank\" rel=\"noopener\">DCASE 2017&nbsp;Large-scale weakly supervised&nbsp;sound event detection for smart cars</a></p><p>Development: <a href=\"https://drive.google.com/file/d/1HOQaUHbTgCRsS6Sr9I9uE6uCjiNPC3d3/view\" target=\"_blank\" rel=\"noopener\">Training </a>(Psswd Training file: DCASE_2017_training_set)</p><p>Development: <a href=\"https://drive.google.com/file/d/1GfP5JATSmCqD8p3CBIkk1J90mfJuPI-k/view\" target=\"_blank\" rel=\"noopener\">Testing </a>(Psswd Testing file: DCASE_2017_testing_set)</p><p><a href=\"https://dl.dropboxusercontent.com/s/bbgqfd47cudwe9y/DCASE_2017_evaluation_set_audio_files.zip\" target=\"_blank\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(863 MB)&nbsp;password &quot;DCASE_2017_evaluation_set&quot;</p><p>音频参数：44.1kHz，单声道，16位深</p></blockquote><pre>鸣笛：-&nbsp;火车喇叭&nbsp;(441)-&nbsp;气喇叭、卡车喇叭&nbsp;(407)-&nbsp;汽车防盗器&nbsp;(273)-&nbsp;倒车提示音&nbsp;(337)-&nbsp;救护车（警笛）&nbsp;(624)-&nbsp;警车（警笛）&nbsp;(2,399)-&nbsp;消防车、消防车（警笛）&nbsp;(2,399)-&nbsp;民防警报器&nbsp;(1,506)-&nbsp;尖叫&nbsp;(744)\n\n车辆声音：-&nbsp;自行车&nbsp;(2,020)-&nbsp;滑板&nbsp;(1,617)-&nbsp;汽车&nbsp;(25,744)-&nbsp;路过的汽车&nbsp;(3,724)-&nbsp;公共汽车&nbsp;(3,745)-&nbsp;卡车&nbsp;(7,090)-&nbsp;摩托车&nbsp;(3,291)-&nbsp;火车&nbsp;(2,301)</pre><p></p><h2>TUT Rare sound events 2017</h2><blockquote><p>下载地址：<a href=\"https://zenodo.org/record/401395#.YvC5InZByUk\" rel=\"noopener\">开发数据集</a>&nbsp;(17.5 GB) |&nbsp;<a href=\"https://zenodo.org/record/1160455#.YvBtZ3ZByUk\" rel=\"noopener\">评估数据集</a>&nbsp;(7.4 GB)</p><p>音频参数：44.1kHz，单声道，16位深</p></blockquote><p>包含用于创建稀有声音事件（婴儿哭声、枪声、玻璃破碎等）与背景音频的混合的源文件，以及一组易于生成的mixtures 和用于生成它们的配方。</p><p>数据集的“source”部分由两个子集组成：</p><ul data-mark=\"-\" class=\" list-paddingleft-2\"><li><p>来自 15 个不同声学场景的背景录音</p></li></ul><pre>-&nbsp;Bus&nbsp;公共汽车-在城市乘坐公共汽车（车辆vehicle）-&nbsp;Cafe&nbsp;/&nbsp;Restaurant&nbsp;咖啡厅/餐厅&nbsp;-&nbsp;小咖啡厅/餐厅（室内indoor）-&nbsp;Car&nbsp;汽车&nbsp;-&nbsp;在城市中驾驶或作为乘客旅行（车辆vehicle）-&nbsp;City&nbsp;center&nbsp;市中心（室外outdoor）-&nbsp;Forest&nbsp;path&nbsp;林间小径（室外outdoor）-&nbsp;Grocery&nbsp;store&nbsp;杂货店&nbsp;-&nbsp;中型杂货店（室内indoor）-&nbsp;Home&nbsp;家（室内）-&nbsp;Lakeside&nbsp;beach&nbsp;湖滨海滩（室外outdoor）-&nbsp;Library&nbsp;图书馆（室内indoor）-&nbsp;Metro&nbsp;station&nbsp;地铁站（室内indoor）-&nbsp;Office&nbsp;办公室&nbsp;-&nbsp;多人，典型工作日（室内indoor）-&nbsp;Residential&nbsp;area住宅区（室外outdoor）-&nbsp;Train&nbsp;火车（旅行，车辆）-&nbsp;Tram&nbsp;有轨电车（旅行，车辆）-&nbsp;Urban&nbsp;park&nbsp;城市公园（室外outdoor）</pre><p></p><ul data-mark=\"-\" class=\" list-paddingleft-2\"><li><p>来自三类目标罕见声音事件的录音，并附有它们的时间发生的注释，</p></li><li><p>一组提供交叉验证设置的元文件：背景和目标事件记录列表分为训练和测试子集（分别称为“devtrain”和“devtest”，表示它们作为开发数据集提供，而不是评估数据集单独发布）。</p></li></ul><p>mixture set 由两个子集（训练和测试）组成，每个子集包含约 1500 个混合（每个子集中每个目标类约 500 个，其中一半的混合不包含任何目标类事件）。</p><h2>TUT Acoustic Scenes 2017</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/400515#.Yu_MH3ZByUk\" rel=\"noopener\">开发数据集</a>&nbsp;(10GB) 每个声学场景有312个片段，总计52分钟的音频。</p></li><li><p><a href=\"https://zenodo.org/record/1040168#.YvBtS3ZByUk\" rel=\"noopener\">验证数据集</a>&nbsp;(3.6 GB) 每个声音场景有108段，总共18分钟的音频。</p></li></ul><p>音频参数：44.1kHz，双声道，24位深</p></blockquote><p>TUT Acoustic Scenes 2017，开发数据集由来自 15 个声学场景的 10 秒音频片段组成：</p><pre>-&nbsp;Bus&nbsp;公共汽车-在城市乘坐公共汽车（车辆vehicle）-&nbsp;Cafe&nbsp;/&nbsp;Restaurant&nbsp;咖啡厅/餐厅&nbsp;-&nbsp;小咖啡厅/餐厅（室内indoor）-&nbsp;Car&nbsp;汽车&nbsp;-&nbsp;在城市中驾驶或作为乘客旅行（车辆vehicle）-&nbsp;City&nbsp;center&nbsp;市中心（室外outdoor）-&nbsp;Forest&nbsp;path&nbsp;林间小径（室外outdoor）-&nbsp;Grocery&nbsp;store&nbsp;杂货店&nbsp;-&nbsp;中型杂货店（室内indoor）-&nbsp;Home&nbsp;家（室内）-&nbsp;Lakeside&nbsp;beach&nbsp;湖滨海滩（室外outdoor）-&nbsp;Library&nbsp;图书馆（室内indoor）-&nbsp;Metro&nbsp;station&nbsp;地铁站（室内indoor）-&nbsp;Office&nbsp;办公室&nbsp;-&nbsp;多人，典型工作日（室内indoor）-&nbsp;Residential&nbsp;area住宅区（室外outdoor）-&nbsp;Train&nbsp;火车（旅行，车辆）-&nbsp;Tram&nbsp;有轨电车（旅行，车辆）-&nbsp;Urban&nbsp;park&nbsp;城市公园（室外outdoor）</pre><p></p><h2>TUT Sound events 2017</h2><blockquote><p><a href=\"https://dcase.community/challenge2017/task-sound-event-detection-in-real-life-audio\" rel=\"noopener\">描述 DACSE 2017 test3</a></p><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/814831#.YzZrDXZByUk\" rel=\"noopener\">Development dataset</a>&nbsp;(1.3 GB)</p></li><li><p><a href=\"https://zenodo.org/record/1040179#.YzZrP3ZByUk\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(388.2 MB)</p></li></ul><p>音频参数：44.1kHz，双声道，24位深</p></blockquote><p>这些录音是在不同的街道上拍摄的。对于每个录制位置，都会捕获 3-5 分钟长的录音。用于录音的设备包括双耳<a href=\"http://www.soundman.de/en/products/\" rel=\"noopener\">Soundman OKM II Klassik/studio A3</a>驻极体入耳式麦克风和使用 44.1 kHz 采样率和 24 位分辨率的<a href=\"http://www.rolandus.com/products/r-09/\" rel=\"noopener\">Roland Edirol R-09波形记录器。</a></p><pre>街道，包含了(刹车吱吱作响、车、孩子们、大型车辆、说话的人、行走的人）</pre><p></p><p>没有纯净噪声，只有噪声起止点。</p><h2>TUT Urban Acoustic Scenes 2018</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/1228142\" rel=\"noopener\">Development dataset</a>&nbsp;(21.4 GB)</p></li><li><p><a href=\"https://zenodo.org/record/1293883\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(8.9 GB)</p></li><li><p><a href=\"https://zenodo.org/record/1245181\" rel=\"noopener\">Leaderboard dataset</a>&nbsp;(3.0 GB)</p></li></ul><p>音频参数：48kHz，双声道，24位深</p></blockquote><p>TUT Urban Acoustic Scenes 2018，排行榜数据集由来自 10 个声学场景的 10 秒音频片段组成：</p><pre>机场&nbsp;-&nbsp;airport\n室内购物中心-shopping_mall\n地铁站&nbsp;-&nbsp;metro_station\n步行街&nbsp;-&nbsp;street_pedestrian\n公共广场&nbsp;-&nbsp;public_square\n街道交通&nbsp;-&nbsp;street_traffic\n乘坐有轨电车&nbsp;-&nbsp;tram\n公交车上-&nbsp;bus\n乘地铁旅行&nbsp;-&nbsp;metro\n城市公园-&nbsp;park</pre><p></p><h2>TAU Urban Acoustic Scenes 2019</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/2589280#.YzU6yHZBxjW\" rel=\"noopener\">Development dataset</a> (35.6 GB)&nbsp;</p></li><li><p><a href=\"https://zenodo.org/record/3063822#.YzUeVHZBxjU\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(17.9 GB)</p></li><li><p><a href=\"https://zenodo.org/record/2672993#.YzUeZHZBxjU\" rel=\"noopener\">Leaderboard dataset</a>&nbsp;(3.0 GB)</p></li></ul><p>音频参数：48kHz，双声道，24位深</p></blockquote><p>包含来自 10 个声学场景的 10 秒音频片段，每个声学场景有 1440 个片段（240 分钟的音频）。该数据集总共包含 40 小时的音频。</p><pre>-&nbsp;机场&nbsp;-airport-&nbsp;室内购物中心&nbsp;-&nbsp;shopping_mall-&nbsp;地铁站&nbsp;-&nbsp;metro_station-&nbsp;步行街&nbsp;-&nbsp;street_pedestrian-&nbsp;公共广场&nbsp;-&nbsp;public_square-&nbsp;街道交通&nbsp;-&nbsp;street_traffic-&nbsp;乘坐有轨电车&nbsp;-&nbsp;tram-&nbsp;公交车上-&nbsp;bus-&nbsp;乘地铁旅行&nbsp;-&nbsp;metro-&nbsp;城市公园-&nbsp;park</pre><p></p><h2>TAU Urban Acoustic Scenes 2020 Mobile</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/3819968#.YzVS8HZBxjU\" rel=\"noopener\">Development dataset</a>&nbsp;(27.4 GB)</p></li><li><p><a href=\"https://zenodo.org/record/3685828#.YzVTFXZBxjU\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(13.1 GB)</p></li></ul><p>音频参数：48kHz，双声道，24位深</p></blockquote><p>TUT城市声学场景2020移动开发数据集由10个声学场景中的10秒音频片段组成</p><pre>机场&nbsp;-&nbsp;airport\n室内购物中心-shopping_mall\n地铁站&nbsp;-&nbsp;metro_station\n步行街&nbsp;-&nbsp;street_pedestrian\n公共广场&nbsp;-&nbsp;public_square\n街道交通&nbsp;-&nbsp;street_traffic\n乘坐有轨电车&nbsp;-&nbsp;tram\n公交车上&nbsp;-&nbsp;bus\n乘地铁旅行&nbsp;-&nbsp;metro\n城市公园-&nbsp;park</pre><p></p><h2>TAU Urban Acoustic Scenes 2020 3Class</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/3670185#.YzVLRnZBxjU\" rel=\"noopener\">Development dataset</a>&nbsp;(35.5 GB)</p></li><li><p><a href=\"https://zenodo.org/record/3685835#.YzVLMnZBxjU\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(20.9 GB)</p></li></ul><p>音频参数：48kHz，双声道，24位深</p></blockquote><p>TAU Urban Acoustic Scenes 2020 3Class 数据集由来自 10 个声学场景的 10 秒音频片段组成，分为以下三大类 ：</p><pre>-&nbsp;室内场景——*室内*：\n&nbsp;&nbsp;&nbsp;&nbsp;机场：airport\n&nbsp;&nbsp;&nbsp;&nbsp;室内商场：indoor&nbsp;shopping&nbsp;mall\n&nbsp;&nbsp;&nbsp;&nbsp;地铁站：metro&nbsp;station-&nbsp;户外场景-*户外*：\n&nbsp;&nbsp;&nbsp;&nbsp;步行街：pedestrian&nbsp;street\n&nbsp;&nbsp;&nbsp;&nbsp;公共广场：public&nbsp;square\n&nbsp;&nbsp;&nbsp;&nbsp;中等交通街道：street&nbsp;with&nbsp;medium&nbsp;level&nbsp;of&nbsp;traffic\n&nbsp;&nbsp;&nbsp;&nbsp;城市公园：urban&nbsp;park-&nbsp;交通相关场景-*交通*：\n&nbsp;&nbsp;&nbsp;&nbsp;乘坐公共汽车：travelling&nbsp;by&nbsp;a&nbsp;bus\n&nbsp;&nbsp;&nbsp;&nbsp;乘坐电车：travelling&nbsp;by&nbsp;a&nbsp;tram\n&nbsp;&nbsp;&nbsp;&nbsp;乘坐地铁：travelling&nbsp;by&nbsp;an&nbsp;underground&nbsp;metro</pre><p></p><h2>TAU Urban Audio-Visual Scenes 2021</h2><blockquote><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/4477542#.YzVMcHZBxjU\" rel=\"noopener\">Development dataset</a>&nbsp;(107.7 GB)</p></li><li><p><a href=\"https://zenodo.org/record/4767103#.YzVMcHZBxjU\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(61.2 GB)</p></li></ul><p>音频参数：</p></blockquote><pre>机场&nbsp;-&nbsp;airport\n室内购物中心-shopping_mall\n地铁站&nbsp;-&nbsp;metro_station\n步行街&nbsp;-&nbsp;street_pedestrian\n公共广场&nbsp;-&nbsp;public_square\n街道交通&nbsp;-&nbsp;street_traffic\n乘坐有轨电车&nbsp;-tram\n公交上&nbsp;-bus\n乘地铁旅行&nbsp;-metro\n城市公园-park</pre><p></p><h2>TAU Urban Acoustic Scenes 2021 Mobile</h2><p>下载地址：<a href=\"https://zenodo.org/record/4767109#.YzVQiXZBxjV\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(8.8 GB)</p><p>音频参数：44.1kHz；单声道；24位深</p><pre>机场&nbsp;-&nbsp;airport\n室内购物中心-shopping_mall\n地铁站&nbsp;-&nbsp;metro_station\n步行街&nbsp;-&nbsp;street_pedestrian\n公共广场&nbsp;-&nbsp;public_square\n街道交通&nbsp;-&nbsp;street_traffic\n乘坐有轨电车&nbsp;-tram\n公交车上&nbsp;-bus\n乘地铁旅行&nbsp;-metro\n城市公园-park</pre><p></p><h2>TAU Urban Acoustic Scenes 2022 Mobile</h2><p>下载地址：</p><ul class=\" list-paddingleft-2\"><li><p><a href=\"https://zenodo.org/record/6337421#.YzVQrXZBxjU\" rel=\"noopener\">Development dataset</a>&nbsp;(27.5 GB)</p></li><li><p><a href=\"https://zenodo.org/record/6591203#.YzVR4nZBxjU\" rel=\"noopener\">Evaluation dataset</a>&nbsp;(13.2 GB)</p></li></ul><p>音频参数：44.1kHz；单声道；24位深</p><pre>机场&nbsp;-&nbsp;airport\n室内购物中心&nbsp;-&nbsp;shopping_mall\n地铁站&nbsp;-&nbsp;metro_station\n步行街&nbsp;-&nbsp;street_pedestrian\n公共广场&nbsp;-&nbsp;public_square\n街道交通&nbsp;-&nbsp;street_traffic\n乘坐有轨电车&nbsp;-&nbsp;tram\n公交车上-&nbsp;bus\n地铁&nbsp;-&nbsp;metro\n城市公园-&nbsp;park</pre><p></p><h1>综合数据集&nbsp;</h1><p>综合数据集是 既有语音又有噪声的数据集</p><h2>MUSAN</h2><blockquote><p>地址：<a href=\"https://www.openslr.org/17/\" target=\"_blank\" rel=\"noopener\">传送门</a>（11G）</p></blockquote><p>音乐、语音和噪音的语料库</p><h2>FSDnoisy18k</h2><p>下载地址：<a href=\"http://www.eduardofonseca.net/FSDnoisy18k/\" target=\"_blank\" rel=\"noopener\">传送门</a>&nbsp;(9.5 GB)</p><p>FSDnoisy18k 是一个音频数据集，旨在促进对声音事件分类中标签噪声的调查。它包含 20 个声音类别的 42.5 小时音频，包括少量手动标记的数据和大量真实世界的嘈杂数据。</p><h2>DS_10283_2791</h2><p><a href=\"https://datashare.ed.ac.uk/handle/10283/2791?show=full\" rel=\"noopener\">用于训练语音增强算法和 TTS 模型的嘈杂语音数据库</a></p><p>干净和嘈杂的并行语音数据库。该数据库旨在训练和测试以 48kHz 运行的语音增强方法。更详细的描述可以在与数据库相关的论文中找到。对于 28 个说话人数据集，详细信息可参见：C. Valentini-Botinhao、X. Wang、S. Takaki 和 J. Yamagishi，“使用深度循环神经网络的噪声鲁棒文本到语音合成系统的语音增强” “，在过程中。Interspeech 2016。对于 56 位说话者数据集：C. Valentini-Botinhao、X. Wang、S. Takaki 和 J. Yamagishi，“研究基于 RNN 的语音增强方法以实现抗噪文本到语音”，In Proc. SSW 2016. 用于创建嘈杂语音的一些噪音来自需求数据库，可在此处获得：http://parole.loria.fr/DEMAND/。语音数据库来自 CSTR VCTK 语料库，可在此处获取：https://doi.org/10.7488/ds/1994。用于创建此数据集的语音和 babble 噪声文件可在此处获得：http://homepages.inf.ed.ac.uk/cvbotinh/se/noises/。</p><h2 class=\"page-header first-page-header\">CSTR NAM TIMIT Plus</h2><p>下载地址：<a href=\"https://datashare.ed.ac.uk/handle/10283/3849https://datashare.ed.ac.uk/handle/10283/3849\" target=\"_blank\" rel=\"noopener\">传送门</a>（1.342G）</p><p>综合数据集就是啥也有</p><p><a href=\"https://datashare.ed.ac.uk/handle/10283/2791\" target=\"_blank\" rel=\"noopener\">DNS-Challenge：https://github.com/microsoft/DNS-Challenge/tree/master/datasets</a></p><p><a href=\"https://datashare.ed.ac.uk/handle/10283/2791\" target=\"_blank\" rel=\"noopener\">Noisy speech database for training speech enhancement algorithms and TTS models</a></p><p>OpenSLR：<a href=\"https://openslr.org/\" target=\"_blank\" rel=\"noopener\">https://openslr.org/</a></p><ul class=\" list-paddingleft-2\"><li><p>12：<a href=\"https://www.openslr.org/12\" target=\"_blank\" rel=\"noopener\">LibriSpeech ASR 语料库</a></p></li><li><p>17：<a href=\"https://openslr.org/17/\" target=\"_blank\" rel=\"noopener\">A corpus of music, speech, and noise</a></p></li><li><p>18：<a href=\"https://www.openslr.org/18/\" target=\"_blank\" rel=\"noopener\">THCHS-30清华大学发布的免费中文语音语料库</a></p></li><li><p>28：<a href=\"https://openslr.org/28/\" target=\"_blank\" rel=\"noopener\">OpenSLR&nbsp;房间脉冲响应和噪声数据库</a></p></li><li><p>38：<a href=\"https://www.openslr.org/38/\" target=\"_blank\" rel=\"noopener\">冲浪科技的免费中文普通话语料库</a>，包含855个说话者的话语，102600个话语；</p></li><li><p>60：<a href=\"https://www.openslr.org/60/\" target=\"_blank\" rel=\"noopener\">LibriTTS语料库</a>，自LibriSpeech语料库原始资料的大规模英语语音语料库</p></li><li><p>62：<a href=\"http://www.openslr.org/62/\" target=\"_blank\" rel=\"noopener\">aidatatang_200zh</a>，北京数据堂科技有限公司的中文普通话语音语料库，包含来自600位说话者的200小时语音数据。每个句子的转录准确率大于 98%</p></li><li><p>68：<a href=\"https://www.openslr.org/68/\" target=\"_blank\" rel=\"noopener\">MAGICDATA 汉语普通话朗读语料库</a>，魔数据科技有限公司的语料库，包含 755 小时的脚本阅读语音数据，来自中国大陆的 1080 位母语为普通话的人。句子转录准确率高于98%。</p></li></ul><p>&nbsp;</p><h1>参考</h1><p>【知乎】<a href=\"https://zhuanlan.zhihu.com/p/267372288\" target=\"_blank\" rel=\"noopener\">语音数据集整理</a></p><p>【github】<a href=\"https://github.com/coqui-ai/open-speech-corpora\" data-pjax=\"#js-repo-pjax-container\" rel=\"noopener\">open-speech-corpora</a></p>',1,NULL,1,'https://www.cnblogs.com/LXP-Never/p/15474948.html','2022-10-07 18:30:39'),(45,'在PE文件中简单注入代码，实现在启动前弹窗',NULL,NULL,0,0,'<h5 id=\"获得的新知识\">获得的新知识：</h5> \n<p>1、kernel32.dll，user32.dll，ntdll.dll等一些dll在<strong>同一个PC</strong>环境下的映射到虚拟内存基址是一样的。<br> 2、在win8以上系统上，更改PE文件的入口点要大于SizeOfHeaders(在可选文件头中)，否则会报错无法运行。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/1c240fbf-1251-44ff-a979-ded28bdfe438.png\" alt=\"\" loading=\"lazy\"></p> \n<h2 id=\"1实现原理\">1、实现原理</h2> \n<p>PE可选文件头有一个AddressOfEntryPoint，更改这个值指向自己代码，执行完自己代码再跳转到原来入口点。</p> \n<h2 id=\"2实验过程\">2、实验过程</h2> \n<p>1、字节的代码<br> shellcode: <code>6A 00 6A 00 6A 00 E8 __ __ __ __ E9 __ __ __ ___</code><br> 调用messagebox过程，压栈调用<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/92a9df7d-6f09-4f3d-a49c-8ef8304af403.png\" alt=\"\" loading=\"lazy\"></p> \n<p>这里用了IAT表，为了简单起见直接使用user32.dll中messagebox的地址<br> e8指令是call指令，后面要补充相对messagbox的地址，e9是jmp指令，要补充相对入口点地址。</p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/6fa973a3-e397-44ab-b30c-880fe293d80e.png\" alt=\"\" loading=\"lazy\"><br> 将代码注入这个程序</p> \n<p>用x32dbg查messagebox地址是0x<strong>76D160660</strong>。程序入口点为0x<strong>00401140</strong>。shellcode入口点设置为0x<strong>00401030</strong><br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/de5dc61b-f408-4231-996f-57fd366bd779.png\" alt=\"\" loading=\"lazy\"></p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/916c4db2-15a2-4038-9a32-5edb8f61bf40.png\" alt=\"\" loading=\"lazy\"></p> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/9d676e0e-35d0-4fde-ac2e-8de05952968b.png\" alt=\"\" loading=\"lazy\"></p> \n<h3 id=\"用wenhex写入shellcode\">用wenhex写入shellcode</h3> \n<p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/3bd64657-a32e-45e7-b335-c1e165a90475.png\" alt=\"\" loading=\"lazy\"></p> \n<p>再把程序入口点修改了<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/17d1b56a-809d-41d5-9fd8-2821b5b06fc7.png\" alt=\"\" loading=\"lazy\"></p> \n<p>最后，完美运行<br> <img src=\"http://localhost:8080/static/blogImages/2022/10/07/e62c7ca3-8e7e-4120-8731-00de37cd1470.png\" alt=\"\" loading=\"lazy\"></p>',100,NULL,0,'https://www.cnblogs.com/zz89/p/16760396.html','2022-10-07 19:01:01'),(46,'网络工程试验（一）链路聚合的三种情况','复习一下华为基础的数通命令吧，原创文章，可能有技术理解错误，欢迎指正，请与我联系，谢谢！\n 介绍-链路聚合（eth-trunk）将交换机两条或以上的二层物理接口绑定为一条逻辑接口：目的：链路带宽叠加、链路负载均衡、提高可靠性（只要绑定的物理端口未全部故障，逻辑端口可正常工作）链路聚合有两种模式：手工负载分担模','2022-10-07 19:37:12',0,0,'<p><span data-offset-key=\"aqe11-0-0\">复习一下华为基础的数通命令吧，原创文章，可能有技术理解错误，欢迎指正，请与我联系，谢谢！</span>\n </p><h1 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"dm385-0-0\"><span data-offset-key=\"dm385-0-0\">介绍-链路聚合（eth-trunk）</span></h1><ul class=\"public-DraftStyleDefault-ul list-paddingleft-2\" data-offset-key=\"129tu-0-0\"><li><p><span data-offset-key=\"129tu-0-0\">将交换机两条或以上的二层物理接口绑定为一条逻辑接口：</span></p></li><ul class=\" list-paddingleft-2\" style=\"list-style-type: square;\"><li><p><span data-offset-key=\"77vun-0-0\"><strong>目的</strong>：链路带宽叠加、链路负载均衡、提高可靠性（只要绑定的物理端口未全部故障，逻辑端口可正常工作）</span></p></li></ul><li><p><span data-offset-key=\"ebaur-0-0\">链路聚合有两种模式：</span></p></li><ul class=\" list-paddingleft-2\" style=\"list-style-type: square;\"><li><p><span data-offset-key=\"8rj33-0-0\"><strong>手工负载分担模式</strong><span data-offset-key=\"8rj33-0-1\">（要求相连端口要一样的<span data-offset-key=\"8rj33-0-2\"><strong>端口类型</strong><span data-offset-key=\"8rj33-0-3\"><strong>、</strong><span data-offset-key=\"8rj33-0-4\"><strong>速率</strong><span data-offset-key=\"8rj33-0-5\"><strong>、</strong><span data-offset-key=\"8rj33-0-6\"><strong>双工模式、同vlan</strong><span data-offset-key=\"8rj33-0-7\">）</span></span></span></span></span></span></span></span></p></li><li><p><span data-offset-key=\"5k4e6-0-0\"><strong>LACP模式</strong><span data-offset-key=\"5k4e6-0-1\">（自动协商，自动设置活动端口和备份端口，备份端口在活动端口故障时候工作）</span></span></p></li></ul></ul><h1 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"eoi74-0-0\"><span data-offset-key=\"eoi74-0-0\">一、配置-手工负载分担模式</span></h1><h2 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"92ao4-0-0\"><span data-offset-key=\"92ao4-0-0\">绘制拓扑</span></h2><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/dafd9637-bf1c-45ec-834d-062dd3e0317b.png\" alt=\"\" loading=\"lazy\" style=\"display: block; margin-left: auto; margin-right: auto\"/>\n &nbsp; &nbsp;</p><p><strong>图1</strong>.链路聚合拓扑</p><h2 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"6tq0v-0-0\"><span data-offset-key=\"6tq0v-0-0\">设置端口协商</span></h2><ul class=\"public-DraftStyleDefault-ul list-paddingleft-2\" data-offset-key=\"ai0nf-0-0\"><li><p><span data-offset-key=\"ai0nf-0-0\">S1和S2同理，关键目录加粗显示</span></p></li></ul><pre>//可选，关闭终端输出，敲着命令突然来一堆文字，思路都被打断了呢&nbsp;un&nbsp;t&nbsp;m&lt;Huawei&gt;undo&nbsp;terminal&nbsp;monitor&nbsp;//进入系统视图&lt;Huawei&gt;system-view&nbsp;//设置交换机的名称[Huawei]sysname&nbsp;S1&nbsp;//创建临时组方便同时配置（类似于思科交换机的range命令），当然也可以创建永久组[S1]port-group&nbsp;group-member&nbsp;GigabitEthernet&nbsp;0/0/9&nbsp;GigabitEthernet&nbsp;0/0/10//关闭自动协商模式[S1-port-group]undo&nbsp;negotiation&nbsp;auto[S1-GigabitEthernet0/0/9]undo&nbsp;negotiation&nbsp;auto[S1-GigabitEthernet0/0/10]undo&nbsp;negotiation&nbsp;auto&nbsp;//设置接口速率为&nbsp;1000Mbit/s[S1-port-group]speed&nbsp;1000[S1-GigabitEthernet0/0/9]speed&nbsp;1000[S1-GigabitEthernet0/0/10]speed&nbsp;1000//设置双工模式为全双工[S1-port-group]duplex&nbsp;full[S1-GigabitEthernet0/0/9]duplex&nbsp;full\n[S1-GigabitEthernet0/0/10]duplex&nbsp;full&gt;quit</pre><p></p><h2><span style=\"font-size: 1em\">设置链路聚合端口绑定</span></h2><ul class=\" list-paddingleft-2\"><li><p><span data-offset-key=\"dkhr7-0-0\">S1和S2同理</span></p></li></ul><pre>//创建链路聚合接口1，并进入。这个编号本地有效，S1和S2可以设置不一样的编号，范围0-63[S1]interface&nbsp;Eth-Trunk&nbsp;1//模式为手工负载均衡[S1-Eth-Trunk1]mode&nbsp;manual&nbsp;load-balance&nbsp;&nbsp;&nbsp;//LACP模式模式在这里有所不同，为mode&nbsp;lacp-static&gt;quit//进到端口去设置链路聚合的绑定（eth-trunk命令在port-group下用不了，老老实实这样操作吧）[S1]interface&nbsp;GigabitEthernet&nbsp;0/0/9&nbsp;//将接口&nbsp;0/0/9&nbsp;接入到聚合链路&nbsp;1&nbsp;中[S1-GigabitEthernet0/0/9]eth-trunk&nbsp;1&gt;quit//同理[S1]interface&nbsp;GigabitEthernet&nbsp;0/0/10//将接口&nbsp;0/0/10&nbsp;接入到聚合链路&nbsp;1&nbsp;中[S1-GigabitEthernet0/0/10]eth-trunk&nbsp;1&gt;quit</pre><p>&nbsp;</p><h2><span data-offset-key=\"an43l-0-0\">查看绑定情况</span></h2><ul class=\"public-DraftStyleDefault-ul list-paddingleft-2\" data-offset-key=\"d46jf-0-0\"><li><p><span data-offset-key=\"d46jf-0-0\">查看端口信息</span></p></li><li><p><span data-offset-key=\"ahdn3-0-0\">display interface Eth-Trunk <span data-offset-key=\"ahdn3-0-1\">1</span></span></p></li><li><p><span data-offset-key=\"36bmg-0-0\">display Eth-Trunk <span data-offset-key=\"36bmg-0-1\">1</span></span></p></li><li><p><span data-offset-key=\"cjq3s-0-0\">display STP brief<span data-offset-key=\"cjq3s-0-1\">、用生成树看也得</span></span></p></li></ul><pre>[S1]display&nbsp;interface&nbsp;Eth-Trunk&nbsp;1Eth-Trunk1&nbsp;current&nbsp;state&nbsp;:&nbsp;UP\nLine&nbsp;protocol&nbsp;current&nbsp;state&nbsp;:&nbsp;UP\nDescription:\nSwitch&nbsp;Port,&nbsp;PVID&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;1,&nbsp;Hash&nbsp;arithmetic&nbsp;:&nbsp;According&nbsp;to&nbsp;SIP-XOR-DIP,Maximal&nbsp;BW:\n&nbsp;2G,&nbsp;Current&nbsp;BW:&nbsp;2G,&nbsp;The&nbsp;Maximum&nbsp;Frame&nbsp;Length&nbsp;is&nbsp;9216IP&nbsp;Sending&nbsp;Frames&#39;&nbsp;Format&nbsp;is&nbsp;PKTFMT_ETHNT_2,&nbsp;Hardware&nbsp;address&nbsp;is&nbsp;4c1f-cc78-1170Current&nbsp;system&nbsp;time:&nbsp;2022-08-14&nbsp;18:32:18-08:00\n&nbsp;&nbsp;&nbsp;&nbsp;Input&nbsp;bandwidth&nbsp;utilization&nbsp;&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;0%\n&nbsp;&nbsp;&nbsp;&nbsp;Output&nbsp;bandwidth&nbsp;utilization&nbsp;:&nbsp;&nbsp;&nbsp;&nbsp;0%\n-----------------------------------------------------PortName&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Status&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Weight-----------------------------------------------------&nbsp;GigabitEthernet0/0/9&nbsp;UP&nbsp;1&nbsp;GigabitEthernet0/0/10&nbsp;UP&nbsp;1-----------------------------------------------------The&nbsp;Number&nbsp;of&nbsp;Ports&nbsp;in&nbsp;Trunk&nbsp;:&nbsp;2The&nbsp;Number&nbsp;of&nbsp;UP&nbsp;Ports&nbsp;in&nbsp;Trunk&nbsp;:&nbsp;2</pre><p></p><h1 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"e6qo8-0-0\"><span data-offset-key=\"e6qo8-0-0\">二、拓展-三层设备配置手工负载分担模式</span></h1><h2 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"70oq1-0-0\"><span data-offset-key=\"70oq1-0-0\">绘制拓扑</span></h2><ul class=\"public-DraftStyleDefault-ul list-paddingleft-2\" data-offset-key=\"b5n72-0-0\"><li><p><span data-offset-key=\"b5n72-0-0\">使用三层交换机、路由器、防火墙效果一样的</span></p></li></ul><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/78dbc318-0921-4091-9d52-8c83ddda7ba1.png\" class=\"Image FocusPlugin--unfocused Image--isBlock\" style=\"display: block; margin-left: auto; margin-right: auto\" data-size=\"normal\" data-rawwidth=\"528\" data-rawheight=\"184\" data-watermark=\"watermark\" data-original-src=\"https://picx.zhimg.com/v2-ce13fd8c4e57772145ded911310198ff_720w.jpg?source=d16d100b\" data-watermark-src=\"https://picx.zhimg.com/v2-e044329b8ec305f471023fce93ff26bb_720w.jpg?source=d16d100b\"/> \n &nbsp; &nbsp; &nbsp;</p><p><strong>图2</strong>.三层设备下的链路聚合</p><h2 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"dm2q0-0-0\"><span data-offset-key=\"dm2q0-0-0\">设置链路聚合和绑定</span></h2><ul class=\"public-DraftStyleDefault-ul list-paddingleft-2\" data-offset-key=\"e5vsm-0-0\"><li><p><span data-offset-key=\"e5vsm-0-0\">R1和R2同理，只不过多一步为Eth-Trunk逻辑接口绑定的IP。</span>&nbsp;</p></li></ul><pre>//可以参考上部分&lt;Huawei&gt;un&nbsp;t&nbsp;m\nInfo:&nbsp;Current&nbsp;terminal&nbsp;monitor&nbsp;is&nbsp;off.&lt;Huawei&gt;sys\nEnter&nbsp;system&nbsp;view,&nbsp;return&nbsp;user&nbsp;view&nbsp;with&nbsp;Ctrl+Z.\n[Huawei]sys&nbsp;R1//#########################//创建链路聚合接口1，并进入。三层设备的链路聚合端口需要设置ip[R1]interface&nbsp;Eth-Trunk&nbsp;1//切换链路聚合端口为三层模式[R1-Eth-Trunk1]undo&nbsp;portswitch&nbsp;&nbsp;//这里最重要之一啦//set&nbsp;ip[R1-Eth-Trunk1]ip&nbsp;address&nbsp;192.168.1.1&nbsp;24&nbsp;&gt;q//进入到目标物理端口来绑定吧[R1]interface&nbsp;GigabitEthernet&nbsp;0/0/1[R1-GigabitEthernet0/0/1]eth-trunk&nbsp;1&gt;q\n[R1]interface&nbsp;GigabitEthernet0/0/0[R1-GigabitEthernet0/0/0]eth-trunk&nbsp;1&gt;q</pre><p></p><p>&nbsp;</p><h1 class=\"public-DraftStyleDefault-block public-DraftStyleDefault-ltr\" data-offset-key=\"9f1k4-0-0\"><span data-offset-key=\"9f1k4-0-0\">三、拓展-LACP模式</span></h1><ul class=\"public-DraftStyleDefault-ul list-paddingleft-2\" data-offset-key=\"6n6s0-0-0\"><li><p><span data-offset-key=\"6n6s0-0-0\">其实LACP模式在绑定端口设置端口熟悉下和手动配置一样</span></p></li><li><p><span data-offset-key=\"1mh6h-0-0\">在<span data-offset-key=\"1mh6h-0-1\"><strong><span style=\"color: rgba(255, 0, 0, 1)\">mode manual load-balance</span></strong><span data-offset-key=\"1mh6h-0-2\">处配置有所不同配置为<span data-offset-key=\"1mh6h-0-3\"><strong><span style=\"color: rgba(255, 0, 0, 1)\">mode lacp-static</span></strong><span data-offset-key=\"1mh6h-0-4\">。</span></span></span></span></span></p></li><li><p><span data-offset-key=\"1scbm-0-0\">我这边就从这里拓展</span></p></li></ul><p><img src=\"http://localhost:8080/static/blogImages/2022/10/07/21f6823b-aa79-445a-976e-b2cfb6709646.png\" class=\"Image FocusPlugin--unfocused Image--isBlock\" style=\"display: block; margin-left: auto; margin-right: auto\" data-size=\"normal\" data-rawwidth=\"534\" data-rawheight=\"205\" data-watermark=\"watermark\" data-original-src=\"https://picx.zhimg.com/v2-69880f69b19d458f9664e7b71b009613_720w.jpg?source=d16d100b\" data-watermark-src=\"https://picx.zhimg.com/v2-6602795633f1edd24f91b91cad2ca5f0_720w.jpg?source=d16d100b\"/>\n &nbsp;</p><p><span class=\"prism-token token punctuation\"><strong>图3</strong>.拓展LACP模式</span></p><pre>[S1]interface&nbsp;Eth-Trunk&nbsp;1//LACP模式模式[S1-Eth-Trunk1]mode&nbsp;lacp-static&nbsp;&gt;quit//进到端口去设置链路聚合的绑定[S1]interface&nbsp;GigabitEthernet&nbsp;0/0/1[S1-GigabitEthernet0/0/1]eth-trunk&nbsp;1&gt;q//同理[S1]interface&nbsp;GigabitEthernet&nbsp;0/0/2[S1-GigabitEthernet0/0/2]eth-trunk&nbsp;1&gt;q//同理[S1]interface&nbsp;GigabitEthernet&nbsp;0/0/3[S1-GigabitEthernet0/0/3]eth-trunk&nbsp;1&gt;q</pre><p></p><ul class=\" list-paddingleft-2\"><li><p>lacp模式下，会有备份的端口，在主用端口出故障时会顶替上</p></li><li><p>所以会有一条链路其实是不在工作中，所以一般比手工模式多一个端口</p></li></ul>',11,NULL,1,'https://www.cnblogs.com/alittlemc/p/16760410.html','2022-10-07 19:30:06'),(47,'结束与开始',NULL,NULL,0,0,'<p>　　我很少在博客上闲聊，除了技术文章，我觉得说些什么都显得矫情。毕竟，你的问题，大多数人都经历过，有什么好逼逼的。所以我从未在这里表达过个人的情绪或者生活的状态。只是分享下我个人对于某些技术点的理解，虽然，嗯……大多数都是抄的，或者边学边写的。哈哈哈</p> \n<p>　　但是，现在的这个时间点，对于我来说，颇具特殊意义，是过去的结束，和未来的开始。无论是学习的计划，还是生活的节奏，还是思想上的感悟，都即将步入一个新的阶段。</p> \n<p>　　我时常会想起如果我早一点接触编程，早一点接触代码，会不会比现在要更从容一些。还记得六、七年前刚到培训班的时候，当时老师说你可以选Web前端、安卓和IOS，问我选哪个，我不知道该怎么选，就问老师都有啥区别啊。老师说：Web前端范围更广，安卓就是安卓手机上，IOS就是苹果手机，我想都能跑的范围更广的肯定更好一些，于是就走上了Web前端这条路。</p> \n<p>　　想要感慨下这些年面临的问题，却又着实不知该从何慨起。想到什么就说什么吧。</p> \n<p>　　六年，我觉得对于六年的前端来说，应该没有不会的问题，可以针对任何场景给出建设性的解决方案。可惜，说来十分惭愧，感觉我还远远达不到自己以为的这样的目标。那我就会问自己，为什么达不到，无非就是自己还不够努力，若是能早些接触程序，编程，或许现在又会是另一番样子。</p> \n<p>　　时光不会倒流，人生也没有如果，现在的样子或许就是最好的样子。</p> \n<p>　　我写博客，其实最主要的目的是学习，如果能在自己学习的过程中帮助一些人，那就足够让我开心好久，比如我之前总结那篇css垂直居中问题，竟然得到了编辑推荐，真的让我开心了好久。就是那种被认可，被鼓励的感觉。</p> \n<p>　　感谢那些曾看过我文章的人们，感谢曾为我点过赞，评论过的人，一直以来，感谢~</p> \n<p>　　最后，我要离开博客园了，说实话我真的很喜欢这里，也从不后悔当初选择博客园作为我分享的地方，但是时代在进步，我想要换个地方重新开始。在这个特殊的时间点上，巧合的是，现在的阶段，我打算下一步要写写Webpack系列，而我记得我刚来博客园的第一个系列也是关于基本Webpack应用的，虽然，我可以坦白的说，那整个系列都是抄的，那时候的我，还远没有能力去写关于Webpack的技术内容，而惭愧的是，那个系列的阅读最多，每每看到，都让我觉得有些无地自容。不过，现在好像可以写一些自己的想法了~所以，真的觉得似乎冥冥中有些什么东西。</p> \n<p>　　嗯~最后的最后，其实我只是个无名小卒啦，没有大厂背景，没有瞩目的学历，更没有深厚的家底，只是一个再普通不过的一个程序员。但是，我总是希望能在这浩瀚的海洋里漂泊的时候能获得一丝丝的鼓励和认可。</p> \n<p>　　最后，仍是感谢。</p> \n<p>　　祝那些一起在这条路上攀登的你们，也祝我自己，守得云开见月明，不知此去经年，归来仍是少年。</p> \n<p>　　</p>',100,NULL,0,'https://www.cnblogs.com/zaking/p/16758806.html','2022-10-07 19:30:06');

/*Table structure for table `t_links` */

DROP TABLE IF EXISTS `t_links`;

CREATE TABLE `t_links` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `linkName` varchar(128) DEFAULT NULL,
  `linkUrl` varchar(128) DEFAULT NULL,
  `orderNo` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

/*Data for the table `t_links` */

insert  into `t_links`(`id`,`linkName`,`linkUrl`,`orderNo`) values (1,'etoak','http://www.etoak.com',1),(2,'etjava','http://www.etjava.com',2),(3,'java','http://www.sun.com',3);

/*Table structure for table `t_music` */

DROP TABLE IF EXISTS `t_music`;

CREATE TABLE `t_music` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `musicName` varchar(64) DEFAULT NULL,
  `albumId` int(11) DEFAULT NULL COMMENT '专辑ID',
  `author` varchar(32) DEFAULT NULL COMMENT '作者',
  `musicUrl` varchar(1024) DEFAULT NULL COMMENT '内容',
  `createDate` datetime DEFAULT NULL COMMENT '加入时间',
  `state` int(11) DEFAULT '0' COMMENT '状态 1有效',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `t_music` */

insert  into `t_music`(`id`,`musicName`,`albumId`,`author`,`musicUrl`,`createDate`,`state`) values (1,'我来人间一趟',1,NULL,'<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=80 height=86 src=\"//music.163.com/outchain/player?type=2&id=1964496436&auto=0&height=66\"></iframe>','2022-10-03 00:00:00',1);

/*Table structure for table `t_user` */

DROP TABLE IF EXISTS `t_user`;

CREATE TABLE `t_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `userName` varchar(32) DEFAULT NULL,
  `password` varchar(128) DEFAULT NULL,
  `profile` text COMMENT '简介',
  `nickName` varchar(32) DEFAULT NULL COMMENT '昵称',
  `sign` varchar(64) DEFAULT NULL COMMENT '个性签名',
  `imageName` varchar(128) DEFAULT NULL COMMENT '头像路径',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

/*Data for the table `t_user` */

insert  into `t_user`(`id`,`userName`,`password`,`profile`,`nickName`,`sign`,`imageName`) values (1,'ETJAVA','ab165311d3b084d3723d40364ff1496f','<p>Justice delayed is justice denied<br/></p><p><br/></p>','etjava','Justice delayed is justice denied','logo.png');

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
